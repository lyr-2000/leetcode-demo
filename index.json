[{"categories":null,"contents":"欢迎来到我的文档站 github地址 个人独立博客地址 csdn博客 博客园 一起听歌,放松 特此声明 本站所有的原创文章均受 创作共享 署名-非商业性 4.0 许可协议 / CC BY-NC 4.0 保护。\n任何个人及媒体在转载本站原创内容（包含文字、自制图像、摄影作品）时请遵守以下版权要求：\n注明转载 注明来源为本站首页网址 blog.lyr-2000.xyz ，或所转内容在本站的完整网址 本站图片部分来自互联网。 此类图片的原版权所有者可在任何时候、以任何理由要求本站停止使用有关图片，其中包括被本站编辑（比如加注中文说明）过的图片， 联系方式见本站首页。\n","date":"2017-08-20T21:38:52+08:00","permalink":"https://lyr-2000.github.io/code/about/","tags":null,"title":"关于"},{"categories":null,"contents":"","date":"2017-08-20T21:38:52+08:00","permalink":"https://lyr-2000.github.io/code/search/","tags":null,"title":"搜索"},{"categories":["链表"],"contents":"给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func swapPairs(head *ListNode) *ListNode { if(head == nil || head.Next==nil) { return head } //x=head,y = head.Next, z = head.Next.Next return swapPairs2( head ,next(head),next(next(head))) } func next(a *ListNode) *ListNode { if a == nil { return nil } return a.Next } func swapPairs2(x,y,z *ListNode) *ListNode { if x == nil { return nil } if y == nil { return x } if z == nil { y.Next = x x.Next = z return y } // z is not nil y.Next = x x.Next = swapPairs2(z,next(z),next(next(z))) //x=head,y = head.Next, z = head.Next.Next return y } ","date":"2024-12-07T00:49:32+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8/","tags":["链表"],"title":"两两交换链表"},{"categories":["双指针"],"contents":"给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。\n返回这三个数的和。\n假定每组输入只存在恰好一个解。\n示例 1：\n输入：nums = [-1,2,1,-4], target = 1\n输出：2\n解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import \u0026#34;sort\u0026#34; import \u0026#34;math\u0026#34; func threeSumClosest(nums []int, target int) int { sort.Ints(nums) n := len(nums) if n \u0026lt;3 { return -1 } res := nums[0] + nums[1] + nums[2] for i := 0;i\u0026lt;n;i++ { for j:=i+1;j\u0026lt;n;j++ { k := n-1 for j \u0026lt; k { sum := nums[i] + nums[j] + nums[k] if sum \u0026gt; target { k-- }else { j++ } if abs(target - sum) \u0026lt; abs(target - res ) { res = sum } } } } if res == int(math.MaxInt) { return -1 } return res } func abs(i int ) int { if i \u0026lt; 0 { return -i } return i } ","date":"2024-12-07T00:41:37+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/lc16.%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","tags":["双指针"],"title":"lc16.最接近的三数之和"},{"categories":["链表"],"contents":"给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { var h ListNode h.Next = head l,r := \u0026amp;h,head for range n { r= r.Next } for r != nil { l = l.Next r = r.Next } l.Next = l.Next.Next return h.Next } ","date":"2024-12-07T00:30:02+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","tags":["链表"],"title":"删除链表第k个节点"},{"categories":["区块链"],"contents":"区块链 区块链是一种分布式账本技术，其主要特征是去中心化、不可篡改和透明。它将数据分成区块，这些区块通过密码学手段串联成链，每个区块存储一组数据并指向上一个区块，从而形成一个链条。以下是区块链的核心原理和矿工角色的解析：\n区块链的核心原理\n去中心化：区块链的账本存储在全网各节点上，没有中心服务器，任何节点都可以参与数据的记录与验证。这样，即便某个节点出现故障，系统仍可继续运作。 不可篡改：每个区块中包含前一个区块的哈希值，并记录了所有交易数据的哈希，通过哈希的链条结构，形成了对数据篡改的防护。若某人试图篡改某区块的数据，将导致后续区块的哈希值发生变化，从而被整个网络发现并拒绝。\n共识机制: 区块链通过共识算法确保每个节点对账本数据的一致性。常见的共识机制包括工作量证明 (PoW)、权益证明(PoS)、权力证明(DPoS) 等。\n分布式存储：区块链数据在多个节点上备份，每个节点都有一个完整的账本副本，确保了数据的可靠性和安全性\n质押 (Staking) 要如何区分官方质押和第三方质押？什么样的质押属于官方质押？什么样的质押属于第三方质押 PoW（Proof of Work，工作量证明）和 PoS（Proof of Stake，权益证明）是区块链中的两种共识机制，用于决定谁有权利验证和打包区块。它们在安全性、能源消耗、去中心化等方面存在显著差异：\n1. PoW（工作量证明） 机制：矿工通过计算复杂的数学问题来竞争记账权，首先解出问题的矿工获得新增区块的打包权并得到奖励。 能源消耗：计算问题的过程需要大量计算资源（如电力和计算力），导致高能耗。比特币就是基于 PoW 的典型例子。 安全性：安全性较高，因为攻击者需要掌握超过 50% 的算力来攻击网络，即“51% 攻击”，这需要巨大的计算资源，难度极大。 去中心化：由于矿机设备和电力成本，实际的算力往往集中在一些大型矿池中，去中心化程度可能会受到一定影响。 2. PoS（权益证明） 机制：验证者通过持有的代币数量和持币时间来竞争记账权。持币越多、时间越久的节点有更高的概率被选中打包区块并获得奖励。 能源消耗：PoS 不依赖大量的计算资源，因此能耗低，生态更加环保。以太坊从 PoW 转换到 PoS 的主要原因之一就是减少能耗。 安全性：同样存在“51% 攻击”的可能性，但攻击者需要拥有超过 50% 的代币。由于获取大量代币成本高昂，成功攻击的难度大。 去中心化：PoS 的设计可以减少资源集中的问题，因为持币量较小的节点也有机会成为验证者，去中心化程度相对较高。 区别总结 特性 PoW（工作量证明） PoS（权益证明） 竞争方式 计算力（算力）竞争 持币量和持币时间竞争 能源消耗 高，依赖计算资源 低，不依赖计算资源 51% 攻击难度 高，需控制绝大多数算力 高，需控制绝大多数代币 去中心化程度 随着矿池集中可能受影响 较高，允许更多节点参与 应用 比特币等早期区块链 以太坊 2.0、Cardano 等 从长期来看，PoS 更符合环保趋势，而 PoW 则因其高安全性依然在比特币等项目中广泛使用。\nPOW: 算力越高，贡献越大，挖矿得到的币就越多\nPOS: 持有的币越多， 能得到的奖励就越多\n(希望你固定持有这个代币，代币才稳定)\n","date":"2024-11-01T17:24:00+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE/","tags":["区块链"],"title":"区块链"},{"categories":["业界算法"],"contents":"Raft算法 共识算法就是保证一个集群的多台机器协同工作，在遇到请求时，数据能够保持一致。\n即使遇到机器宕机，整个系统仍然能够对外保持服务的可用性。\nRaft 将共识问题分解三个子问题：Leader election 领导选举：有且仅有一个 leader 节点，如果 leader 宕机，通过选举机制选出新的 leader；\nLog replication 日志复制：leader 从客户端接收数据更新/删除请求，然后日志复制到 follower 节点，从而保证集群数据的一致性；\nSafety 安全性：通过安全性原则来处理一些特殊 case，保证 Raft 算法的完备性；\n所以，Raft 算法核心流程可以归纳为：首先选出 leader，leader 节点负责接收外部的数据更新/删除请求；\n然后日志复制到其他 follower 节点，同时通过安全性的准则来保证整个日志复制的一致性；\n如果遇到 leader 故障，followers 会重新发起选举出新的 leader；\n领导者 Leader：接收处理客户端请求、向Follower进行日志同步、同一时刻最多只能有一个可行的 Leader 追随者 Follower：接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志，处在完全被动状态候选人 Candidate：临时角色，处于 Leader 和 Follower 之间的暂时状态 ","date":"2024-10-16T20:31:26+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%B8%9A%E7%95%8C%E7%AE%97%E6%B3%95/raft%E7%AE%97%E6%B3%95/","tags":["业界算法"],"title":"raft算法"},{"categories":["容器"],"contents":"给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n请你设计并实现时间复杂度为 O(n) 的算法解决此问题。\n示例 1：\n输入：nums = [100,4,200,1,3,2]\n输出：4\n解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int longestConsecutive(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if(nums.size() == 0) return 0; unordered_set\u0026lt;int\u0026gt; hash; for(auto i :nums) hash.insert(i); int mx = 1; for(auto k: hash) { if(hash.count(k-1)) { continue; } int cnt = 1; while(hash.count(k+1)) { cnt ++; k++; } if(cnt \u0026gt; mx) mx = cnt; } return max(1,mx); } }; ","date":"2024-10-16T17:57:48+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%AE%B9%E5%99%A8/lc.128.%E6%9C%80%E9%95%BF%E5%BA%8F%E5%88%97/","tags":["容器"],"title":"lc.128.最长序列"},{"categories":["动态规划"],"contents":"1. 买卖股票的最佳时机 III 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { //只能2次，且不能持仓下 继续加仓 int n = prices.size(); if(n==0) return 0; // 定义2个状态， hold or close // 清仓状态 close , 交易次数为 k // dp[k][i][0] = max(dp[k][i-1][0],dp[k][i-1][1] + prices[i]) // 持有状态 // dp[k][i][1] = max(dp[k][i-1][1],dp[k-1][i-1][0] + prices[i]) // empty -\u0026gt; dp[0][ ? ][0] //buy -\u0026gt; dp[1][?][1] //sell -\u0026gt; dp[1][?][0] //buy -\u0026gt; dp[2][?][1] //sell -\u0026gt; dp[2][?][0] vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; dp(3,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n+1,vector\u0026lt;int\u0026gt; (2,INT_MIN/2))); for(int i=0;i\u0026lt;n;i++) dp[0][i][0] = 0; dp[1][0][1] = -prices[0]; for(int i=1;i\u0026lt;n;i++) { for(int k=1;k\u0026lt;=2;k++) { dp[k][i][0] = max( dp[k][i-1][0], dp[k][i-1][1] + prices[i] ); dp[k][i][1] = max(dp[k][i-1][1],dp[k-1][i-1][0] - prices[i]); } } return max({0, dp[1][n-1][0] ,dp[2][n-1][0]}); } }; ","date":"2024-10-16T17:40:02+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/","tags":["动态规划"],"title":"买卖股票最佳时机"},{"categories":["枚举"],"contents":"给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的\n子集\n（幂集）。\n解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n输入：nums = [1,2,3]\n输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n=nums.size(); //各不相同 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; rets; vector\u0026lt;int\u0026gt; tmp; dfs(rets,tmp,nums,0,n); return rets; } void dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;rets,vector\u0026lt;int\u0026gt; \u0026amp;tmp,vector\u0026lt;int\u0026gt; \u0026amp;nums,int i,int n) { if(i\u0026gt;=n) { rets.push_back(tmp); return; } tmp.push_back(nums[i]); dfs(rets,tmp,nums,i+1,n); tmp.pop_back(); dfs(rets,tmp,nums,i+1,n); } }; ","date":"2024-10-16T09:56:45+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%9E%9A%E4%B8%BE/%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/","tags":["枚举"],"title":"枚举算法"},{"categories":["  双指针"],"contents":"给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n必须在不使用库内置的 sort 函数的情况下解决这个问题。\n输入：nums = [2,0,2,1,1,0]\n输出：[0,0,1,1,2,2]\n大于放右边，小于放左边，不大不小在中间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: void sortColors(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int l = 0, n = nums.size(),r=n-1; int i=0; while(i\u0026lt;=r) { if(nums[i] == 0) { swap(nums[i],nums[l++]); } if(nums[i]==2) { swap(nums[i],nums[r--]); }else { i++; } } } }; ","date":"2024-10-16T09:50:28+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98/-%E5%8F%8C%E6%8C%87%E9%92%88/lc.75%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/","tags":["  双指针"],"title":"lc.75颜色分类"},{"categories":["动态规划"],"contents":"给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。\n你可以对一个单词进行如下三种操作：\n插入一个字符\n删除一个字符\n替换一个字符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int minDistance(string s, string t) { // . eq // i N // d 0 int n = s.size(),m= t.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n+1,vector\u0026lt;int\u0026gt; (m+1,INT_MAX)); dp[0][0] = 0; for(int i=0;i\u0026lt;n+1;i++) dp[i][0] = i; //插入 for(int i=0;i\u0026lt;m+1;i++) dp[0][i] = i ;//del for(int i=1;i\u0026lt;=n;i++) { for(int j=1;j\u0026lt;=m;j++) { int del = dp[i-1][j] + 1; int add = dp[i][j-1] + 1; int rep = dp[i-1][j-1] ; if(s[i-1] != t[j-1]) rep++; dp[i][j] = min({del,add,rep}); } } return dp[n][m]; } }; ","date":"2024-10-16T01:05:42+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/","tags":["动态规划"],"title":"编辑距离"},{"categories":["二分"],"contents":"给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n请必须使用时间复杂度为 O(log n) 的算法。\n输入: nums = [1,3,5,6], target = 5\n输出: 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int searchInsert(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); if(n == 0) return 0; if(nums[0] \u0026gt; target) return 0; if(nums[n-1] \u0026lt; target) return n; int l=0,r=n-1; while(l\u0026lt;r) { int k = (l+r)/2; //compare nums[k] target-1 if(nums[k] \u0026lt; target) { l = k+1; }else { r=k; } } return l; } }; ","date":"2024-10-15T23:57:17+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/lc.35.%E6%95%B0%E7%BB%84%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0/","tags":["二分"],"title":"lc.35.数组插入位置"},{"categories":["动态规划"],"contents":"给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。\n注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: bool wordBreak(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { int n = s.size(); vector\u0026lt;bool\u0026gt; dp(n+1,0); dp[0] = 1; for(int i=1;i\u0026lt;=n;i++) { for(auto \u0026amp;p : wordDict) { if( i\u0026gt;=p.size() ) { if(dp[i-p.size()] \u0026amp;\u0026amp; s.substr(i - p.size(),p.size() ) == p) { dp[i] = dp[i] || dp[i-p.size()]; } } } } return dp[n]; } }; 140. 单词拆分 II 给定一个字符串 s 和一个字符串字典 wordDict ，在字符串 s 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。以任意顺序 返回所有这些可能的句子。\n注意：词典中的同一个单词可能在分段中被重复使用多次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public: vector\u0026lt;string\u0026gt; wordBreak(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { int n = s.size(); unordered_set\u0026lt;string\u0026gt; wordSet(wordDict.begin(), wordDict.end()); // 使用set加快查找速度 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1); // dp[i] 表示s[0:i]的有效拆分起点 dp[0] = {0}; // 空字符串可以被拆分 // 动态规划填表 for (int i = 0; i \u0026lt; n; i++) { if (dp[i].empty()) continue; // 如果当前起点不可达，跳过 for (int j = i + 1; j \u0026lt;= n; j++) { if (wordSet.find(s.substr(i, j - i)) != wordSet.end()) { dp[j].push_back(i); // 记录拆分起点i } } } vector\u0026lt;string\u0026gt; res; vector\u0026lt;string\u0026gt; path; if (!dp[n].empty()) { dfs(res, path, s, dp, n); // 从dp数组的末尾开始递归构造结果 } return res; } private: void dfs(vector\u0026lt;string\u0026gt; \u0026amp;res, vector\u0026lt;string\u0026gt; \u0026amp;path, string \u0026amp;s, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;dp, int idx) { if (idx == 0) { // 逆序拼接字符串 string result; for (int i = path.size() - 1; i \u0026gt;= 0; i--) { result += path[i]; if (i != 0) result += \u0026#34; \u0026#34;; } res.push_back(result); return; } // 遍历当前idx处的所有有效起点 for (int start : dp[idx]) { path.push_back(s.substr(start, idx - start)); // 记录当前子串 dfs(res, path, s, dp, start); // 递归到前一个起点 path.pop_back(); // 回溯，删除当前子串 } } }; ","date":"2024-10-09T16:01:25+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8D%95%E5%90%83%E6%8B%86%E5%88%86/","tags":["动态规划"],"title":"单吃拆分"},{"categories":["数学"],"contents":" 字符串相乘 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。\n注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public: string multiply(string num1, string num2) { // 如果有一个数是0，结果必然为0 if (num1 == \u0026#34;0\u0026#34; || num2 == \u0026#34;0\u0026#34;) return \u0026#34;0\u0026#34;; // 反转两个字符串，方便从低位到高位进行计算 reverse(num1.begin(), num1.end()); reverse(num2.begin(), num2.end()); int n = num1.size(); int m = num2.size(); // 存放乘积的结果，长度最多为n+m vector\u0026lt;int\u0026gt; res(n + m, 0); // 逐位相乘并累加到结果数组 for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { res[i + j] += (num1[i] - \u0026#39;0\u0026#39;) * (num2[j] - \u0026#39;0\u0026#39;); } } // 处理进位 for (int i = 0; i \u0026lt; n + m - 1; i++) { res[i + 1] += res[i] / 10; // 将进位累加到下一位 res[i] %= 10; // 当前位只保留个位数 } // 去除前导零，并构建最终结果 int k = n + m - 1; while (k \u0026gt; 0 \u0026amp;\u0026amp; res[k] == 0) k--; // 去除最高位的0 string result; for (int i = k; i \u0026gt;= 0; i--) { result.push_back(res[i] + \u0026#39;0\u0026#39;); // 将数字转换为字符 } return result; } }; ","date":"2024-10-09T15:37:19+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%95%B0%E5%AD%A6/%E5%A4%A7%E6%95%B0%E4%B9%98%E6%B3%95/","tags":["数学"],"title":"大数乘法"},{"categories":["  双指针"],"contents":"给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n返回容器可以储存的最大水量。\n说明：你不能倾斜容器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { //x ,y int n = height.size(); int i=0,j = n-1; int travel = 0; while(i\u0026lt;=j) { int x = j - i ; int miny = min(height[i],height[j]); travel = max(travel,miny * x); if (height[i] \u0026gt;= height[j]) { j--; }else { i++; } } return travel; } }; 15. 三数之和 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { sort(nums.begin(),nums.end()); int n= nums.size(); if (n\u0026lt;3) return {}; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; for(int i=0;i\u0026lt;n;i++) { while(i \u0026amp;\u0026amp; i\u0026lt; n \u0026amp;\u0026amp; nums[i] == nums[i-1]) i++; int j=i+1,k=n-1; while (i\u0026lt;j \u0026amp;\u0026amp; j \u0026lt; k ) { // x,y,z = 0 // x+z = -x int target = - nums[i]; // \u0026gt; ,\u0026lt; = int x = nums[k] + nums[j]; if(x == target) { res.push_back({nums[i],nums[j],nums[k]}); j++; k--; while(j\u0026lt;k \u0026amp;\u0026amp; nums[j-1] == nums[j]) j++; while(j\u0026lt;k \u0026amp;\u0026amp; nums[k+1] == nums[k]) k--; }else if (x\u0026gt; target) { k--; }else { j++; } } } return res; } }; 18. 四数之和 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fourSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); sort(nums.begin(),nums.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if(n\u0026lt;4) return res; for(int i=0;i\u0026lt;n;i++) { while(i\u0026gt; 0 \u0026amp;\u0026amp; i \u0026lt; n \u0026amp;\u0026amp; nums[i] == nums[i-1]) i++; for(int j=i+1;j\u0026lt;n;j++) { while(j\u0026gt;i+1 \u0026amp;\u0026amp; j \u0026lt;n \u0026amp;\u0026amp; nums[j] == nums[j-1]) j++; int k = j+1,l = n-1; while(i\u0026lt;j \u0026amp;\u0026amp; j \u0026lt; k \u0026amp;\u0026amp; k \u0026lt; l) { long long x = 1ll*target - 1ll*(nums[i] + nums[j]); long long tmp = ( nums[k] *1ll + nums[l]) ; // compare x if (x == tmp) { res.push_back({ nums[i],nums[j],nums[k],nums[l]}); k++; l--; while(k \u0026lt;l \u0026amp;\u0026amp; nums[k] == nums[k-1]) ++k; while(k\u0026lt;l \u0026amp;\u0026amp; nums[l] == nums[l+1]) --l; }else if (x \u0026gt; tmp ) { //too small k++; }else { l--; } } } } return res; } }; ","date":"2024-10-09T13:21:49+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98/-%E5%8F%8C%E6%8C%87%E9%92%88/%E5%8F%8C%E6%8C%87%E9%92%88/","tags":["  双指针"],"title":"双指针"},{"categories":["动态规划"],"contents":" 最长回文子串 给你一个字符串 s，找到 s 中最长的回文\n。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public: string longestPalindrome(string s) { int n = s.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n+1,vector\u0026lt;int\u0026gt;(n+1)); dp[0][0] = 1; for(int i=0;i\u0026lt;n;i++) dp[i][i] =1; for(int i=n-1;i\u0026gt;=0;i--) { for(int j=i+1;j\u0026lt;n;j++) { if(s[i] != s[j]) { dp[i][j] = false; continue; } // j\u0026gt;i if(j-i == 2) { //aba dp[i][j] = s[i] == s[j]; continue; } if(j-i==1) { //ab dp[i][j] = s[i]==s[j]; continue; } dp[i][j] = dp[i+1][j-1]; } } int l=0,r=0,mx=-1; // 最长 for(int i=0;i\u0026lt;n;i++) { for(int j=i;j\u0026lt;n;j++) { if(dp[i][j] \u0026amp;\u0026amp; j-i + 1 \u0026gt; mx) { l=i,r=j; mx = r-l+1; } } } return s.substr(l,r-l+1); } }; 正则表达式匹配\n已解答\n困难\n相关标签\n相关企业\n给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 \u0026lsquo;.\u0026rsquo; 和 \u0026lsquo;*\u0026rsquo; 的正则表达式匹配。 \u0026lsquo;.\u0026rsquo; 匹配任意单个字符\n\u0026lsquo;*\u0026rsquo; 匹配零个或多个前面的那一个元素\n所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public: bool isMatch(string s, string p) { int n = s.size(); int m = p.size(); // 这里要修正为 p 的大小 vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;bool\u0026gt;(m + 1, false)); // 使用 bool 类型 dp[0][0] = true; // 空字符串与空模式匹配 // 处理 p 中的模式可以匹配空字符串的情况 for (int j = 1; j \u0026lt;= m; j++) { if (p[j - 1] == \u0026#39;*\u0026#39;) { if(j\u0026gt;=2) dp[0][j] = dp[0][j - 2]; // 例如 a*、.* 等 } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (p[j-1] == s[i-1] || p[j-1] == \u0026#39;.\u0026#39;) { dp[i][j] = dp[i-1][j-1]; }else if(p[j-1] == \u0026#39;*\u0026#39;) { //match previous char if(p[j-2] == \u0026#39;.\u0026#39; || s[i-1] == p[j-2]) { //匹配 0个， 匹配1~N dp[i][j] = dp[i][j-2] || dp[i-1][j] ; }else { // p 前一个不能 和 当前的s 比较, 匹配0 个字符 dp[i][j] = dp[i][j-2]; } } } } return dp[n][m]; } // private: // bool state_match(string \u0026amp;s, string \u0026amp;p, int i, int j) { // if (i \u0026lt; 0) return false; // s 为空 // if (p[j] == \u0026#39;.\u0026#39;) return true; // . 可以匹配任何字符 // return s[i] == p[j]; // 匹配具体字符 // } }; ","date":"2024-10-09T00:29:49+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","tags":["动态规划"],"title":"最长子串"},{"categories":["数学"],"contents":"给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n回文数\n是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n例如，121 是回文，而 123 不是。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: bool isPalindrome(int x) { if(x\u0026lt; 0 ) return false; int bak = x; int j=0; int b = (INT_MAX - INT_MAX % 10) / 10; while(x) { //X MUST \u0026gt;0 if (j \u0026gt; INT_MAX/10) return false; if (j == b \u0026amp;\u0026amp; x % 10 \u0026gt; INT_MIN % 10 ) return false; j = j*10 + x%10; x/=10; } return bak == j; } }; 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数。\n函数 myAtoi(string s) 的算法如下：\n空格：读入字符串并丢弃无用的前导空格（\u0026quot; \u0026ldquo;）\n符号：检查下一个字符（假设还未到字符末尾）为 \u0026lsquo;-\u0026rsquo; 还是 \u0026lsquo;+\u0026rsquo;。如果两者都不存在，则假定结果为正。\n转换：通过跳过前置零来读取该整数，直到遇到非数字字符或到达字符串的结尾。如果没有读取数字，则结果为0。\n舍入：如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被舍入为 −231 ，大于 231 − 1 的整数应该被舍入为 231 − 1 。\n返回整数作为最终结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class Solution { public: int myAtoi(string s) { int k = 0; int n = s.size(); bool flag = false; int state = 0; // 跳过前导空格 int start = 0; while (start \u0026lt; n \u0026amp;\u0026amp; s[start] == \u0026#39; \u0026#39;) start++; for (int i = start; i \u0026lt; n; i++) { if (state \u0026gt; 0 \u0026amp;\u0026amp; !(s[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;9\u0026#39;)) { return k; } if (s[i] == \u0026#39; \u0026#39;) { return k; } if (s[i] == \u0026#39;+\u0026#39;) { if (state != 0) return k; // 遇到非首字符的符号 state = 1; continue; } if (s[i] == \u0026#39;-\u0026#39;) { if (state != 0) return k; // 遇到非首字符的符号 flag = true; state = 1; continue; } if (s[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;9\u0026#39;) { state = 1; int ne = s[i] - \u0026#39;0\u0026#39;; if (flag) ne *= -1; // 检查溢出条件 if (k \u0026gt; INT_MAX / 10 || (k == INT_MAX / 10 \u0026amp;\u0026amp; ne \u0026gt; INT_MAX % 10 )) { // ne \u0026gt; 8 return INT_MAX; } if (k \u0026lt; INT_MIN / 10 || (k == INT_MIN / 10 \u0026amp;\u0026amp; ne \u0026lt; INT_MIN % 10)) { // ne \u0026lt; -7 return INT_MIN; } k = k * 10 + ne; } else { break; // 遇到非数字字符直接退出 } } return k; } }; 整数反转\n给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\n如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。\n假设环境不允许存储 64 位整数（有符号或无符号）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int reverse(int x) { int j = 0; while (x != 0) { int digit = x % 10; // 检查是否会溢出 if (j \u0026gt; INT_MAX / 10 || (j == INT_MAX / 10 \u0026amp;\u0026amp; digit \u0026gt; INT_MAX %10 )) { return 0; // 正溢出 } if (j \u0026lt; INT_MIN / 10 || (j == INT_MIN / 10 \u0026amp;\u0026amp; digit \u0026lt; INT_MIN %10)) { return 0; // 负溢出 } j = j * 10 + digit; x /= 10; } return j; } }; ","date":"2024-10-08T16:07:58+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6/","tags":["数学"],"title":"数学"},{"categories":["区间dp"],"contents":"参考例题 给定一个由 \u0026lsquo;[\u0026rsquo; ，\u0026rsquo;]\u0026rsquo;，\u0026rsquo;(\u0026rsquo;，‘)’ 组成的字符串，请问最少插入多少个括号就能使这个字符串的所有括号左右配对。\n例如当前串是 \u0026ldquo;([[])\u0026quot;，那么插入一个\u0026rsquo;]\u0026lsquo;即可满足。\n输入描述：\n仅一行，输入一个字符串，字符串仅由 \u0026lsquo;[\u0026rsquo; ，\u0026rsquo;]\u0026rsquo; ，\u0026rsquo;(\u0026rsquo; ，‘)’ 组成\n输出描述：\n输出最少插入多少个括号\n括号区间匹配 [[..\\序列边界\\leetcode.410.分割数组的最大值.md]]\n两个关键代码\n1 2 3 4 5 for len in 2..n: for i \u0026lt; n-len+1 j = i+len-1 calc dp[i][j] dp[i][j] from dp[i][k] ~ dp[k+1][j] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool ismatch(char a, char b) { if ((a == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; b == \u0026#39;)\u0026#39;) || (a == \u0026#39;[\u0026#39; \u0026amp;\u0026amp; b == \u0026#39;]\u0026#39;)) { return true; } return false; } int main() { string s; cin\u0026gt;\u0026gt;s; int n = s.size(); vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; dp(n+1,vector\u0026lt;int\u0026gt;(n+1) ); #define inf (1ll\u0026lt;\u0026lt;31)-1 for(int i=0;i\u0026lt;n;i++) dp[i][i] =1; for(int l=2;l\u0026lt;=n;l++) { for(int i=0;i \u0026lt; n-l+1; i++) { //例如 len=2,{0,1} , i 只能到 n-len+1 int j = i+l-1; if(j\u0026lt;=i) continue; //region {i~j} dp[i][j] = inf; if(ismatch(s[i],s[j])) { dp[i][j] = dp[i+1][j-1]; // {ax..yb} =\u0026gt; {x..y} } for(int k=i;k\u0026lt;j;k++) { dp[i][j] = min(dp[i][j],dp[i][k]+dp[k+1][j]); } } } cout \u0026lt;\u0026lt; dp[0][n-1]; return 0; } 最长回文子序列 给定一个字符串，找到其中最长的回文子序列，并返回该序列的长度。\n注：回文序列是指这个序列无论从左读还是从右读都是一样的。\n本题中子序列字符串任意位置删除k（len(s)\u0026gt;=k\u0026gt;=0）个字符后留下的子串。\n例如\nabccsb\n4\n说明：\n分别选取第2、3、4、6位上的字符组成“bccb”子序列是最优解\n类似于最长公共子序列\n[[../动态规划基础.md]]\n$$\nd(i,i)=1 \\\nd(i+1,i)=0\n$$\n递归入口 dfs(0,n-1)\n$$\nd(i,j)=\n\\begin{cases}\nd[i+1][j-1]+2 \u0026amp; \\text{if } \\ a[i]==a[j]\\\nmax(d[i+1][j],d[i][j-1]) \u0026amp; \\text{if } \\ a[i]\u0026lt;\u0026gt;a[j]\\\n\\end{cases}\n$$\n由于要从 d[i+1][j] 转移状态到 d[i][j]\n所以 i倒序枚举， j-1 转移到 j, j要正序枚举\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { string s; cin\u0026gt;\u0026gt;s; int n = s.size(); vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; dp(n+1,vector\u0026lt;int\u0026gt; (n+1)); // dp[i][j] = dp[i+1][j-1]+2 // dp[i][j] = dp[i+1][j],dp[i][j-1] for(int i=n-1;i\u0026gt;=0;i--) { dp[i][i] =1; for(int j=i+1;j\u0026lt;n;j++) { if(s[i] == s[j]) { dp[i][j] = dp[i+1][j-1]+2; }else { dp[i][j] = max(dp[i+1][j],dp[i][j-1]); } } } cout \u0026lt;\u0026lt; dp[0][n-1]\u0026lt;\u0026lt;endl; return 0; } 能量项链 在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为 r，尾标记为 n，则聚合后释放的能量为 m*r*n\n例如：设N=4，4颗珠子的头标记与尾标记依次为(2，3) (3，5) (5，10) (10，2)。我们用记号⊕表示两颗珠子的聚合操作，(j⊕k)表示第j，k两颗珠子聚合后所释放的能量。则第4、1两颗珠子聚合后释放的能量为：(4⊕1)=1023=60。\nm×r×n （Mars单位），新产生的珠子的头标记为 m，尾标记为 n。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 1e9+7; int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n*2) ; for(int i=0;i\u0026lt;n;i++) { cin\u0026gt;\u0026gt;a[i]; a[n+i] = a[i]; } vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; dp(n*2+1,vector\u0026lt;int\u0026gt; (n*2+1) ); // dp[i][j] = dp[i][k]* a[k] * dp[k+1][j] for(int l=1;l\u0026lt;n;l++) { for(int i=0;i\u0026lt;2*n-l;i++) { int j = i+l; for(int k=i;k\u0026lt;j;k++) { dp[i][j] = max(dp[i][j], (dp[i][k] + dp[k+1][j] + (a[i]*a[k+1]*a[j+1] )) % mod); } } } int ret=0; for(int i=0;i\u0026lt;n;i++) ret = max(ret,dp[i][i+n-1]); cout \u0026lt;\u0026lt; ret; return 0; } ","date":"2024-03-11T23:09:29Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E5%8C%BA%E9%97%B4dp/%E5%8C%BA%E9%97%B4dp%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/","tags":["区间dp"],"title":"区间dp问题详解"},{"categories":["背包汇总"],"contents":"数列问题汇总 等差数列 $$\na_{n+1} - a_{n} = d \\\nS_{n} = n(a_1+a_n) / 2\n$$\n等比数列 $$\na_{n+1}/a_{n} = d \\\nS_n = a_1 \\times \\sum_{i=1}^{n} q^i\n$$\n斐波那契数列 $f(n) = f(n-1)+f(n-2)$\n一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶(n为正整数)总共有多少种跳法。\nf(n)=f(n-1)+f(n-2)+……+f(2)+f(1);\nf(n-1) = f(n-2)+……+f(2)+f(1);\nf(n)/f(n-1) = 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { //f(n) = 2*f(n-1) // f(n) = 2^(n-1) int n; cin\u0026gt;\u0026gt;n; cout \u0026lt;\u0026lt; pow(2,n-1); return 0; } 其他递推数列 最小花费爬楼梯\n给定一个整数数组 cost ，其中 cost[i] 是从楼梯第i 个台阶向上爬需要支付的费用，下标从0开始。一旦你支付此费用，即可选择向上爬一个或者两个台阶\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); vector\u0026lt;int\u0026gt; a(n+1); for(int i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;a[i]; vector\u0026lt;int\u0026gt;dp(n+1) ; if(n\u0026lt;=2) { puts(\u0026#34;error\u0026#34;); return 0; } for(int i=3;i\u0026lt;=n+1;i++) { dp[i] = min(dp[i-1]+a[i-1],dp[i-2]+a[i-2]) ; } cout \u0026lt;\u0026lt; dp[n+1]; return 0; } 数列求和问题 DP9 环形数组的连续子数组最大和 给定一个长度为\nn 的环形整数数组，请你求出该数组的 非空 连续子数组 的最大可能和 。\n环形数组 意味着数组的末端将会与开头相连呈环状。例如，对于数组\n例如\n3\n5 -3 5\n输出 10= sum([5,5])\n参考文章 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n) ; for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i]; // vector\u0026lt;int\u0026gt; dp(2*n+1) ; // dp[]k int dpmin,dpmax; dpmax= dpmin=a[0]; int mx=a[0]; int mn = 0; int sum=mx; for(int i=1;i\u0026lt;(n);i++) { int j = a[i]; sum+=j; dpmax = max(dpmax,dpmax+j); if(mx\u0026lt;dpmax) mx = dpmax; } for(int i=1;i\u0026lt;n-1;i++) { int j = a[i]; dpmin = min(dpmin,0)+j; if(mn \u0026gt; dpmin) mn = dpmin; } cout \u0026lt;\u0026lt;max(mx,sum-mn) \u0026lt;\u0026lt;endl; return 0; } ","date":"2024-03-09T23:14:08Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E8%83%8C%E5%8C%85%E6%B1%87%E6%80%BB/%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C%E7%AD%89%E9%97%AE%E9%A2%98/","tags":["背包汇总"],"title":"数列问题"},{"categories":["循环队列"],"contents":"请你实现一个循环队列，该循环队列可利用的空间大小等于\nn个int型变量的大小。\n操作：\npush x：将\nx加入到循环队列尾端。若循环队列已满，输出\u0026quot;full\u0026quot;(不含引号)，否则不输出任何内容。保证\nx为int型整数。\nfront：输出队首元素，队首不出队。若队列为空，输出\u0026quot;empty\u0026quot;(不含引号)。\npop：输出队首元素，且队首出队。若队列为空，输出\u0026quot;empty\u0026quot;(不含引号)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e5 + 3; // int q[N]; vector\u0026lt;int\u0026gt; q ; int sz; int u; int t = 0; int l = 0, r = 0; void push(int x) { if (l == (r + 1) % sz) { puts(\u0026#34;full\u0026#34;); return; } q[r ] = x; r = (r + 1) % sz; } void pop() { if (l == r) { puts(\u0026#34;empty\u0026#34;); return; } cout \u0026lt;\u0026lt; q[l++] \u0026lt;\u0026lt; endl; l %= sz; } void front() { if (l == r) { puts(\u0026#34;empty\u0026#34;); return; } cout \u0026lt;\u0026lt; q[l] \u0026lt;\u0026lt; endl; } int main() { cin \u0026gt;\u0026gt; sz \u0026gt;\u0026gt; u; sz++; q.resize(sz); while (u--) { string a; cin \u0026gt;\u0026gt; a; if (a == \u0026#34;push\u0026#34;) { cin \u0026gt;\u0026gt; t; push(t); } else if (a == \u0026#34;pop\u0026#34;) { pop(); } else { // front front(); } } return 0; } ","date":"2024-03-03T16:54:49Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/","tags":["循环队列"],"title":"循环队列详解"},{"categories":["几何"],"contents":"点到线或面的距离公式 已知直线的方程为 ax + by + c = 0, 则平面上任意一点(x,y)\n到该直线的距离 d 的公式为\n$$\nd = \\dfrac{|ax_0+by_0+c|}{\\sqrt{a^2+b^2}}\n$$\n$$\n\\vec{n} = \\dfrac{\\vec{n} * \\vec{m}}{\\vec{m}}\n$$\n$$\n\\vec{m} = (a,b) \\\n\\vec{n} = (x-x_0,y-y_0) \\\n$$\n$$\n\\vec{n} = \\dfrac{\\vec{n} * \\vec{m}}{\\vec{m}}\n= \\dfrac{|a(x-x_0)+b(y-y_0)|}{\\sqrt{a^2+b^2}}\n$$\n其中 (x,y) 在 l上，因此有 ax+by = -c, 代入上式\n即有\n$$\nd = \\dfrac{|ax_0+by_0+c|}{\\sqrt{a^2+b^2}}\n$$\nhttps://www.nowcoder.com/practice/6600857a0cc74a15b3418d5c617ab427?tpId=347\u0026tqId=10091327\u0026ru=/exam/oj\u0026qru=/ta/vip-algorithm/question-ranking\u0026sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D347 ","date":"2024-03-03T16:21:43Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/%E5%87%A0%E4%BD%95/%E7%BA%BF/","tags":["几何"],"title":"线"},{"categories":["单调栈"],"contents":"在直线上从左到右有\nn个山丘，第\ni个山丘的高度为ℎ\n​\n现在有一只小鸟想要从某个山丘顶部水平起飞，并且飞行的时候必须水平向左或向右飞行。\n这只小鸟如果在飞行过程中遇到一个比起始点还要高的山丘，则它就无法越过。它现在身上有一个炸弹，并且可以在飞行的过程中任意一个位置掷下（当前所在山丘和它的飞行高度相等时也能掷下）。如果一个山丘无法被炸弹炸到，则我们称它为安全的。\n现在对于每一个山丘，你要统计出有多少个出发点对它来说是安全的（即小鸟从那个出发点起飞无法向该山丘掷下炸弹）。\nhttps://www.nowcoder.com/practice/597c32f0b3cf43beb1d01e7ddd87cc32?tpId=347\u0026tqId=10068892\u0026ru=/exam/oj\u0026qru=/ta/vip-algorithm/question-ranking\u0026sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D308 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n); vector\u0026lt;int\u0026gt; l(n), r(n) ; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; stack\u0026lt;int\u0026gt; s; for (int i = 0; i \u0026lt; n; i++) { if (s.size()) { while (s.size() \u0026amp;\u0026amp; a[s.top()] \u0026lt; a[i]) { s.pop(); } l[i] = s.size(); } s.push(i); } while (s.size()) s.pop(); for (int i = n - 1; i \u0026gt;= 0; i--) { while (s.size() \u0026amp;\u0026amp; a[i] \u0026gt; a[s.top()]) { s.pop(); } r[i] = s.size(); s.push(i); } for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%d \u0026#34;, n - (l[i] + r[i]) - 1); } return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; moutains(n); vector\u0026lt;int\u0026gt; ans(n, 0); for(int i = 0; i \u0026lt; n; i++){ cin \u0026gt;\u0026gt; moutains[i]; } stack\u0026lt;int\u0026gt; left; left.push(0); int leftnum = 0; for(int i = 1; i \u0026lt; n; i++){ while(!left.empty() \u0026amp;\u0026amp; moutains[i] \u0026gt; moutains[left.top()]){ leftnum++; left.pop(); } ans[i] = ans[i] + leftnum; left.push(i); } stack\u0026lt;int\u0026gt; right; right.push(n - 1); int rightnum = 0; for(int i = n - 2; i \u0026gt;= 0; i--){ while(!right.empty() \u0026amp;\u0026amp; moutains[i] \u0026gt; moutains[right.top()]){ rightnum++; right.pop(); } ans[i] = ans[i] + rightnum; right.push(i); } for(int i= 0; i \u0026lt; n; i++){ cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } // 64 位输出请用 printf(\u0026#34;%lld\u0026#34;) ","date":"2024-03-03T14:26:25Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/%E8%AE%A1%E6%95%B0/%E6%84%A4%E6%80%92%E7%9A%84%E5%B0%8F%E9%B8%9F/","tags":["单调栈"],"title":"愤怒的小鸟"},{"categories":["堆"],"contents":"优先队列 [[....\\图论\\最短路径问题\\迪杰斯特拉详解.md]]\n请你实现一个堆(大根堆)。\n操作：\npush x：将\nx加入堆。保证\nx为int型整数。不输出任何内容。\ntop：输出堆顶元素。若堆为空，输出\u0026quot;empty\u0026quot;(不含引号)。\npop：输出堆顶元素，且弹出堆顶。若堆为空，输出\u0026quot;empty\u0026quot;(不含引号)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n;cin\u0026gt;\u0026gt;n; priority_queue\u0026lt;int,vector\u0026lt;int\u0026gt;,less\u0026lt;int\u0026gt;\u0026gt; q; while(n--) { string op; cin\u0026gt;\u0026gt;op; if (op == \u0026#34;push\u0026#34;) { int x;cin\u0026gt;\u0026gt;x; q.push(x); }else if(op == \u0026#34;top\u0026#34;) { if(q.size()) printf(\u0026#34;%d\\n\u0026#34;,q.top()); else puts(\u0026#34;empty\u0026#34;); }else { if(q.size()) { printf(\u0026#34;%d\\n\u0026#34;,q.top()); q.pop(); }else puts(\u0026#34;empty\u0026#34;); } } return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=100010; int h[N],len; void down(int u) { int t=u; if(u*2\u0026lt;=len\u0026amp;\u0026amp;h[u*2]\u0026gt;h[t]) t=u*2; if(u*2+1\u0026lt;=len\u0026amp;\u0026amp;h[u*2+1]\u0026gt;h[t]) t=u*2+1; if (u!=t) { swap(h[u],h[t]); down(t); } } void up(int u) { while(u/2\u0026amp;\u0026amp;h[u/2]\u0026lt;h[u]) { swap(h[u/2],h[u]); u/=2; } } int main() { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); len=0; for(int i=n/2;i;i--) down(i); while(n--) { char op[5]; int x; scanf(\u0026#34;%s\u0026#34;,op); if(op[0]==\u0026#39;p\u0026#39;\u0026amp;\u0026amp;op[1]==\u0026#39;u\u0026#39;) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); h[++len]=x; up(len); } else if(op[0]==\u0026#39;p\u0026#39;\u0026amp;\u0026amp;op[1]==\u0026#39;o\u0026#39;) { if(len) { printf(\u0026#34;%d\\n\u0026#34;,h[1]); h[1]=h[len]; len--; down(1); } else puts(\u0026#34;empty\u0026#34;); } else { if(len) printf(\u0026#34;%d\\n\u0026#34;,h[1]); else puts(\u0026#34;empty\u0026#34;); } } } ","date":"2024-03-02T23:41:54Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86%E5%BA%93%E8%AF%A6%E8%A7%A3/","tags":["堆"],"title":"优先队列\u0026堆库详解"},{"categories":["最短路径问题"],"contents":"相关知识 [[....\\数据结构\\堆\\23.合并前k个升序链表.md]]\n单源最短路径算法 给你一个无向图，图中包含 5000 个点 m 个边，任意两个点之间的距离是 w ，无重边或自环。请求出1号点到n号点的最短距离。\n注意：图中可能存在孤立点，即存在点与任意点都没有边相连\n如果1号点不能到达n号点，输出-1.\n参考题目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; template \u0026lt;class T, class S, class C\u0026gt; S\u0026amp; Container(priority_queue\u0026lt;T, S, C\u0026gt;\u0026amp; q) { struct HackedQueue : private priority_queue\u0026lt;T, S, C\u0026gt; { static S\u0026amp; Container(priority_queue\u0026lt;T, S, C\u0026gt;\u0026amp; q) { return q.*\u0026amp;HackedQueue::c; } }; return HackedQueue::Container(q); } struct edge { int v; int w; edge(int v=0,int w=0): v(v),w(w){} bool operator \u0026lt;(const edge\u0026amp;r) const { return w \u0026gt; r.w; } }; void printq(priority_queue\u0026lt;edge\u0026gt; \u0026amp;q) { auto v = Container(q); for(edge w: v) { printf(\u0026#34;%d \u0026#34;,w.v); } printf(\u0026#34;\\n\u0026#34;); } int main() { int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; unordered_map\u0026lt;int,vector\u0026lt;edge\u0026gt; \u0026gt; g; while(m--) { int u,v,w; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v\u0026gt;\u0026gt;w; g[u].push_back({v,w}); g[v].push_back({u,w}); } #define inf INT32_MAX priority_queue\u0026lt;edge\u0026gt; q; vector\u0026lt;int\u0026gt;distTo(5001,inf) ; distTo[1] = 0; q.push(edge{1,0}); while(q.size() ) { auto s = q.top();q.pop(); if(distTo[s.v] \u0026lt; s.w) { continue; } vector\u0026lt;edge\u0026gt; all = g[s.v] ; //获取所有可达点 for(auto edg: all) { int w = edg.w,to = edg.v; // if(vis.count(to)) continue; if(distTo[to] \u0026gt; distTo[s.v] + w) { //经常错 s === (cost=w) ===\u0026gt; v distTo[to] = distTo[s.v] + w; // printf(\u0026#34;u,v : %d %d\\n\u0026#34;,s.v,s.w); q.push(edge{to,distTo[to]}); // printf(\u0026#34;(%d-\u0026gt; %d) w:%d distTo[%d]: %d\\n\u0026#34;,s.v,edg.v,edg.w,edg.v,distTo[edg.v]); // printq(q); } } } if(distTo[n] != inf) { cout \u0026lt;\u0026lt;distTo[n] \u0026lt;\u0026lt;endl; }else { puts(\u0026#34;-1\u0026#34;); } return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define edge pair\u0026lt;int,int\u0026gt; int main() { int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; unordered_map\u0026lt;int,vector\u0026lt;edge\u0026gt; \u0026gt; g; while(m--) { int u,v,w; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v\u0026gt;\u0026gt;w; g[u].push_back({w,v}); g[v].push_back({w,u}); } #define inf INT32_MAX priority_queue\u0026lt;edge,vector\u0026lt;edge\u0026gt;,greater\u0026lt;edge\u0026gt; \u0026gt; q; vector\u0026lt;int\u0026gt;distTo(5001,inf) ; distTo[1] = 0; q.push(make_pair(0,1)); while(q.size() ) { auto s = q.top();q.pop(); int from = s.second; vector\u0026lt;edge\u0026gt; all = g[from] ; if(distTo[from] \u0026lt; s.first) continue; //获取所有可达点 for(auto edg: all) { int to = edg.second, weight = edg.first; // if(vis.count(to)) continue; if(distTo[to] \u0026gt; distTo[from] + weight) { //经常错 s === (cost=w) ===\u0026gt; v distTo[to] = distTo[from] + weight; q.push(edge{distTo[to],to}); } } } if(distTo[n] != inf) { cout \u0026lt;\u0026lt;distTo[n] \u0026lt;\u0026lt;endl; }else { puts(\u0026#34;-1\u0026#34;); } return 0; } ","date":"2024-03-02T23:39:34Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E8%AF%A6%E8%A7%A3/","tags":["最短路径问题"],"title":"迪杰斯特拉详解"},{"categories":["并查集"],"contents":" https://www.nowcoder.com/discuss/592142671393591296 给定一个 n 个节点的邻接矩阵 m。 节点定义为城市，如果 a 城市与 b 城市相连， b 与 c 城市相连，尽管 a 与 c 并不直接相连，但可以认为 a 与 c 相连，定义 a,b,c 是一个城市群。\n矩阵 m[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，否则表示不相连。\n请你找出共有多少个城市群。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param m int整型vector\u0026lt;vector\u0026lt;\u0026gt;\u0026gt; * @return int整型 */ int citys(vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;\u0026amp; m) { // write code here int n = m.size(); initf(n); sz.assign(n,1); int cnt = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { int a = m[i][j]; int x = find(i), y = find(j); if ( a \u0026amp;\u0026amp; x != y \u0026amp;\u0026amp; i != j) { p[x] = y; sz[y] += sz[x]; } } } int ccnt = 0; for(int i=0;i\u0026lt;n;i++) { int j = find(i); if(sz[j]\u0026gt;0) { ccnt+=1; sz[j] = -sz[j]; } } return ccnt; } vector\u0026lt;int\u0026gt; p; vector\u0026lt;int\u0026gt; sz; int find(int x) { int y = p[x]; if (y != x) return p[x] = find(p[x]); return y; } void initf(int x) { p.assign(x , 0); for (int i = 0; i \u0026lt; x; i++) p[i] = i; } }; 相关问题 https://www.nowcoder.com/practice/35175cee9e634b92b35b634244d81feb?tpId=347\u0026tqId=10068437\u0026ru=%2Fpractice%2F5dc1ccabaa0442d8b83f00ec74b225fa\u0026qru=%2Fta%2Fvip-algorithm%2Fquestion-ranking\u0026sourceUrl=%2Fexam%2Foj 考察连通性问题+ 二分法\n二维平面上有\nn个基站，第\ni个基站的坐标为 x,y, 所有的基站都共同的信号强度w\n现在我想知道，信号强度\nw至少是多大，才能使得至少有\nk个基站可以互相通信。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; // https://www.nowcoder.com/practice/35175cee9e634b92b35b634244d81feb?tpId=347\u0026amp;tqId=10068437\u0026amp;ru=/practice/5dc1ccabaa0442d8b83f00ec74b225fa\u0026amp;qru=/ta/vip-algorithm/question-ranking\u0026amp;sourceUrl=/exam/oj vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; nodes; vector\u0026lt;int\u0026gt; g; int find(int x,vector\u0026lt;int\u0026gt;\u0026amp;g ) { if (g[x]!=x) { g[x] = find(g[x],g); } return g[x]; } int dis(int a,int b,int c,int d) { return (a-c) * (a-c) + (b-d)*(b-d) ; } vector\u0026lt;int \u0026gt;sz; bool checkk(int k, int w,int n,vector\u0026lt;int\u0026gt; \u0026amp;g ) { for(int i=0;i\u0026lt;n;i++) g[i] = i; for(int i=0;i\u0026lt;n;i++) sz[i] = 1; int merge=0; for(int i=0;i\u0026lt;n;i++) { for(int j=0;j\u0026lt;i;j++) { if(i!=j) { if(dis(nodes[i].first,nodes[i].second,nodes[j].first,nodes[j].second) \u0026gt; w ) { // return false; continue; }else { int x = find(i,g); int y = find(j,g); if(x!=y) { g[x] = y; sz[y] += sz[x]; merge++; // if (merge \u0026gt;= k) return true; } } } } } for(int i=0;i\u0026lt;n;i++) { if(sz[i]\u0026gt;=k) return true; } return false; } int main() { int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; g.assign(n+1,0); sz.assign(n+1,0); for(int i=0;i\u0026lt;n;i++) { int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; nodes.push_back({x,y}); } int r = 9000,l=0; while(l\u0026lt;r) { int w = (l+r)/2; // printf(\u0026#34;w:%d\\n\u0026#34;,w); if(checkk(k,w,n,g)) { r = w; }else { l = w+1; } } cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; return 0; } 最小生成树算法 一个有 n 户人家的村庄，有 m 条路相互连接着。村里现在要修路，每条路都有一个成本价格，现在请你帮忙计算下，最少需要花费多少钱，就能让这 n 户人家连接起来。\ncost 为一个二维数组，每个元素是一个长度为 3 的一维数组\na[1] 表示村庄\na[0] 和村庄\na[1] 有一条路，修这条路的成本价格为\na[2] 。\n参考题目 kruskal算法+并查集 具体做法：\n最小生成树，我们可以连通的点看成是同一个并查集，利用并查集的思想来逐渐加边使所有节点连在一起。同时，最小生成树需要用kruskal算法的贪心思想，先对邻接表按照边权递增排序，然后从最小的边开始遍历，检查边的两边是否在同一个并查集中，如果在则不加这条边，如果不在则将这条边加入总边权，同时设置二者属于同一个并查集。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: static bool cmp(vector\u0026lt;int\u0026gt;\u0026amp;x ,vector\u0026lt;int\u0026gt; \u0026amp;y) { return x[2]\u0026lt;y[2]; } int find(vector\u0026lt;int\u0026gt; \u0026amp;p,int x) { if(p[x] !=x) p[x] = find(p,p[x]); return p[x]; } int miniSpanningTree(int n, int m, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;\u0026amp; cost) { // write code here vector\u0026lt;int\u0026gt; parent(n+1); for(int i=0;i\u0026lt;=n;++i) parent[i] = i; sort(cost.begin(),cost.end(),cmp); int res=0; for(vector\u0026lt;int\u0026gt;\u0026amp;v: cost) { int x = v[0],y=v[1],w = v[2]; int px = find(parent,x),py = find(parent,y); if(px!=py) { res+=w; parent[px] = py; } } return res; } }; ","date":"2024-02-27T00:15:43Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%8E%9F%E7%90%86/","tags":["并查集"],"title":"并查集算法原理\u0026最小生成树"},{"categories":["拓扑排序"],"contents":"拓扑排序模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; /* clang-format off */ #define debug 1 int main() { int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; unordered_map\u0026lt;int,vector\u0026lt;int\u0026gt; \u0026gt;g ; vector\u0026lt;int\u0026gt; d(n+1) ; for(int k=0;k\u0026lt;m;k++) { int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; g[u].push_back(v); d[v]++; } queue\u0026lt;int\u0026gt; q; for(int i=1;i\u0026lt;=n;i++) if(d[i]==0) q.push(i); if(q.size()==0) { puts(\u0026#34;-1\u0026#34;); return 0; } vector\u0026lt;int\u0026gt; seq; while(q.size()) { int x = q.front();q.pop(); seq.push_back(x); for(auto ne: g[x]) { d[ne]--; if(d[ne]==0) q.push(ne); } } if(seq.size() != n) { puts(\u0026#34;-1\u0026#34;); return 0; } for(int i=0,n=seq.size();i\u0026lt;n;i++) { printf(\u0026#34;%d\u0026#34;,seq[i]); if(i+1\u0026lt;n) printf(\u0026#34; \u0026#34;); } return 0; } 拓扑排序变题 现在有一个\nn个点\nm条边的有向无环图，图中无重边与自环，牛牛在无向图中编号为\nt的节点。\n现在给你\nq次询问，每次给定一个起点\ns，问你有多少种不同的方式可以走到牛牛所在的节点\nt(两种方案不同，当且仅当经过的点的序列不同)。\n由于答案可能比较大，你只需要输出它对100007取模的值即可。\n[[....\\dp\\背包汇总\\01背包模板.md]]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 100007; int main() { int n,m,t; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;t; unordered_map\u0026lt;int,vector\u0026lt;int\u0026gt; \u0026gt;mp ; vector\u0026lt;int\u0026gt; ind(n+1); // vector\u0026lt;int\u0026gt; dfn(n+1); // vector\u0026lt;int\u0026gt; mdfn(n+1); for(int i=0;i\u0026lt;m;i++) { int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; mp[u].push_back(v); ind[v]++; } int qx; int cnt=0; cin\u0026gt;\u0026gt;qx; queue\u0026lt;int\u0026gt; q; for(int i=1;i\u0026lt;=n;i++) if(ind[i]==0) q.push(i); vector\u0026lt;int\u0026gt; seq; while(q.size()) { int x = q.front();q.pop(); seq.push_back(x); for(auto p: mp[x]) { ind[p]--; if(ind[p]==0) q.push(p); } } vector\u0026lt;int\u0026gt; dp(n+1); dp[t] = 1; for(int i=seq.size()-1;i\u0026gt;=0;i--) { //参考01背包，倒着遍历,每个点只用1次 int k = seq[i]; for(auto ne: mp[k]) { dp[k] = (dp[k] + dp[ne]) % mod; } } for(int i=0;i\u0026lt;qx;i++) { int s; cin\u0026gt;\u0026gt;s; //s-\u0026gt;t cnt cout \u0026lt;\u0026lt; dp[s]\u0026lt;\u0026lt;endl; } return 0; } ","date":"2024-02-25T14:58:35Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","tags":["拓扑排序"],"title":"拓扑排序"},{"categories":["快速幂"],"contents":" VC26方程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; long long mod_v = 998244353; long long qsm(long long base,int x) { if(x==0) return 1; if(x % 2 !=0) return base * qsm(base,x-1) % mod_v; auto p = qsm(base,x/2); return p*p % mod_v; } int main() { int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; int x=0; for (char f:s) { if(f==\u0026#39;0\u0026#39;)x++; } printf(\u0026#34;%lld\\n\u0026#34;,qsm(2,x)); } ","date":"2024-02-25T14:48:49Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/%E5%BF%AB%E9%80%9F%E5%B9%82/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%8E%9F%E7%90%86/","tags":["快速幂"],"title":"快速幂原理"},{"categories":["差分"],"contents":"一维差分的定义 $$\na_5 = \u0026lt;3,1,8,9,2\u0026gt;\n$$\n$$\nb_n = a_n - a_{n-1} \\\na_n= {0,3,1,8,9,2,0} \\\nb_n={0,3,-2,7,1,-7,-2,0}\\\n$$\n对于差分来说，通常习惯于对数组前后补0，方便处理\n练习题 给你一个长度为n的正数数组 a1~an\n接下来对这个数组进行m次操作，每个操作包含三个参数l,r,k, 对 a[l-r] 范围内加上k\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;long long\u0026gt; dp(n + 1); vector\u0026lt;int\u0026gt; a(n + 10); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; for (int j = 0; j \u0026lt; m; j++) { int l, r, k; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k; dp[l - 1] += k; //题目数组索引从 1开始,所以-1, dp[r] -= k; } long long ans = 0; for (int i = 0; i \u0026lt; n; i++) { ans += dp[i]; cout \u0026lt;\u0026lt; ans + a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 其他例题 现在有一个从左到右被分为\nn个格子的木板，初始木板的每个位置都没有颜料。\n现在有一种特殊的颜料:\n当一个没有颜料的位置或者蓝色的位置被涂抹上这种颜料时，那个位置就会变成红色； 如果一个红色的位置被涂上这种颜料时，那个位置就会变成绿色； 如果一个绿色的位置被涂上这种颜料时，那个位置就会变成蓝色。\n也就是说，对于某个位置，如果它初始没有颜料，并且被多次涂抹颜料时，它的颜色变化是这样的：无颜色-\u0026gt;红色-\u0026gt;绿色-\u0026gt;蓝色-\u0026gt;红色-\u0026gt;绿色 \u0026hellip;\n现在给你\nq次操作，每次操作给定一个闭区间\n[l,r]表示把这个区间里所有格子涂上一遍颜料，我想要你在所有操作结束后，告诉我每个格子是什么颜色。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; void printx(int x) { if (x == 0) { printf(\u0026#34;O\u0026#34;); return; } x = (x - 1) % 3; switch (x) { case 0: printf(\u0026#34;R\u0026#34;); break; case 1: printf(\u0026#34;G\u0026#34;); break; case 2: printf(\u0026#34;B\u0026#34;); break; } } vector\u0026lt;int\u0026gt; a; int main() { int n, k, l, r; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; a.resize(n + 2); while (k--) { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; a[l] += 1; a[min(r + 1, n+1)] -= 1; } l = 0; for (int i = 1; i \u0026lt;= n; i++) { l += a[i]; printx(l); } return 0; } ","date":"2024-02-24T20:16:02Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E5%B7%AE%E5%88%86/%E5%B7%AE%E5%88%86%E5%9F%BA%E7%A1%80%E9%A2%98%E5%92%8C%E7%90%86%E8%A7%A3/","tags":["差分"],"title":"差分基础题和理解"},{"categories":["背包汇总"],"contents":"01背包和完全背包模板 你有一个背包，最多能容纳的体积是V。\n现在有n个物品，第i个物品的体积为vi ，价值wi\n（1）求这个背包至多能装多大价值的物品？\n（2）若背包恰好装满，求至多能装多大价值的物品？\n[[..\\01背包问题.md]]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* clang-format on */ const auto io_sync_off=[]() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }(); int w[1000]; int v[1000]; int dp[1000]; int main() { int n,V; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;V; for(int i=0;i\u0026lt;n;i++) { cin\u0026gt;\u0026gt;v[i]\u0026gt;\u0026gt;w[i]; } // 0表示可以从任意状态转移到 j memset(dp,0,sizeof dp); for(int i=0;i\u0026lt;n;i++) { //由于每个物品只能用一次，为了防止重复计算，需要倒序遍历 for(int j=V;j\u0026gt;=v[i];j--) { //状态转移，要么选择第i件物品，要么不选，取价值最大的 dp[j] = max(dp[j],dp[j-v[i]] + w[i]); } } int mx=dp[V]; // 所有的状态都不可达，将0置为0， 即 所有的 j状态必须都要从0转移过去 memset(dp,-0x3f,sizeof dp); dp[0] = 0; for(int i=0;i\u0026lt;n;i++) { for(int j=V;j\u0026gt;=v[i];j--) { dp[j] = max(dp[j],dp[j-v[i]] + w[i]); } } printf(\u0026#34;%d\\n%d\\n\u0026#34;, max(mx,0), max(dp[V],0)); } 完全背包 你有一个背包，最多能容纳的体积是V。\n现在有n类物品，第i类物品的体积为vi ，价值wi (数量无限)\n（1）求这个背包至多能装多大价值的物品？\n（2）若背包恰好装满，求至多能装多大价值的物品？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /*clang-format on*/ const auto io_sync_off=[]() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }(); int w[1000]; int v[1000]; int dp[1000]; int main() { int n,V; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;V; for(int i=0;i\u0026lt;n;i++) { cin\u0026gt;\u0026gt;v[i]\u0026gt;\u0026gt;w[i]; } memset(dp,0,sizeof dp); for(int i=0;i\u0026lt;n;i++) { for(int j=v[i];j\u0026lt;=V;j++) { dp[j] = max(dp[j],dp[j-v[i]] + w[i]); } } int mx=dp[V]; memset(dp,-0x3f,sizeof dp); dp[0] = 0; for(int i=0;i\u0026lt;n;i++) { for(int j=v[i];j\u0026lt;=V;j++) { dp[j] = max(dp[j],dp[j-v[i]] + w[i]); } } printf(\u0026#34;%d\\n%d\\n\u0026#34;,max(mx,0),max(dp[V],0)); } 下面是例题练习\ndp43 最少的完全平方数 给定一个正整数n，请找出最少个数的完全平方数，使得这些完全平方数的和等于n。\n完全平方指用一个整数乘以自己例如11，22，3*3等，依此类推。若一个数能表示成某个整数的平方的形式，则称这个数为完全平方数。例如:1，4，9，和16都是完全平方数，但是2，3，5，8，11等等不是\n输入：\n5\n输出：\n2\n说明：\n1+4=5\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int main() { int n ; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); int mx = sqrt(n); if(mx*mx == n) { printf(\u0026#34;1\u0026#34;); return 0; } vector\u0026lt;int\u0026gt; dp(n+1,0x3f); dp[0] = 0; for(int i=1;i\u0026lt;=mx;i++) { for(int j=i*i;j\u0026lt;=n;j++) { dp[j] = min(dp[j],dp[j-i*i] + 1); } } printf(\u0026#34;%d\\n\u0026#34;,dp[n]); return 0; } DP 44 兑换零钱 给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，\n再给定一个aim，代表要找的钱数，求组成aim的最少货币数。\n如果无解，请返回-1.\n输入描述：\n3 20\n5 2 3\n第一行给定两个正整数分别是 n 和 aim 分别表示数组 arr 的长度和要找的钱数。\n第二行给定 n 个正整数表示 arr 数组中的所有元素\n输出描述：\n输出组成 aim 的最少货币数\n4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n,aim; scanf(\u0026#34;%d %d\\n\u0026#34;,\u0026amp;n,\u0026amp;aim); vector\u0026lt;int\u0026gt; dp(aim+1,INT_MAX-1); dp[0] = 0; for(int i=0;i\u0026lt;n;i++) { int item; scanf(\u0026#34;%d\u0026#34;,\u0026amp;item); for(int j=item;j\u0026lt;=aim;j++) dp[j] = min(dp[j],dp[j-item]+1); } printf(\u0026#34;%d\\n\u0026#34;,dp[aim]==INT_MAX-1? -1:dp[aim]); return 0; } DP45 分割等和子集 描述\n给定一个只包含正整数的数组 nums ，请问能否把这个数组取出若干个数使得取出的数之和和剩下的数之和相同。\n第一行输入一个正整数 n ，表示数组 nums 的长度。\n第二行输入 n 个正整数，表示数组中的值。\n4\n1 5 11 5\ntrue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int total = 0; vector\u0026lt;int\u0026gt; a(n); for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); total += a[i]; } if (total % 2 != 0) { puts(\u0026#34;false\u0026#34;); return 0; } int mx = (1 \u0026lt;\u0026lt; 31) - 1; //技巧 INT_MAX (1 \u0026lt;\u0026lt; (sizeof(int) * 8 - 1)) // 1\u0026lt;\u0026lt;31 最大 total /= 2; vector\u0026lt;int\u0026gt; dp(total, mx); dp[0] = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = total; j \u0026gt;= a[i]; j--) { dp[j] = min(dp[j - a[i]] + 1, dp[j]); } } if (dp[total] == mx) { puts(\u0026#34;false\u0026#34;); } else puts(\u0026#34;true\u0026#34;); return 0; } dp46 装箱问题 有一个箱子容量为 V ，同时有n个物品，每个物品有一个体积（正整数）。每个物品只能使用一次。\n要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。\n第一行输入一个正整数 V 表示箱子的容量，\n第二行输入一个正整数 n 表示物品的个数。\n后续 n 行每行输入一个正整数表示物品的体积\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; /** 有一个箱子容量为 V ，同时有n个物品，每个物品有一个体积（正整数）。每个物品只能使用一次。 要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。 */ int main() { int V,n; cin\u0026gt;\u0026gt;V\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n); int no = 0; vector\u0026lt;int\u0026gt; dp(V+1,no); for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i]; for(int i=0;i\u0026lt;n;i++) { for(int j=V;j\u0026gt;=a[i];j--) dp[j] = max(dp[j],dp[j-a[i]]+a[i]); } cout \u0026lt;\u0026lt; V- dp[V] \u0026lt;\u0026lt;endl; return 0; } ","date":"2024-02-24T18:29:19Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E8%83%8C%E5%8C%85%E6%B1%87%E6%80%BB/01%E8%83%8C%E5%8C%85%E6%A8%A1%E6%9D%BF/","tags":["背包汇总"],"title":"01背包和完全背包模板"},{"categories":["牛客算法汇总"],"contents":"题目 描述\n给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。\n要求:\n空间复杂度 O(N), 时间复杂度 O(nlogk)\n前置知识 1 2 3 4 //升序队列 小顶堆 great 小到大 priority_queue \u0026lt;int,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt; \u0026gt; pq;//升序 //降序队列 大顶堆 less 大到小 默认 priority_queue \u0026lt;int,vector\u0026lt;int\u0026gt;,less\u0026lt;int\u0026gt; \u0026gt; pq;//降序 函数/方法 top() 访问队头\nempty()\nsize()\npush() / emplace\npop\nswap\n这是一个拥有权值queue，其内部元素按照元素的权值排列。权值较高者排在最前优先出队。其中缺省情况下系统是通过一个max-heap以堆实现完成排序特性，表现为一个以vector表现的完全二叉树。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param input int整型vector * @param k int整型 * @return int整型vector */ vector\u0026lt;int\u0026gt; GetLeastNumbers_Solution(vector\u0026lt;int\u0026gt;\u0026amp; input, int k) { // write code heroe priority_queue\u0026lt;int\u0026gt; q; int n = input.size(); for(int j:input) { q.push(j); if(q.size() \u0026gt; k) q.pop(); } vector\u0026lt;int\u0026gt;res(k); while(k) { res[k-1] = (q.top()); q.pop(); k--; } return res; } }; ","date":"2024-02-05T22:26:03Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/%E6%9C%80%E5%B0%8Fk%E4%B8%AA%E6%95%B0/","tags":["牛客算法汇总"],"title":"最小k个数"},{"categories":["牛客算法汇总"],"contents":"相关题目 [[..\\哈希表\\LRU缓存实现.md]]\nhttps://www.nowcoder.com/practice/5dfded165916435d9defb053c63f1e84?tpId=117\u0026tags=\u0026title=\u0026difficulty=0\u0026judgeStatus=0\u0026rp=1\u0026sourceUrl=%2Fexam%2Fcompany 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct Node { int val; int key; Node *next; Node *prev; Node() { this-\u0026gt;next = nullptr; this-\u0026gt;prev = nullptr; this-\u0026gt;key = 0; this-\u0026gt;val = 9999; } }; class Solution { public: Solution(int capacity) { // write code here cap = capacity; first = new Node(); tail = new Node(); tail-\u0026gt;next = NULL; first-\u0026gt;prev = NULL; link(first, tail); } int cap; unordered_map\u0026lt;int, Node *\u0026gt; tab; Node *first; Node *tail; void link(Node *l, Node *r) { if(l \u0026amp;\u0026amp; r) { l-\u0026gt;next = r; r-\u0026gt;prev = l; } } void printlist() { auto x = first; while(x) { cout \u0026lt;\u0026lt;\u0026#34;{\u0026#34;\u0026lt;\u0026lt;x-\u0026gt;key\u0026lt;\u0026lt;\u0026#34;,\u0026#34; \u0026lt;\u0026lt;x-\u0026gt;val \u0026lt;\u0026lt; \u0026#34;} -\u0026gt; \u0026#34;; x=x-\u0026gt;next; } cout \u0026lt;\u0026lt;endl; } void remove(Node *x, int key) { // cout \u0026lt;\u0026lt; x-\u0026gt;val \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; key \u0026lt;\u0026lt; endl; // if(x == first) return; auto p = x-\u0026gt;prev; auto n = x-\u0026gt;next; x-\u0026gt;next = NULL; x-\u0026gt;prev = NULL; link(p, n); if (key \u0026gt;= 0) { tab.erase(key); } } void puthead(Node *x) { auto right = first-\u0026gt;next; link(first, x); link(x, right); } int get(int key) { printlist(); // write code here if (!tab.count(key)) return -1; auto n = tab[key]; remove(n, -1); puthead(n); return n-\u0026gt;val; } void set(int key, int value) { printlist(); // write code here bool ok = tab.count(key); if (ok) { get(key); tab[key]-\u0026gt;val = value; } else { if (tab.size() \u0026gt;= cap) { remove(tail-\u0026gt;prev, tail-\u0026gt;prev-\u0026gt;key); } // insert auto n = new Node(); n-\u0026gt;val = value; n-\u0026gt;key = key; tab[key] = n; puthead(n); } } }; /** * Your Solution object will be instantiated and called as such: * Solution* solution = new Solution(capacity); * int output = solution-\u0026gt;get(key); * solution-\u0026gt;set(key,value); */ int main(void) { auto p = Solution(2); p.set(1, 2); p.set(2, 2); p.get(1); p.set(3, 3); p.get(2); p.set(4, 4); p.get(1); p.get(3); p.get(4); return 0; } ","date":"2024-02-05T22:10:21Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/lru%E7%BC%93%E5%AD%98/","tags":["牛客算法汇总"],"title":"lru缓存"},{"categories":["背包汇总"],"contents":" leetcode\n2742.给墙壁刷油漆 algorithms\nHard (37.12%)\nLikes: 38\nDislikes: 0\nTotal Accepted: 3.4K\nTotal Submissions: 9.1K\nTestcase Example: \u0026lsquo;[1,2,3,2]\\n[1,2,3,2]\u0026rsquo;\n给你两个长度为 n 下标从 0 开始的整数数组 cost\n和 time ，分别表示给 n 堵不同的墙刷油漆需要的开销和时间。你有两名油漆匠：\n一位需要\n付费 的油漆匠，刷第 i 堵墙需要花费 time[i] 单位的时间，开销为 cost[i] 单位的钱。\n一位 免费 的油漆匠，刷\n任意 一堵墙的时间为 1 单位，开销为 0 。但是必须在付费油漆匠 工作 时，免费油漆匠才会工作。\n请你返回刷完 n 堵墙最少开销为多少。\n示例 1：\n输入：cost = [1,2,3,2], time = [1,2,3,2]\n输出：3\n解释：下标为 0 和 1 的墙由付费油漆匠来刷，需要 3\n单位时间。同时，免费油漆匠刷下标为 2 和 3 的墙，需要 2 单位时间，开销为 0\n。总开销为 1 + 2 = 3 。\n示例 2：\n输入：cost = [2,3,4,2], time = [1,1,1,1]\n输出：4\n解释：下标为 0 和 3 的墙由付费油漆匠来刷，需要 2\n单位时间。同时，免费油漆匠刷下标为 1 和 2 的墙，需要 2 单位时间，开销为 0\n。总开销为 2 + 2 = 4 。\n提示：\n1 \u0026lt;= cost.length \u0026lt;= 500\ncost.length == time.length\n1 \u0026lt;= cost[i] \u0026lt;= 10^6\n1 \u0026lt;= time[i] \u0026lt;= 500\n思路 : 选和不选 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // @lc code=start class Solution { public: int paintWalls(vector\u0026lt;int\u0026gt; \u0026amp;cost, vector\u0026lt;int\u0026gt; \u0026amp;time) { int n = cost.size(); if (n \u0026lt;= 0) return 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; memo(n, vector\u0026lt;int\u0026gt;(n*2+1, -1)); function\u0026lt;int(int, int)\u0026gt; dfs = [\u0026amp;](int i, int j) -\u0026gt; int { if (j \u0026gt; i) return 0; if (i \u0026lt; 0) return 0x3f3f3f3f; if (memo[i][j+n] != -1) return memo[i][j+n]; // int l = ; long long res = 0; res = min({1ll* dfs(i - 1, j + time[i]) + cost[i], 1ll * dfs(i - 1, j - 1)}); return memo[i][j+n] = res; }; return dfs(n - 1, 0); } // dfs(i,j) -\u0026gt; 0~i面墙 ，免费刷j面墙 // 付费 dfs(i,j) = dfs(i-1,j+time[i]) + cost[i] // free dfs(i,j) = min(dfs(i-1,j+time[i]) + cost[i] , dfs(i-1,j-1)) /** if(j\u0026gt;i) return 0 */ }; // @lc code=end int main() { # ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2742] 给墙壁刷油漆\u0026#34; \u0026lt;\u0026lt; endl; # endif Solution k; vector\u0026lt;int\u0026gt;a{1,2,3,2} ; vector\u0026lt;int\u0026gt;b{1,2,3,2} ; cout \u0026lt;\u0026lt; k.paintWalls(a,b)\u0026lt;\u0026lt;endl; return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public: int paintWalls(vector\u0026lt;int\u0026gt; \u0026amp;cost, vector\u0026lt;int\u0026gt; \u0026amp;time) { int n = cost.size(); if (n \u0026lt;= 0) return 0; //前N个物品，体积和至少是N，最小化cost //f[i][j] vector\u0026lt;int\u0026gt; dp(n+1,0x3f3f3f3f) ; dp[0] = 0; for(int i=0;i\u0026lt;n;i++) { for (int j=n;j;j--) { dp[j] = min(dp[max(j - (time[i]+1),0)] + cost[i],dp[j]); } } return dp[n]; } int paintWalls_DFS(vector\u0026lt;int\u0026gt; \u0026amp;cost, vector\u0026lt;int\u0026gt; \u0026amp;time) { int n = cost.size(); if (n \u0026lt;= 0) return 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; memo(n, vector\u0026lt;int\u0026gt;(n*2+1, -1)); function\u0026lt;int(int, int)\u0026gt; dfs = [\u0026amp;](int i, int j) -\u0026gt; int { if (j \u0026gt; i) return 0; if (i \u0026lt; 0) return 0x3f3f3f3f; if (memo[i][j+n] != -1) return memo[i][j+n]; // int l = ; long long res = 0; res = min({1ll * dfs(i - 1, j + time[i]) + cost[i], 1ll * dfs(i - 1, j - 1)}); return memo[i][j+n] = res; }; return dfs(n - 1, 0); } // dfs(i,j) -\u0026gt; 0~i面墙 ，免费刷j面墙 // 付费 dfs(i,j) = dfs(i-1,j+time[i]) + cost[i] // free dfs(i,j) = min(dfs(i-1,j+time[i]) + cost[i] , dfs(i-1,j-1)) /** if(j\u0026gt;i) return 0 */ }; ","date":"2024-02-03T22:36:50Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E8%83%8C%E5%8C%85%E6%B1%87%E6%80%BB/lc.2742.%E7%BB%99%E5%A2%99%E5%A3%81%E5%88%B7%E6%B2%B9%E6%BC%86/","tags":["背包汇总"],"title":"lc.2742.给墙壁刷油漆"},{"categories":["序列边界"],"contents":" leetcode 2741.特别的排列 algorithms\nMedium (36.58%)\nLikes: 38\nDislikes: 0\nTotal Accepted: 4.6K\nTotal Submissions: 12.6K\nTestcase Example: \u0026lsquo;[2,3,6]\u0026rsquo;\n给你一个下标从 0 开始的整数数组 nums ，它包含 n 个 互不相同 的正整数。如果 nums\n的一个排列满足以下条件，我们称它是一个特别的排列：\n对于 0 \u0026lt;= i \u0026lt; n - 1 的下标 i ，要么 nums[i] % nums[i+1] == 0 ，要么 nums[i+1] % nums[i]\n== 0 。\n请你返回特别排列的总数目，由于答案可能很大，请将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入：nums = [2,3,6]\n输出：2\n解释：[3,6,2] 和 [2,6,3] 是 nums 两个特别的排列。\n示例 2：\n输入：nums = [1,4,3]\n输出：2\n解释：[3,1,4] 和 [4,1,3] 是 nums 两个特别的排列。\n提示：\n2 \u0026lt;= nums.length \u0026lt;= 14\n1 \u0026lt;= nums[i] \u0026lt;= 10^9\nDP 定义 定义 dp(i,j) 表示当前可选集合 i,上一个选的数的下标是j时, 可以构造出多少个特别序列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // @lc code=start class Solution { public: const int MOD = 1e9 + 7; int specialPerm(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int maxsize = 15; int n = nums.size(); if(n\u0026lt;=1) return n; int all1 = (1\u0026lt;\u0026lt;n) -1; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; dp(1\u0026lt;\u0026lt;n,vector\u0026lt;int\u0026gt;(n,0)); //f[mask][end] = f[mask][end] + f[prev_mask][prev_end] for(int i=0;i\u0026lt;n;i++) dp[0][i] = 1; for(int i=1;i\u0026lt;= all1;i++) { for(int j=0;j\u0026lt;n;j++) { //父节点 for(int k=0;k\u0026lt;n;k++) { //子节点 if(((i\u0026gt;\u0026gt;k) \u0026amp; 1)\u0026gt;0 \u0026amp;\u0026amp; (nums[j] % nums[k] == 0 or nums[k] % nums[j] == 0) ) { dp[i][j] = (dp[i][j] + dp[i ^ (1\u0026lt;\u0026lt;k)][k]) % MOD; } } } } int res=0; for(int i=0;i\u0026lt;n;i++) { // 0 1 =\u0026gt; 1 // 1 1 =\u0026gt; 0 // 0 0 =\u0026gt; 1 res = (res + dp[all1 ^ (1\u0026lt;\u0026lt;i)][i] ) % MOD; } return res; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2741] 特别的排列\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; vector\u0026lt;int\u0026gt; nums{2,3,6} ; cout \u0026lt;\u0026lt; k.specialPerm(nums) \u0026lt;\u0026lt;endl; return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func specialPerm(nums []int) (ans int) { const mod int = 1e9 + 7 n := len(nums) m := 1 \u0026lt;\u0026lt; n memo := make([][]int, m) for i := range memo { memo[i] = make([]int, n) for j := range memo[i] { memo[i][j] = -1 } } var dfs func(int, int) int dfs = func(i, j int) (res int) { if i == 0 { return 1 // 找到一个特别排列 } p := \u0026amp;memo[i][j] if *p != -1 { return *p } for k, x := range nums { if i\u0026gt;\u0026gt;k\u0026amp;1 \u0026gt; 0 \u0026amp;\u0026amp; (nums[j]%x == 0 || x%nums[j] == 0) { res = (res + dfs(i^(1\u0026lt;\u0026lt;k), k)) % mod } } *p = res return } for j := range nums { ans = (ans + dfs((m-1)^(1\u0026lt;\u0026lt;j), j)) % mod } return } 其他参考 [[..\\状态压缩\\lc.1655.分配重复整数.md]]\n","date":"2024-02-03T21:44:08Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E5%BA%8F%E5%88%97%E5%88%92%E5%88%86dp/lc.2741.%E7%89%B9%E5%88%AB%E7%9A%84%E6%8E%92%E5%88%97/","tags":["序列边界"],"title":"lc.2741.特别的排列"},{"categories":["序列边界"],"contents":" leetcode\n2771.构造最长非递减子数组 algorithms\nMedium (34.79%)\nLikes: 27\nDislikes: 0\nTotal Accepted: 5.7K\nTotal Submissions: 16.5K\nTestcase Example: \u0026lsquo;[2,3,1]\\n[1,2,1]\u0026rsquo;\n给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，长度均为 n 。\n让我们定义另一个下标从 0 开始、长度为 n 的整数数组，nums3 。对于范围 [0, n - 1]\n的每个下标 i ，你可以将 nums1[i] 或 nums2[i] 的值赋给 nums3[i] 。\n你的任务是使用最优策略为 nums3 赋值，以最大化 nums3 中 最长非递减子数组 的长度。\n以整数形式表示并返回 nums3 中 最长非递减 子数组的长度。\n注意：子数组 是数组中的一个连续非空元素序列。\n示例 1：\n输入：nums1 = [2,3,1], nums2 = [1,2,1]\n输出：2\n解释：构造 nums3 的方法之一是：\nnums3 = [nums1[0], nums2[1], nums2[2]] =\u0026gt; [2,2,1]\n从下标 0 开始到下标 1 结束，形成了一个长度为 2 的非递减子数组 [2,2] 。\n可以证明 2 是可达到的最大长度。\n示例 2：\n输入：nums1 = [1,3,2,1], nums2 = [2,2,3,4]\n输出：4\n解释：构造 nums3 的方法之一是：\nnums3 = [nums1[0], nums2[1], nums2[2], nums2[3]] =\u0026gt; [1,2,3,4]\n整个数组形成了一个长度为 4 的非递减子数组，并且是可达到的最大长度。\n示例 3：\n输入：nums1 = [1,1], nums2 = [2,2]\n输出：2\n解释：构造 nums3 的方法之一是：\nnums3 = [nums1[0], nums1[1]] =\u0026gt; [1,1]\n整个数组形成了一个长度为 2 的非递减子数组，并且是可达到的最大长度。\n提示：\n1 \u0026lt;= nums1.length == nums2.length == n \u0026lt;= 10^5\n1 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 10^9\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // @lc code=start class Solution { public: int maxNonDecreasingLength(vector\u0026lt;int\u0026gt; \u0026amp;nums1, vector\u0026lt;int\u0026gt; \u0026amp;nums2) { int n = nums1.size(); if (n \u0026lt;= 0) return 0; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; memo (n,vector\u0026lt;int\u0026gt;(2,INT_MIN) ); function\u0026lt;int(int,int)\u0026gt; dfs = [\u0026amp;](int i,int j) -\u0026gt; int { if(i==0) return 1; if (memo[i][j] != INT_MIN) return memo[i][j]; int ans = 1; int num = j==0? nums1[i]: nums2[i]; if(num \u0026gt;= nums1[i-1]) ans = dfs(i-1,0) +1; if(num \u0026gt;= nums2[i-1]) ans = max(ans,dfs(i-1,1) + 1); return memo[i][j] = ans; }; int res=1; for(int start=1;start\u0026lt;n;start++) { res = max({res,dfs(start,0),dfs(start,1)}); } return res; } }; // @lc code=end int main() { # ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2771] 构造最长非递减子数组\u0026#34; \u0026lt;\u0026lt; endl; # endif Solution k; vector\u0026lt;int\u0026gt; a{ 1,3,2,1 }; vector\u0026lt;int\u0026gt; b{ 2,2,3,4 }; cout \u0026lt;\u0026lt; k.maxNonDecreasingLength(a, b) \u0026lt;\u0026lt; endl; return 0; } ","date":"2024-02-03T18:01:18Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E5%BA%8F%E5%88%97%E5%88%92%E5%88%86dp/lc.2771.%E6%9E%84%E9%80%A0%E6%9C%80%E9%95%BF%E9%9D%9E%E9%80%92%E5%87%8F%E5%AD%90%E5%BA%8F%E5%88%97/","tags":["序列边界"],"title":"lc.2771.构造最长非递减子序列"},{"categories":["序列边界"],"contents":" 参考教程 [[....\\差分\\lc.2772.使数组中的所有元素都等于0.md]]\n[[..\\lc.300.最长上升子序列.md]]\n[[..\\动态规划基础.md]]\n[[..\\01背包问题.md]]\n[[lc.2741.特别的排列.md]]\n最长递增子序列模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if (n\u0026lt;=1) return n; vector\u0026lt;int\u0026gt; len(n,1); // 最短是它本身 for (int i=0;i\u0026lt;n;i++) { for (int j=0;j\u0026lt;i;j++) { if(nums[i] \u0026gt; nums[j]) { len[i] = max(len[i],len[j]+1); } } } //求出 每一个 i 结尾的 最长序列长度，寻找到最长的序列长度就是答案 int res = 0; for (int i=0;i\u0026lt;n;i++) res = max(res,len[i]); return res; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; tail; int n =nums.size() ; for(int i=0;i\u0026lt;n;i++) { int cur = nums[i]; auto it = lower_bound(tail.begin(),tail.end(),cur); if(it == tail.end()) { tail.push_back(cur); }else { *it = cur; } } return tail.size(); } }; 给定一个长度为 n 的数组 arr，求它的最长严格上升子序列的长度。\n所谓子序列，指一个数组删掉一些数（也可以不删）之后，形成的新数组。例如 [1,5,3,7,3] 数组，其子序列有：[1,3,3]、[7] 等。但 [1,6]、[1,3,5] 则不是它的子序列。\n例如：\n输入\n7\n6 3 1 5 2 3 7\n输出\n4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n;cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n) ; for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i]; vector\u0026lt;int\u0026gt; que; for(int k: a) { if(que.size()==0) { que.push_back(k); }else{ if(k \u0026gt; que.back()) { que.push_back(k); }else { auto p = lower_bound(que.begin(),que.end(),k); *p = k; } } } cout \u0026lt;\u0026lt; que.size() \u0026lt;\u0026lt;endl; return 0; } dilworld定理 它描述了有限偏序集的宽度，根据序列划分的最小数量的链来确定。这个定理的名称取自数学家Robert P. Dilworth。\n在偏序集中，链是指集合中任意两个元素都可比的偏序子集，而反链则是指集合中任意两个元素都不可比的偏序子集。Dilworth定理的核心内容是：对于一个有限偏序集，其最小链划分中链的数量等于其反链长度的最大值。换句话说，最长反链中元素的数目必等于最小链覆盖中链的数目，这个数目也等于偏序集的宽度。\n这个定理在组合数学、图论和计算机科学等领域都有广泛的应用，特别是在处理排序、优化和算法设计等问题时。通过理解和应用Dilworth定理，我们可以更好地理解和分析偏序集的结构和性质，从而更有效地解决相关问题。\n什么是偏序呢？\n在数学中，偏序是一种二元关系，它满足自反性、反对称性和传递性。给定集合S上的一个偏序关系“≤”，对于S中的任意元素a和b，如果a≤b并且b≤a，则称a和b是等价的（记作a≈b）。偏序集合是一个装备了偏序关系的集合。偏序关系与等价关系的主要区别在于，偏序关系不必是对称的。\n偏序的关系： 自反性，对称性，传递性\n偏序教程 Dilworth定理 最少的下降序列个数就等于整个序列最长上升子序列的长度\n参考 拦截导弹 某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只一套系统，因此有可能不能拦截所有的导弹。\n输入导弹依次飞来的高度（雷达给出的高度数据是不大于1000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。\n输入描述：\n第一行输入一个正整数 n ，表示导弹的个数\n第二行输入 n 个正整数，表示导弹的高度\n输出描述：\n输出一套拦截系统最多拦截多少导弹和最少要配备多少套导弹拦截系统两个正整数\n考虑一个序列：2, 1, 3, 4。\n通过观察，我们可以得到1, 3, 4作为最长上升子序列，其长度为3。\n接下来，我们应用Dilworth定理的概念。我们要将这个序列划分为尽可能少的不上升子序列。\n一种可能的下降子序列划分是：\n2, 1（下降）\n3（单独一个元素）\n4（单独一个元素）\n问： 最长下降子序列 问： 最短下降子序列的划分数量=\u0026gt; 最长上升子序列的长度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int n, res1 = 1, res2 = 1; cin \u0026gt;\u0026gt; n; int arr[n], dp1[n], dp2[n]; for (int i = 0; i \u0026lt; n; ++i) { cin \u0026gt;\u0026gt; arr[i]; dp1[i] = 1; // 最长下降子序列长度 dp2[i] = 1; // 最长上升子序列长度 = 最短下降子序列长度 } // 时间复杂度O(N^2)，空间复杂度O(N) for (int i = 1; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; i; ++j) { if (arr[j] \u0026gt;= arr[i]) dp1[i] = max(dp1[i], dp1[j] + 1); else dp2[i] = max(dp2[i], dp2[j] + 1); } res1 = max(res1, dp1[i]); res2 = max(res2, dp2[i]); } cout \u0026lt;\u0026lt; res1 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; res2; return 0; } DP16 合唱队形 N位同学站成一排，音乐老师要请其中的 (N-K) 位同学出列，使得剩下的K位同学排成合唱队形。\n合唱队形是指这样的一种队形：设K位同学从左到右依次编号为 1，2…，K，他们的身高分别为 t1~tn\nt1\u0026lt;t2\u0026lt; ti \u0026gt;ti+1\u0026gt;...tk(1\u0026lt;=i\u0026lt;=k)\n你的任务是，已知所有 n 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n) ; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } vector\u0026lt;int\u0026gt; l(n + 1, 1), r(n + 1, 1); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { if (a[i] \u0026gt; a[j]) l[i] = max(l[i], l[j] + 1); } } for (int i = n - 1; i \u0026gt;= 0; i--) { for (int j = n - 1; j \u0026gt; i; j--) { if (a[i] \u0026gt; a[j]) r[i] = max(r[i], r[j] + 1); } } int kmore = 0; for (int i = 0; i \u0026lt; n; i++) { int k = l[i] + r[i] - 1; if (kmore \u0026lt; k) { kmore = k; } } cout \u0026lt;\u0026lt; n - kmore \u0026lt;\u0026lt; endl; return 0; } DP17 信封嵌套 给 n 个信封的长度和宽度。如果信封 a 的长和宽都小于信封 b ，那么信封 a 可以放到信封 b 里，请求出信封最多可以嵌套多少层。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; a(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i].first \u0026gt;\u0026gt; a[i].second; if(n==1) { puts(\u0026#34;1\u0026#34;); return 0; } // 转化为最长上升子序列问题 sort(a.begin(), a.end()); vector\u0026lt;int\u0026gt; dp(n + 1, 1); int flag = 1; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { if (a[i].first \u0026gt; a[j].first \u0026amp;\u0026amp; a[i].second \u0026gt; a[j].second) { dp[i] = max(dp[i], dp[j] + 1); flag = max(flag,dp[i]); } } } cout \u0026lt;\u0026lt; flag \u0026lt;\u0026lt; endl; return 0; } 最长公共子序列 给定两个字符串 s1 和 s2，长度为 n 和 m 。求两个字符串最长公共子序列的长度。\n所谓子序列，指一个字符串删掉部分字符（也可以不删）形成的字符串。例如：字符串 \u0026ldquo;arcaea\u0026rdquo; 的子序列有 \u0026ldquo;ara\u0026rdquo; 、 \u0026ldquo;rcaa\u0026rdquo; 等。但 \u0026ldquo;car\u0026rdquo; 、 \u0026ldquo;aaae\u0026rdquo; 则不是它的子序列。\n所谓 s1 和 s2 的最长公共子序列，即一个最长的字符串，它既是 s1 的子序列，也是 s2 的子序列。\n数据范围 :\n1000\n1≤m,n≤1000 。保证字符串中的字符只有小写字母。\n[[..\\动态规划基础.md]]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; string a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; //todo vaid n vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; lcm(n+1,vector\u0026lt;int\u0026gt;(m+1) ); for(int i=0;i\u0026lt;n;i++) { for(int j=0;j\u0026lt;m;j++) { if(a[i] == b[j]) { // dp[i-1][j-1] + 1 if(i-1\u0026gt;=0 \u0026amp;\u0026amp; j-1\u0026gt;=0) { lcm[i][j] = lcm[i-1][j-1]+1; }else { lcm[i][j] = 1; } }else { lcm[i][j] = max(i-1\u0026gt;=0?lcm[i-1][j]:0,j-1\u0026gt;=0? lcm[i][j-1]:0); } } } cout \u0026lt;\u0026lt; lcm[n-1][m-1]; return 0; } 连续子数组的最大和 给定一个长度为\nn 的数组，数组中的数为整数。\n请你选择一个非空连续子数组，使该子数组所有数之和尽可能大，子数组最小长度为1。求这个最大值。\n例如\n8\n1 -2 3 10 -4 7 2 -5\n经分析可知，输入数组的子数组[3,10,-4,7,2]可以求得最大和为18\nhttps://blog.csdn.net/Supreme7/article/details/117398880 ","date":"2024-02-03T00:46:50Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E5%BA%8F%E5%88%97%E5%88%92%E5%88%86dp/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E7%AD%89%E5%81%8F%E5%BA%8F%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/","tags":["序列边界"],"title":"把子数组改成子序列怎么做"},{"categories":["数位dp"],"contents":" leetcode\n2719.统计整数数目 algorithms\nHard (48.27%)\nLikes: 95\nDislikes: 0\nTotal Accepted: 14.6K\nTotal Submissions: 26.1K\nTestcase Example: \u0026lsquo;\u0026ldquo;1\u0026rdquo;\\n\u0026quot;12\u0026quot;\\n1\\n8\u0026rsquo;\n给你两个数字字符串 num1 和 num2 ，以及两个整数 max_sum\n和 min_sum 。如果一个整数 x 满足以下条件，我们称它是一个好整数：\nnum1 \u0026lt;= x \u0026lt;= num2\nmin_sum \u0026lt;= digit_sum(x) \u0026lt;= max_sum.\n请你返回好整数的数目。答案可能很大，请返回答案对 10^9 + 7 取余后的结果。\n注意，digit_sum(x) 表示 x 各位数字之和。\n示例 1：\n输入：num1 = \u0026ldquo;1\u0026rdquo;, num2 = \u0026ldquo;12\u0026rdquo;, min_num = 1, max_num = 8\n输出：11\n解释：总共有 11 个整数的数位和在 1 到 8 之间，分别是 1,2,3,4,5,6,7,8,10,11 和 12\n。所以我们返回 11 。\n示例 2：\n输入：num1 = \u0026ldquo;1\u0026rdquo;, num2 = \u0026ldquo;5\u0026rdquo;, min_num = 1, max_num = 5\n输出：5\n解释：数位和在 1 到 5 之间的 5 个整数分别为 1,2,3,4 和 5 。所以我们返回 5 。\n提示：\n$1 \u0026lt;= num1 \u0026lt;= num2 \u0026lt;= 10^{22}$\n$1 \u0026lt;= min_sum \u0026lt;= max_sum \u0026lt;= 400$\n此外，由于前导零对数位和无影响\n$$\n\\textit{sum}+0=\\textit{sum}\n$$\n模板中的 isNum 可以省略。\n作者：灵茶山艾府\n链接： https://leetcode.cn/problems/count-of-integers/solutions/2296043/shu-wei-dp-tong-yong-mo-ban-pythonjavacg-9tuc/ 来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // @lc code=start class Solution { public: const int MOD = 1e9 + 7; int calc(string \u0026amp;Limit, int L, int R) { int n = Limit.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; memo(n, vector\u0026lt;int\u0026gt;(min(9 *n, R) + 1, -1)); function\u0026lt;int(int, int, bool)\u0026gt; f = [\u0026amp;](int i, int x, bool islimit) -\u0026gt; int { if (x \u0026gt; R) return 0; if (i == n) return x \u0026gt;= L ? 1 : 0; if (!islimit \u0026amp;\u0026amp; memo[i][x] != -1) return memo[i][x]; int up = islimit ? Limit[i] - \u0026#39;0\u0026#39; : 9; int res = 0; for (int d = 0; d \u0026lt;= up; d++) { res = (res*1ll + f(i + 1, x + d, islimit \u0026amp;\u0026amp; d == up)) % MOD; } if (!islimit) memo[i][x] = res; return res; }; return f(0, 0, true); } int count(string num1, string num2, int min_sum, int max_sum) { int res = calc(num2, min_sum, max_sum) - calc(num1, min_sum, max_sum); #ifdef debug cout \u0026lt;\u0026lt; \u0026#34;debug:\u0026#34;\u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; #endif if(res\u0026lt;0) res += MOD; int sum = 0; for (char c : num1) { sum += c - \u0026#39;0\u0026#39;; } if (sum \u0026lt;= max_sum \u0026amp;\u0026amp; sum \u0026gt;= min_sum) return (res + 1) % MOD; return res % MOD; } }; // @lc code=end int main() { # ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2719] 统计整数数目\u0026#34; \u0026lt;\u0026lt; endl; # endif Solution k; cout \u0026lt;\u0026lt; k.count(\u0026#34;1\u0026#34;, \u0026#34;12\u0026#34;, 1, 8) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; k.count(\u0026#34;4179205230\u0026#34;, \u0026#34;7748704426\u0026#34;, 8, 46) \u0026lt;\u0026lt; endl; return 0; } ","date":"2024-02-03T00:21:52Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E6%95%B0%E4%BD%8Ddp/lc.2719.%E7%BB%9F%E8%AE%A1%E6%95%B4%E6%95%B0%E6%95%B0%E7%9B%AE/","tags":["数位dp"],"title":"lc.2719.统计整数数目"},{"categories":["排序"],"contents":" leetcode\n215.数组中的第K个最大元素 algorithms\nMedium (62.15%)\nLikes: 2401\nDislikes: 0\nTotal Accepted: 984.8K\nTotal Submissions: 1.6M\nTestcase Example: \u0026lsquo;[3,2,1,5,6,4]\\n2\u0026rsquo;\n给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。\n请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。\n示例 1:\n输入: [3,2,1,5,6,4], k = 2\n输出: 5\n示例 2:\n输入: [3,2,3,1,2,4,5,5,6], k = 4\n输出: 4\n提示：\n1 \u0026lt;= k \u0026lt;= nums.length \u0026lt;= 10^5\n-10^4 \u0026lt;= nums[i] \u0026lt;= 10^4\n快速选择算法复杂度分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // @lc code=start class Solution { public: int findKthLargest(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { // 0 1 ,1 return qselect(nums,0,nums.size()-1,nums.size() - k+1); } int qselect(vector\u0026lt;int\u0026gt; \u0026amp;nums, int l, int r, int k) { if(r\u0026lt;=l) return nums[l]; int i = l - 1, j = r + 1; int piv = nums[(i + j) / 2]; while (i \u0026lt; j) { do ++i; while (nums[i] \u0026lt; piv); do --j; while (nums[j] \u0026gt; piv); if (i \u0026lt; j) { swap(nums[i], nums[j]); } } int ranksz = j - l + 1; if (k \u0026lt;= ranksz) return qselect(nums, l, j, k); // 1,1 return qselect(nums, j + 1, r, k - ranksz); } }; // @lc code=end 参考模板 [[快速排序代码模板.md]]\n其他解法？ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public: int findKthLargest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { make_heap(nums.begin(),nums.end()); for(int i =0;i\u0026lt;k-1;i++){ pop_heap(nums.begin(),nums.end()); nums.pop_back(); } return nums[0]; } }; ","date":"2024-01-31T22:48:25Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/lc.215.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/","tags":["排序"],"title":"lc.215.数组中第K个最大元素"},{"categories":["数位dp"],"contents":" leetcode 2801.统计范围内的步进数字数目 algorithms\nHard (42.35%)\nLikes: 18\nDislikes: 0\nTotal Accepted: 3K\nTotal Submissions: 7K\nTestcase Example: \u0026lsquo;\u0026ldquo;1\u0026rdquo;\\n\u0026quot;11\u0026quot;\u0026rsquo;\n给你两个正整数 low 和 high ，都用字符串表示，请你统计闭区间 [low, high] 内的 步进数字 数目。\n如果一个整数相邻数位之间差的绝对值都 恰好 是 1 ，那么这个数字被称为 步进数字 。\n请你返回一个整数，表示闭区间 [low, high] 之间步进数字的数目。\n由于答案可能很大，请你将它对 10^9 + 7 取余 后返回。\n注意：步进数字不能有前导 0 。\n示例 1：\n输入：low = \u0026ldquo;1\u0026rdquo;, high = \u0026ldquo;11\u0026rdquo;\n输出：10\n解释：区间 [1,11] 内的步进数字为 1 ，2 ，3 ，4 ，5 ，6 ，7 ，8 ，9 和 10 。总共有 10 个步进数字。所以输出为 10\n。\n示例 2：\n输入：low = \u0026ldquo;90\u0026rdquo;, high = \u0026ldquo;101\u0026rdquo;\n输出：2\n解释：区间 [90,101] 内的步进数字为 98 和 101 。总共有 2 个步进数字。所以输出为 2 。\n提示：\n1 \u0026lt;= int(low) \u0026lt;= int(high) \u0026lt; 10^100\n1 \u0026lt;= low.length, high.length \u0026lt;= 100\nlow 和 high 只包含数字。\nlow 和 high 都不含前导 0 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // @lc code=start class Solution { public: int countSteppingNumbers(string low, string high) { base = high; int preval = 0; f = vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;(base.size(),vector\u0026lt;int\u0026gt;(10,-1)); int bval = query(0,preval,true,false); base = low; f = vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;(base.size(),vector\u0026lt;int\u0026gt;(10,-1)); return (bval - query(0,preval,true,false) + valid(low)+MOD) % MOD ; } int valid(string \u0026amp;s) { for(int i=1;i\u0026lt;s.size();i++) { if( abs(int(s[i]) - int(s[i-1])) !=1) { return false; } } return true; } string base; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; f ; const int MOD = 1e9+7; int query(int i,int pre,bool limit,bool isnum) { if(base.size() == i) return isnum; if(!limit \u0026amp;\u0026amp; isnum \u0026amp;\u0026amp; f[i][pre]!=-1) return f[i][pre]; int res=0; if(not isnum) res = query(i+1,pre,false,false); // int minval = isnum? 0:1; int maxcurr = limit ? base[i]-\u0026#39;0\u0026#39;: 9; for (int j=1-isnum;j\u0026lt;=maxcurr;j++) { if (!isnum || abs(j - pre) == 1) { res = (res + query(i+1,j,limit \u0026amp;\u0026amp; j == maxcurr,true)) % MOD; } } if(!limit \u0026amp;\u0026amp; isnum) f[i][pre] = res; return res; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2801] 统计范围内的步进数字数目\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; return 0; } ","date":"2024-01-31T00:52:33Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E6%95%B0%E4%BD%8Ddp/lc.2801.%E7%BB%9F%E8%AE%A1%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E6%AD%A5%E8%BF%9B%E6%95%B0%E5%AD%97/","tags":["数位dp"],"title":"lc.2801.统计范围内的步进数字"},{"categories":["数位dp"],"contents":" leetcode 902.最大为 N的数字组合 algorithms\nHard (46.79%)\nLikes: 271\nDislikes: 0\nTotal Accepted: 29.8K\nTotal Submissions: 63.3K\nTestcase Example: \u0026lsquo;[\u0026ldquo;1\u0026rdquo;,\u0026ldquo;3\u0026rdquo;,\u0026ldquo;5\u0026rdquo;,\u0026ldquo;7\u0026rdquo;]\\n100\u0026rsquo;\n给定一个按 非递减顺序 排列的数字数组 digits 。你可以用任意次数 digits[i] 来写的数字。例如，如果 digits [\u0026lsquo;1\u0026rsquo;,\u0026lsquo;3\u0026rsquo;,\u0026lsquo;5\u0026rsquo;]，我们可以写数字，如 \u0026lsquo;13\u0026rsquo;, \u0026lsquo;551\u0026rsquo;, 和 \u0026lsquo;1351315\u0026rsquo;。\n返回 可以生成的小于或等于给定整数 n 的正整数的个数 。\n示例 1：\n输入：digits = [\u0026ldquo;1\u0026rdquo;,\u0026ldquo;3\u0026rdquo;,\u0026ldquo;5\u0026rdquo;,\u0026ldquo;7\u0026rdquo;], n = 100\n输出：20\n解释：\n可写出的 20 个数字是：\n1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75,\n77.\n示例 2：\n输入：digits = [\u0026ldquo;1\u0026rdquo;,\u0026ldquo;4\u0026rdquo;,\u0026ldquo;9\u0026rdquo;], n = 1000000000\n输出：29523\n解释：\n我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，\n81 个四位数字，243 个五位数字，729 个六位数字，\n2187 个七位数字，6561 个八位数字和 19683 个九位数字。\n总共，可以使用D中的数字写出 29523 个整数。\n示例 3:\n输入：digits = [\u0026ldquo;7\u0026rdquo;], n = 8\n输出：1\n提示：\n1 \u0026lt;= digits.length \u0026lt;= 9\ndigits[i].length == 1\ndigits[i] 是从 \u0026lsquo;1\u0026rsquo; 到 \u0026lsquo;9\u0026rsquo; 的数\ndigits 中的所有值都 不同\ndigits 按 非递减顺序 排列\n1 \u0026lt;= n \u0026lt;= 10^9\n递推式推导 $$\nf(i,islimit,isnum) =\n\\text{if}(!islimit \u0026amp;\u0026amp; isnum) { f(i+1,false,isnum)}\nf(i+1,islimit \u0026amp; curr==up ,isnum)\n$$ 查询子节点的总数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // @lc code=start class Solution { public: int atMostNGivenDigitSet(vector\u0026lt;string\u0026gt; \u0026amp;digits, int n) { maxnum = to_string(n); dp = vector\u0026lt;int\u0026gt;(maxnum.size(), -1); this-\u0026gt;digits = digits; //保证digits是有序的 return f(0, true, false); } string maxnum; vector\u0026lt;int\u0026gt; dp; vector\u0026lt;string\u0026gt; digits; int f(int i, bool islimit, bool isnum) { // f[i] = f[i+1] or i == m?1:0 if (i == maxnum.size()) { return isnum; } if (!islimit \u0026amp;\u0026amp; isnum \u0026amp;\u0026amp; dp[i] \u0026gt;= 0) return dp[i]; int cmax = islimit ? maxnum[i] : \u0026#39;9\u0026#39;; int res = 0; if (!isnum) res += f(i + 1, false /*位数比N短*/, isnum); for (auto \u0026amp;str : digits) { if (str[0] \u0026gt; cmax) break; // sort(digits) res += f(i + 1, cmax == str[0] \u0026amp;\u0026amp; islimit, true); } if (!islimit \u0026amp;\u0026amp; isnum) dp[i] = res; return res; } }; // @lc code=end int main() { # ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [902] 最大为 N 的数字组合\u0026#34; \u0026lt;\u0026lt; endl; # endif Solution k; return 0; } 参考 [[数位dp详解.md]]\n","date":"2024-01-31T00:01:51Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E6%95%B0%E4%BD%8Ddp/lc.902.%E6%9C%80%E5%A4%A7%E4%B8%BA-n-%E7%9A%84%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88/","tags":["数位dp"],"title":"lc.902.最大为-n-的数字组合"},{"categories":["树状数组优化"],"contents":" leetcode\n2376.统计特殊整数 algorithms\nHard (54.05%)\nLikes: 76\nDislikes: 0\nTotal Accepted: 11.1K\nTotal Submissions: 20K\nTestcase Example: \u0026lsquo;20\u0026rsquo;\n如果一个正整数每一个数位都是 互不相同 的，我们称它是 特殊整数 。\n给你一个 正 整数 n ，请你返回区间 [1, n] 之间特殊整数的数目。\n示例 1：\n输入：n = 20\n输出：19\n解释：1 到 20 之间所有整数除了 11 以外都是特殊整数。所以总共有 19 个特殊整数。\n示例 2：\n输入：n = 5\n输出：5\n解释：1 到 5 所有整数都是特殊整数。\n示例 3：\n输入：n = 135\n输出：110\n解释：从 1 到 135 总共有 110 个整数是特殊整数。\n不特殊的部分数字为：22 ，114 和 131 。\n提示：\n1 \u0026lt;= n \u0026lt;= 2 * 10^9\n数位DP原理 n = 1 2 3\nf(i,mask)\n[[..\\数位dp\\数位dp详解.md]]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // @lc code=start class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp; int m; string s; int f(int i, int mask, bool islimit, bool isnum) { if (i == m) { return isnum; } if(!islimit \u0026amp;\u0026amp; isnum \u0026amp;\u0026amp; dp[i][mask]\u0026gt;=0) { return dp[i][mask]; } int res=0; if(!isnum) { res = f(i+1,mask,false,false); } int up = islimit? s[i]-\u0026#39;0\u0026#39;: 9; for(int j=1-isnum;j\u0026lt;=up;j++) { if((mask \u0026gt;\u0026gt; j \u0026amp; 1 )==0) { res += f(i+1,mask|(1\u0026lt;\u0026lt;j),islimit \u0026amp;\u0026amp; j == up,true) ; } } if(!islimit \u0026amp;\u0026amp; isnum) dp[i][mask] = res; return res; } int countSpecialNumbers(int n) { s = to_string(n); m = s.size(); dp = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(m, vector\u0026lt;int\u0026gt;(1 \u0026lt;\u0026lt; 10,-1)); return f(0,0,true,false); } }; // @lc code=end int main() { # ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2376] 统计特殊整数\u0026#34; \u0026lt;\u0026lt; endl; # endif Solution k; return 0; } ","date":"2024-01-30T00:34:04Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E6%95%B0%E4%BD%8Ddp/lc.2376.%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E6%95%B4%E6%95%B0/","tags":["树状数组优化"],"title":"lc.2376.统计特殊整数"},{"categories":["数位dp"],"contents":"数位DP详解 参考例题 统计特殊整数 模板解说 设集合对应的二进制数为x。本题需要用到两个位运算操作\n判断元素d在集合中, x\u0026gt;\u0026gt;d \u0026amp; 1, 可以取出x的第d个比特位 把元素d添加到集合中： 将x更新为 x|(1\u0026lt;\u0026lt;d) 将n转化为 字符串 s,定义 f(i,mask,isLimit,isNum) 表示构造第 i 位的合法方案数\nmask 表示数字集合 011 表示 0 和 1 都用了 isLimit 表示 是否不能超过 n , 受到了最大限制 (构造的数字不能超过n) 例如: n=\u0026ldquo;123\u0026rdquo;, 则前面填入\u0026quot;12\u0026quot;,第3为不能超过 \u0026lsquo;3\u0026rsquo;, 只能在 1,2,3 里面选 isNum 表示 i前面的数位是否填了数字， 若没有填(isNum=false), 则当前位置也可以跳过,或者可以填入数字, isNum=true 则必须填入数字 作者：灵茶山艾府\n链接： https://leetcode.cn/problems/count-special-integers/solutions/1746956/shu-wei-dp-mo-ban-by-endlesscheng-xtgx/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int countSpecialNumbers(int n) { auto s = to_string(n); int m = s.length(), memo[m][1 \u0026lt;\u0026lt; 10]; memset(memo, -1, sizeof(memo)); // -1 表示没有计算过 function\u0026lt;int(int, int, bool, bool)\u0026gt; f = [\u0026amp;](int i, int mask, bool is_limit, bool is_num) -\u0026gt; int { if (i == m) return is_num; // is_num 为 true 表示得到了一个合法数字 if (!is_limit \u0026amp;\u0026amp; is_num \u0026amp;\u0026amp; memo[i][mask] != -1) return memo[i][mask]; int res = 0; if (!is_num) // 可以跳过当前数位 res += f(i + 1, mask, false, false); int up = is_limit ? s[i] - \u0026#39;0\u0026#39; : 9; // 如果前面填的数字都和 n 的一样，那么这一位至多填数字 s[i]（否则就超过 n 啦） for (int d = 1 - is_num; d \u0026lt;= up; ++d) // 枚举要填入的数字 d if ((mask \u0026gt;\u0026gt; d \u0026amp; 1) == 0) // d 不在 mask 中 // 相当于后续遍历 , sum(node) = sum(node-\u0026gt;left)+sum(node-\u0026gt;right) + node-\u0026gt;val, 统计当前节点有多少个子节点 res += f(i + 1, mask | (1 \u0026lt;\u0026lt; d), is_limit \u0026amp;\u0026amp; d == up, true); if (!is_limit \u0026amp;\u0026amp; is_num) //什么 !isLimit \u0026amp;\u0026amp; isNum 这两个条件的前提下才去使用和记录缓存？ memo[i][mask] = res; //因为只有满足这两个条件的才需要重复计算吧，如果受到n约束或者跳过数位的话只算一次就好了 return res; }; return f(0, 0, true, false); //一开始一定是受到 s 的影响的 } }; 详解 强化训练（数位 DP） 数字 1 的个数（题解） 面试题 17.06. 2出现的次数（题解） 不含连续1的非负整数（题解） 最大为 N 的数字组合 范围内的数字计数 找到所有好字符串（有难度，需要结合一个经典字符串算法） 例题 [[lc.2376.统计特殊整数.md]]\n[[lc.902.最大为-n-的数字组合.md]]\n","date":"2024-01-30T00:09:05Z","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E6%95%B0%E4%BD%8Ddp/%E6%95%B0%E4%BD%8Ddp%E8%AF%A6%E8%A7%A3/","tags":["数位dp"],"title":"数位dp详解"},{"categories":["双指针"],"contents":" leetcode 2799.统计完全子数组的数目 algorithms\nMedium (58.21%)\nLikes: 28\nDislikes: 0\nTotal Accepted: 7.4K\nTotal Submissions: 12.7K\nTestcase Example: \u0026lsquo;[1,3,1,2,2]\u0026rsquo;\n给你一个由 正 整数组成的数组 nums 。\n如果数组中的某个子数组满足下述条件，则称之为 完全子数组 ：\n子数组中 不同 元素的数目等于整个数组不同元素的数目。\n返回数组中 完全子数组 的数目。\n子数组 是数组中的一个连续非空序列。\n示例 1：\n输入：nums = [1,3,1,2,2]\n输出：4\n解释：完全子数组有：[1,3,1,2]、[1,3,1,2,2]、[3,1,2] 和 [3,1,2,2] 。\n示例 2：\n输入：nums = [5,5,5,5]\n输出：10\n解释：数组仅由整数 5 组成，所以任意子数组都满足完全子数组的条件。子数组的总数为 10 。\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 1000\n1 \u0026lt;= nums[i] \u0026lt;= 2000\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // @lc code=start class Solution { public: int countCompleteSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int m=unordered_set\u0026lt;int\u0026gt;(nums.begin(),nums.end()).size() ; unordered_map\u0026lt;int,int\u0026gt; mp; int ans=0,left=0; for(int v: nums) { mp[v]++; while(mp.size() == m) { int j = nums[left]; left++; mp[j]--; if(mp[j] == 0) { mp.erase(j); } } ans += left; } return ans; } /** int n = nums.size(); unordered_set\u0026lt;int\u0026gt; f; for(int u:nums)f.insert(u); int m= f.size(); int r=0; for(int i=0;i\u0026lt;n;i++) { unordered_set\u0026lt;int\u0026gt; se; for(int j=i;j\u0026lt;n;j++) { se.insert(nums[j]); if (se.size() == m ){ r++; } } } */ }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2799] 统计完全子数组的数目\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; return 0; } ","date":"2024-01-28T22:24:59+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/lc.2799.%E7%BB%9F%E8%AE%A1%E5%AE%8C%E5%85%A8%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/","tags":["双指针"],"title":"lc.2799.统计完全子数组数目"},{"categories":["树状数组优化"],"contents":" leetcode 2830.销售利润最大化 algorithms\nMedium (42.39%)\nLikes: 46\nDislikes: 0\nTotal Accepted: 5.9K\nTotal Submissions: 13.8K\nTestcase Example: \u0026lsquo;5\\n[[0,0,1],[0,2,2],[1,3,2]]\u0026rsquo;\n给你一个整数 n 表示数轴上的房屋数量，编号从 0 到 n - 1 。\n另给你一个二维整数数组 offers ，其中 offers[i] = [starti, endi, goldi] 表示第 i 个买家想要以 goldi\n枚金币的价格购买从 starti 到 endi 的所有房屋。\n作为一名销售，你需要有策略地选择并销售房屋使自己的收入最大化。\n返回你可以赚取的金币的最大数目。\n注意 同一所房屋不能卖给不同的买家，并且允许保留一些房屋不进行出售。\n示例 1：\n输入：n = 5, offers = [[0,0,1],[0,2,2],[1,3,2]]\n输出：3\n解释：\n有 5 所房屋，编号从 0 到 4 ，共有 3 个购买要约。\n将位于 [0,0] 范围内的房屋以 1 金币的价格出售给第 1 位买家，并将位于 [1,3] 范围内的房屋以 2 金币的价格出售给第 3 位买家。\n可以证明我们最多只能获得 3 枚金币。\n示例 2：\n输入：n = 5, offers = [[0,0,1],[0,2,10],[1,3,2]]\n输出：10\n解释：有 5 所房屋，编号从 0 到 4 ，共有 3 个购买要约。\n将位于 [0,2] 范围内的房屋以 10 金币的价格出售给第 2 位买家。\n可以证明我们最多只能获得 10 枚金币。\n提示：\n1 \u0026lt;= n \u0026lt;= 10^5\n1 \u0026lt;= offers.length \u0026lt;= 10^5\noffers[i].length == 3\n0 \u0026lt;= starti \u0026lt;= endi \u0026lt;= n - 1\n1 \u0026lt;= goldi \u0026lt;= 10^3\n动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // @lc code=start class Solution { public: int maximizeTheProfit(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; offers) { unordered_map\u0026lt;int, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;\u0026gt; grp(n) ; for (auto \u0026amp;vec: offers) { grp[vec[1]].push_back(vec); } vector\u0026lt;int\u0026gt; dp(n+1); for (int end=0;end\u0026lt;n;end++) { dp[end+1] = dp[end]; for(auto \u0026amp;vec: grp[end]) { int gold = vec[2],l = vec[0]; dp[end+1] = max(dp[end+1], dp[l] + gold); } } return dp[n]; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2830] 销售利润最大化\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; return 0; } 树状数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: int maximizeTheProfit(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; offers) { sort(offers.begin(),offers.end()); N = n+5; a = vector\u0026lt;int\u0026gt;(N,0); int res=0; for(auto \u0026amp;ve: offers) { int l = ve[0]+1, r=ve[1]+1,g = ve[2]; int cur = query(l-1)+g; res = max(res,cur); update(r,cur); } return res; } vector\u0026lt;int\u0026gt; a; int N; int lowbit(int f) { return f \u0026amp; -f; } void update(int idx, int values) { // dp[idx] = max(dp[idx],values) for(;idx\u0026lt;N;idx+= lowbit(idx)) { a[idx] = max(a[idx],values); } } int query(int r) { // max{a[k] | 1\u0026lt;=k\u0026lt;=r } int res=0; for(;r\u0026gt;0; r -= lowbit(r)) { res = max(res,a[r]); } return res; } }; 其他 [[....\\数据结构\\树状数组\\树状数组基础.md]]\n[[..\\树状数组优化\\lc.2926.平衡子序列的最大和.md]]\n","date":"2024-01-28T21:38:40+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96/lc.2830.%E9%94%80%E5%94%AE%E5%88%A9%E6%B6%A6%E6%9C%80%E5%A4%A7%E5%8C%96/","tags":["树状数组优化"],"title":"lc.2830.销售利润最大化"},{"categories":["树状数组优化"],"contents":" leetcode 2008.出租车的最大盈利 algorithms\nMedium (56.53%)\nLikes: 171\nDislikes: 0\nTotal Accepted: 23.4K\nTotal Submissions: 41.5K\nTestcase Example: \u0026lsquo;5\\n[[2,5,4],[1,5,1]]\u0026rsquo;\n你驾驶出租车行驶在一条有 n 个地点的路上。这 n 个地点从近到远编号为 1 到 n ，你想要从 1 开到 n\n，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。\n乘客信息用一个下标从 0 开始的二维数组 rides 表示，其中 rides[i] = [starti, endi, tipi] 表示第 i\n位乘客需要从地点 starti 前往 endi ，愿意支付 tipi 元的小费。\n每一位 你选择接单的乘客 i ，你可以 盈利 endi - starti + tipi 元。你同时 最多 只能接一个订单。\n给你 n 和 rides ，请你返回在最优接单方案下，你能盈利 最多 多少元。\n注意：你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。\n示例 1：\n输入：n = 5, rides = [[2,5,4],[1,5,1]]\n输出：7\n解释：我们可以接乘客 0 的订单，获得 5 - 2 + 4 = 7 元。\n示例 2：\n输入：n = 20, rides =\n[[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]]\n输出：20\n解释：我们可以接以下乘客的订单：\n将乘客 1 从地点 3 送往地点 10 ，获得 10 - 3 + 2 = 9 元。 将乘客 2 从地点 10 送往地点 12 ，获得 12 - 10 + 3 = 5 元。 将乘客 5 从地点 13 送往地点 18 ，获得 18 - 13 + 1 = 6 元。\n我们总共获得 9 + 5 + 6 = 20 元。 提示：\n1 \u0026lt;= n \u0026lt;= 10^5\n1 \u0026lt;= rides.length \u0026lt;= 3 * 10^4\nrides[i].length == 3\n1 \u0026lt;= starti \u0026lt; endi \u0026lt;= n\n1 \u0026lt;= tipi \u0026lt;= 10^5\n动态规划解题思路 $$\n\\begin{align}\ndp[i] = max(dp[i-1],dp[offer[0]] + offer[2])\n\\end{align}\n$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // @lc code=start class Solution { public: #define ll long long long long maxTaxiEarnings(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; rides) { N = n+6; a = vector\u0026lt;ll\u0026gt;(N,0); sort(rides.begin(),rides.end()); ll res=0; for(auto \u0026amp;ve:rides){ int l=ve[0],r = ve[1],tip = ve[2]; ll getx = query(l) + r-l + tip; res = max(res,getx); update(r, getx); } return res; } vector\u0026lt;ll\u0026gt; a; int N; int lowbit(int f) { return f \u0026amp; -f; } ll query(int idx) { // query(r) = Max { a[k] , 1\u0026lt;=k \u0026lt;=idx }, a[k] = range(0,k) ll res=0; for(;idx; idx-=lowbit(idx)) { res = max(res,a[idx]); } return res; } void update(int idx,ll value) { // a[idx] = max(a[idx],value) for(;idx\u0026lt;N;idx+=lowbit(idx)) { a[idx] = max(a[idx],value); } } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2008] 出租车的最大盈利\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; return 0; } 离散化减低内存消耗 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Solution { public: #define ll long long void unique(unordered_map\u0026lt;int,int\u0026gt;\u0026amp;mp ,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; rides) { set\u0026lt;int\u0026gt; se; for(auto \u0026amp;ve: rides) { se.insert(ve[0]); se.insert(ve[1]); } int idx=1; for(int w:se) { mp[w] = idx++; } } long long maxTaxiEarnings(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; rides) { sort(rides.begin(),rides.end()); unordered_map\u0026lt;int,int\u0026gt; idxx ; unique(idxx,rides); N = idxx.size()+6; a = vector\u0026lt;ll\u0026gt;(N,0); ll res=0; for(auto \u0026amp;ve:rides){ int l = ve[0],r = ve[1], w = r-l+ve[2]; l=idxx[ve[0]],r = idxx[ve[1]]; ll getx = query(l) + w; res = max(res,getx); update(r, getx); } return res; } vector\u0026lt;ll\u0026gt; a; int N; int lowbit(int f) { return f \u0026amp; -f; } ll query(int idx) { // query(r) = Max { a[k] , 1\u0026lt;=k \u0026lt;=idx }, a[k] = range(0,k) ll res=0; for(;idx; idx-=lowbit(idx)) { res = max(res,a[idx]); } return res; } void update(int idx,ll value) { // a[idx] = max(a[idx],value) for(;idx\u0026lt;N;idx+=lowbit(idx)) { a[idx] = max(a[idx],value); } } }; ","date":"2024-01-28T21:38:31+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96/lc.2008.%E5%87%BA%E7%A7%9F%E8%BD%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9B%88%E5%88%A9/","tags":["树状数组优化"],"title":"lc.2008.出租车的最大盈利"},{"categories":["数列"],"contents":" leetcode 2829.k-avoiding\n数组的最小总和 algorithms\nMedium (59.58%)\nLikes: 16\nDislikes: 0\nTotal Accepted: 6.7K\nTotal Submissions: 11.4K\nTestcase Example: \u0026lsquo;5\\n4\u0026rsquo;\n给你两个整数 n 和 k 。\n对于一个由 不同 正整数组成的数组，如果其中不存在任何求和等于 k\n的不同元素对，则称其为 k-avoiding 数组。\n返回长度为 n 的 k-avoiding 数组的可能的最小总和。\n示例 1：\n输入：n = 5, k = 4\n输出：18\n解释：设若 k-avoiding 数组为 [1,2,4,5,6] ，其元素总和为 18 。\n可以证明不存在总和小于 18 的 k-avoiding 数组。\n示例 2：\n输入：n = 2, k = 6\n输出：3\n解释：可以构造数组 [1,2] ，其元素总和为 3 。\n可以证明不存在总和小于 3 的 k-avoiding 数组。\n提示：\n1 \u0026lt;= n, k \u0026lt;= 50\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // @lc code=start class Solution { public: int minimumSum(int n, int k) { unordered_set\u0026lt;int\u0026gt; mp; int res=0; for (int j=1;n;j++) { int r = k-j; if(!mp.count(r)) { n--; res += j; mp.insert(j); } } return res; } }; // @lc code=end int main() { # ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2829] k-avoiding 数组的最小总和\u0026#34; \u0026lt;\u0026lt; endl; # endif Solution k; return 0; } 等差数列求和 $$\n\\begin{align}\nm = min(k/2,n)\n\\%\nl = \\sum_{n=1}^{m} a_{n}\n\\%\nr = \\sum_{n=k}^{k+n-m-1} a_{n}\n\\%\n\\text{ total = l+r}\n\\%\n\\end{align}\n% 先求和 1~(k/2) 的数\n% 在对 (k ~n) 范围的数求和\n%\n$$\n1 2 3 4 5 6 7 8 9 10 class Solution { public: int minimumSum(int n, int k) { // n*(a1+an)/2 int ln = min(k/2,n); int l = ln * (1+ln)/2; int r = (k + (k+n-ln-1)) *(n-ln) /2; return l+r; } }; ","date":"2024-01-28T14:57:30+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%88%97/lc.2829.k-avoiding-%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E6%80%BB%E5%92%8C/","tags":["数列"],"title":"lc.2829.k-avoiding-数组最小总和"},{"categories":["数学"],"contents":"数学markdown常用公式 参考链接 矩阵 $$\n\\begin{matrix}\n1 \u0026amp; 2 \u0026amp; 3 \\\na \u0026amp; b \u0026amp; c \\\n\\end{matrix}\n$$\n$$\n\\begin{pmatrix}\n1 \u0026amp; 2 \u0026amp; 3 \\\na \u0026amp; b \u0026amp; c \\\n\\end{pmatrix}\n$$\n$$\n\\begin{bmatrix}\n1 \u0026amp; 2 \u0026amp; 3 \\\na \u0026amp; b \u0026amp; c \\\n\\end{bmatrix}\n$$\n公式 $$\nd(i)=\n\\begin{cases}\nd[i-1]+1 \u0026amp; \\text{if } \\ a[i]\u0026gt;=a[i-1]\\\n1 \u0026amp; \\text{if } \\ a[i]\u0026lt;a[i-1]\\\n\\end{cases}\n$$\n分数 $$\n\\frac{x}{y} \\\n\\\n$$\n$$\\frac{x}{y+\\frac{1}{2}}$$\n公式符号 $$\n\\sum_{n=1}^{\\infty} 2^{-n} = 1\n$$\n$$\nf(x) \\ = \\sum_{n=1}^{m} 2^{x}\n$$\n$$\n\\sum_{n=1}^{\\infty} 2^{n}\n$$\n$$\n\\lim_{x\\to\\infty} f(x) /\n\\triangle x\n\\\n\\lvert x \\rvert\n\\\nK(\\lambda)\n$$\nmarkdown间距控制 $$\n\\frac{x}{y}\n$$\noverleaf latex语法参考 https://www.overleaf.com/project/65b600cfed43216b4cffbcac ","date":"2024-01-22T00:05:17+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6markdown%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F/","tags":["数学"],"title":"数学markdown常用公式\u0026 latx"},{"categories":["序列问题"],"contents":" leetcode 2420.找到所有好下标 algorithms\nMedium (32.46%)\nLikes: 45\nDislikes: 0\nTotal Accepted: 8.8K\nTotal Submissions: 27K\nTestcase Example: \u0026lsquo;[2,1,1,1,3,4,1]\\n2\u0026rsquo;\n给你一个大小为 n 下标从 0 开始的整数数组 nums 和一个正整数 k 。\n对于 k \u0026lt;= i \u0026lt; n - k 之间的一个下标 i ，如果它满足以下条件，我们就称它为一个 好 下标：\n下标 i 之前 的 k 个元素是 非递增的 。\n下标 i 之后 的 k 个元素是 非递减的 。\n按 升序 返回所有好下标。\n示例 1：\n输入：nums = [2,1,1,1,3,4,1], k = 2\n输出：[2,3]\n解释：数组中有两个好下标：\n下标 2 。子数组 [2,1] 是非递增的，子数组 [1,3] 是非递减的。 下标 3 。子数组 [1,1] 是非递增的，子数组 [3,4] 是非递减的。\n注意，下标 4 不是好下标，因为 [4,1] 不是非递减的。 示例 2：\n输入：nums = [2,1,1,2], k = 2\n输出：[]\n解释：数组中没有好下标。\n提示：\nn == nums.length\n3 \u0026lt;= n \u0026lt;= 10^5\n1 \u0026lt;= nums[i] \u0026lt;= 10^6\n1 \u0026lt;= k \u0026lt;= n / 2\n解题方法1. 动态规划 通过\n$$\nd(i)=\n\\begin{cases}\nd[i-1]+1 \u0026amp; if \\ a[i]\u0026gt;=a[i-1]\\\n1 \u0026amp; if \\ a[i]\u0026lt;a[i-1]\\\n\\end{cases}\n$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // @lc code=start class Solution { public: vector\u0026lt;int\u0026gt; goodIndices(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); vector\u0026lt;int\u0026gt; dec(n,1) ; vector\u0026lt;int\u0026gt; asc(n,1) ; vector\u0026lt;int\u0026gt; res; for (int i=n-2;i\u0026gt;=0;i--) if(nums[i] \u0026lt;= nums[i+1]) dec[i] = dec[i+1] + 1; for(int i=1;i\u0026lt;n;i++) if(nums[i] \u0026lt;= nums[i-1]) asc[i] = asc[i-1]+1; for(int i=1;i\u0026lt;n-k;i++) { if(asc[i-1]\u0026gt;=k \u0026amp;\u0026amp; dec[i+1]\u0026gt;=k) { res.push_back(i); } } return res; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2420] 找到所有好下标\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; vector\u0026lt;int\u0026gt; nums{2,1,1,1,3,4,1} ; println(k.goodIndices(nums,2)); return 0; } 解法2- 单调栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: vector\u0026lt;int\u0026gt; goodIndices(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { stack\u0026lt;int\u0026gt; stk1, stk2; int n = nums.size(); vector\u0026lt;int\u0026gt; dp(n, 0); //从左到右统计，当前位置左侧是否存在满足条件的序列 for (int i = 0; i \u0026lt; nums.size(); ++i) { if (stk1.size() \u0026gt;= k) dp[i] += 1; if (!stk1.empty() \u0026amp;\u0026amp; nums[stk1.top()] \u0026lt; nums[i]) while (!stk1.empty()) stk1.pop(); stk1.push(i); } //从右到左统计，当前位置左侧是否存在满足条件的序列 for (int j = nums.size() - 1; j \u0026gt;= 0; --j) { if (stk2.size() \u0026gt;= k) dp[j] += 1; if (!stk2.empty() \u0026amp;\u0026amp; nums[stk2.top()] \u0026lt; nums[j]) while (!stk2.empty()) stk2.pop(); stk2.push(j); } //左侧右侧都存在的话 此时的计数为2 vector\u0026lt;int\u0026gt; ans; for (int i = 0; i \u0026lt; nums.size(); ++i) if (dp[i] == 2) ans.push_back(i); return ans; } }; ","date":"2024-01-21T22:52:09+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/lc.2420.%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E5%A5%BD%E4%B8%8B%E6%A0%87/","tags":["序列问题"],"title":"lc.2420.找到所有好下标"},{"categories":["差分"],"contents":" leetcode\n2848.与车相交的点 algorithms\nEasy (73.93%)\nLikes: 14\nDislikes: 0\nTotal Accepted: 8K\nTotal Submissions: 10.8K\nTestcase Example: \u0026lsquo;[[3,6],[1,5],[4,7]]\u0026rsquo;\n给你一个下标从 0 开始的二维整数数组 nums\n表示汽车停放在数轴上的坐标。对于任意下标 i，nums[i] = [starti, endi] ，其中\nstarti 是第 i 辆车的起点，endi 是第 i 辆车的终点。\n返回数轴上被车 任意部分 覆盖的整数点的数目。\n示例 1：\n输入：nums = [[3,6],[1,5],[4,7]]\n输出：7\n解释：从 1 到 7 的所有点都至少与一辆车相交，因此答案为 7 。\n示例 2：\n输入：nums = [[1,3],[5,8]]\n输出：7\n解释：1、2、3、5、6、7、8 共计 7 个点满足至少与一辆车相交，因此答案为 7 。\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 100\nnums[i].length == 2\n1 \u0026lt;= starti \u0026lt;= endi \u0026lt;= 100\n排序解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // @lc code=start class Solution { public: int numberOfPoints(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;nums) { int n = nums.size(); if (!n) return 0; sort(nums.begin(), nums.end(), [\u0026amp;](vector\u0026lt;int\u0026gt; \u0026amp;a, vector\u0026lt;int\u0026gt; \u0026amp;b) { if (a[0] == b[0]) return a[1] \u0026lt; b[1]; return a[0] \u0026lt; b[0]; }); int total = 0; for (int i=0;i\u0026lt;n;i++) { int l = nums[i][0], r = nums[i][1]; while(i \u0026lt; n-1 \u0026amp;\u0026amp; r \u0026gt;= nums[i+1][0]) { r = max(r,nums[i+1][1]); i++; } total += r - l +1; } return total; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2848] 与车相交的点\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; nums{{4, 4}, {9, 10}, {9, 10}, {3, 8}}; println(k.numberOfPoints(nums)); return 0; } 差分解法 [[..\\解题技巧\\差分数组.md]]\n通过 o(1) 的时间 对区间端点进行操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int numberOfPoints(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;nums) { int n = nums.size(); if (!n) return 0; n=0; for(auto \u0026amp;ve: nums) n = max(ve[0],max(ve[1],n)) ; vector\u0026lt;int\u0026gt; d(n+2) ; for(auto \u0026amp;ve: nums) { int l=ve[0],r = ve[1]; d[l]+=1; d[r+1]-=1; } int total =0; int sum=0; for(int i=0;i\u0026lt;n+2;i++) { sum += d[i]; if(sum) total++; } return total; } }; ","date":"2024-01-21T21:54:29+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E5%B7%AE%E5%88%86/lc.2848.%E4%B8%8E%E8%BD%A6%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%82%B9/","tags":["差分"],"title":"lc.2848.与车相交的点"},{"categories":["堆"],"contents":" leetcode\n2500.删除每行中的最大值 algorithms\nEasy (83.75%)\nLikes: 59\nDislikes: 0\nTotal Accepted: 32.9K\nTotal Submissions: 39.3K\nTestcase Example: \u0026lsquo;[[1,2,4],[3,3,1]]\u0026rsquo;\n给你一个 m x n 大小的矩阵 grid ，由若干正整数组成。\n执行下述操作，直到 grid 变为空矩阵：\n从每一行删除值最大的元素。如果存在多个这样的值，删除其中任何一个。\n将删除元素中的最大值与答案相加。\n注意 每执行一次操作，矩阵中列的数据就会减 1 。\n返回执行上述操作后的答案。\n示例 1：\n输入：grid = [[1,2,4],[3,3,1]]\n输出：8\n解释：上图展示在每一步中需要移除的值。\n在第一步操作中，从第一行删除 4 ，从第二行删除 3（注意，有两个单元格中的值为 3\n，我们可以删除任一）。在答案上加 4 。 在第二步操作中，从第一行删除 2 ，从第二行删除 3 。在答案上加 3 。 在第三步操作中，从第一行删除 1 ，从第二行删除 1 。在答案上加 1 。\n最终，答案 = 4 + 3 + 1 = 8 。 示例 2：\n输入：grid = [[10]]\n输出：10\n解释：上图展示在每一步中需要移除的值。\n在第一步操作中，从第一行删除 10 。在答案上加 10 。\n最终，答案 = 10 。 提示：\nm == grid.length\nn == grid[i].length\n1 \u0026lt;= m, n \u0026lt;= 50\n1 \u0026lt;= grid[i][j] \u0026lt;= 100\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // @lc code=start class Solution { public: int deleteGreatestValue(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid) { int n = grid.size(); for (int i = 0; i \u0026lt; n; i++) sort(grid[i].begin(), grid[i].end()); if(!n) return 0; int m = grid[0].size(); int total=0; while(m--\u0026gt;0) { int maxval=0; for (int i=0;i\u0026lt;n;i++) { if(grid[i][m] \u0026gt;maxval) maxval = grid[i][m]; } total+= maxval; } return total; } int deleteGreatestValueV0(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid) { int n = grid.size(); if (!n) return 0; int m = grid[0].size(); vector\u0026lt;multiset\u0026lt;int\u0026gt;\u0026gt; s(n); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { s[i].insert(grid[i][j]); } } int all = n * m; int total = 0; while (true) { int maxval = 0; for (int i = 0; i \u0026lt; n; i++) { if (!s[i].size()) { break; } auto maxvalue = prev(s[i].end()); int val = *maxvalue; s[i].erase(maxvalue); if (val \u0026gt; maxval) maxval = val; } total += maxval; if (s[0].size() == 0) break; } return total; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2500] 删除每行中的最大值\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; grid{{1, 2, 4}, {3, 3, 1}}; println(k.deleteGreatestValue(grid)); return 0; } ","date":"2024-01-21T19:03:32+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/lc.2500.%E5%88%A0%E9%99%A4%E6%AF%8F%E8%A1%8C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","tags":["堆"],"title":"lc.2500.删除每行的最大值"},{"categories":["序列问题"],"contents":" leetcode\n1673.找出最具竞争力的子序列 algorithms\nMedium (40.47%)\nLikes: 114\nDislikes: 0\nTotal Accepted: 12.9K\nTotal Submissions: 31.8K\nTestcase Example: \u0026lsquo;[3,5,2,6]\\n2\u0026rsquo;\n给你一个整数数组 nums 和一个正整数 k ，返回长度为 k 且最具 竞争力 的 nums\n子序列。\n数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。\n在子序列 a 和子序列 b 第一个不相同的位置上，如果 a 中的数字小于 b\n中对应的数字，那么我们称子序列 a 比子序列 b（相同长度下）更具 竞争力 。\n例如，[1,3,4] 比 [1,3,5]\n更具竞争力，在第一个不相同的位置，也就是最后一个位置上， 4 小于 5 。\n示例 1：\n输入：nums = [3,5,2,6], k = 2\n输出：[2,6]\n解释：在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]}\n中，[2,6] 最具竞争力。\n示例 2：\n输入：nums = [2,4,3,3,5,4,9,6], k = 4\n输出：[2,3,3,4]\n提示：\n1\n0\n1\n解题思路 这个题用的是字典序\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // @lc code=start class Solution { public: vector\u0026lt;int\u0026gt; mostCompetitive(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { int n = nums.size(); vector\u0026lt;int\u0026gt; seq(k); int idx = -1; for (int i = 0; i \u0026lt; n; i++) { while (idx \u0026gt;= 0 \u0026amp;\u0026amp; seq[idx] \u0026gt; nums[i] \u0026amp;\u0026amp; i \u0026lt; (n - (k - (idx + 1)))) --idx; if (idx + 1 \u0026lt; k) seq[++idx] = nums[i]; } return seq; } }; // @lc code=end int main() { # ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [1673] 找出最具竞争力的子序列\u0026#34; \u0026lt;\u0026lt; endl; # endif Solution k; vector\u0026lt;int\u0026gt; nums{2, 4, 3, 3, 5, 4, 9, 6}; int n = 4; println(k.mostCompetitive(nums, n)); return 0; } ","date":"2024-01-21T18:07:50+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/lc.1673.%E6%89%BE%E5%87%BA%E6%9C%80%E5%85%B7%E7%AB%9E%E4%BA%89%E5%8A%9B%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/","tags":["序列问题"],"title":"lc.1673.找出最具竞争力的子序列"},{"categories":["质因数"],"contents":"质数因数总结 题目 类型 质数筛选法 欧拉筛法 质数分解 魔法数字:\n对于一个十进制下的整数\nx（不含前导零），如果他所有的长度大于\n1\n1的子串所形成的数字都不是素数，那么我们认为它是一个有魔法的数字。例如数字\n123\n123的所有长度大于 1\n1的子串为：\n[12,23,123]，由于其中\n23是素数，故\n123不是魔法数字；数字\n124的所有长度大于\n1的子串为：\n[12,24,124]，均不为素数，故数字 124是魔法数字。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int res; vector\u0026lt;bool\u0026gt; flag; bool ismagic(int k) { if(k==0) return true; // if(k\u0026lt;=2) return k==2; auto p = to_string(k); int n = p.size(); for(int i=0;i\u0026lt;n;i++) { int num=0; for(int j=i;j\u0026lt;n;j++) { num = num*10 + (p[j]-\u0026#39;0\u0026#39;); if(j\u0026gt;i \u0026amp;\u0026amp; !flag[num]) //长度大于1 return false; } } return true; } int main() { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); // auto N = ((int)sqrt(n)) +1; flag.resize(n+1,false); // flag[0] = false; //01 不是质数 flag[1] = true; for(int i=2;i\u0026lt;=n;i++) { if(!flag[i]) { for(int j=2;j*i\u0026lt;=n;j++) { flag[j*i] = true; } } } for(int i=1;i\u0026lt;=n;i++) { // solve(i); if(ismagic(i)) res++; } printf(\u0026#34;%d\\n\u0026#34;,res); return 0; } ","date":"2024-01-21T15:29:48+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/%E8%B4%A8%E5%9B%A0%E6%95%B0/%E8%B4%A8%E6%95%B0%E5%9B%A0%E6%95%B0%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/","tags":["质因数"],"title":"质数因数题目总结"},{"categories":["平衡树"],"contents":" leetcode 2817.限制条件下元素之间的最小绝对差 algorithms\nMedium (31.73%)\nLikes: 25\nDislikes: 0\nTotal Accepted: 5.1K\nTotal Submissions: 16K\nTestcase Example: \u0026lsquo;[4,3,2,4]\\n2\u0026rsquo;\n给你一个下标从 0 开始的整数数组 nums 和一个整数 x 。\n请你找到数组中下标距离至少为 x 的两个元素的 差值绝对值 的 最小值 。\n换言之，请你找到两个下标 i 和 j ，满足 abs(i - j) \u0026gt;= x 且 abs(nums[i] - nums[j]) 的值最小。\n请你返回一个整数，表示下标距离至少为 x 的两个元素之间的差值绝对值的 最小值 。\n示例 1：\n输入：nums = [4,3,2,4], x = 2\n输出：0\n解释：我们选择 nums[0] = 4 和 nums[3] = 4 。\n它们下标距离满足至少为 2 ，差值绝对值为最小值 0 。\n0 是最优解。\n示例 2：\n输入：nums = [5,3,2,10,15], x = 1\n输出：1\n解释：我们选择 nums[1] = 3 和 nums[2] = 2 。\n它们下标距离满足至少为 1 ，差值绝对值为最小值 1 。\n1 是最优解。\n示例 3：\n输入：nums = [1,2,3,4], x = 3\n输出：3\n解释：我们选择 nums[0] = 1 和 nums[3] = 4 。\n它们下标距离满足至少为 3 ，差值绝对值为最小值 3 。\n3 是最优解。\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5\n1 \u0026lt;= nums[i] \u0026lt;= 10^9\n0 \u0026lt;= x \u0026lt; nums.length\n解题示意图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int minAbsoluteDifference(vector\u0026lt;int\u0026gt;\u0026amp; nums, int x) { int ans = INT_MAX, n = nums.size(); set\u0026lt;int\u0026gt; s {}; for (int i=x;i\u0026lt;n;i++) { s.insert(nums[i-x]); auto it = s.lower_bound(nums[i]); if (it != s.end()) { ans = min(ans,abs(nums[i]- *it)); } if(it != s.begin()) { int prev = *(--it); ans = min(ans,abs(prev - nums[i])); } } return ans; } }; 变题 这里是 \u0026gt;=x 的距离，如果改为 i-j \u0026lt;=x ，那么 如何处理\n这时候就要 把 前面过期的数据移除掉 ， 用 multiset 来实现\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回 滑动窗口中的最大值 。\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n输出：[3,3,5,5,6,7]\n参考： https://leetcode.cn/problems/sliding-window-maximum/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: vector\u0026lt;int\u0026gt; maxSlidingWindow(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { multiset\u0026lt;int\u0026gt; s{}; int n = nums.size(); for (int i=0;i\u0026lt;k \u0026amp;\u0026amp; i\u0026lt;n;i++) s.insert(nums[i]); vector\u0026lt;int\u0026gt; res{}; res.push_back(*prev(s.end())); for (int i=k;i\u0026lt;n;i++) { // cout \u0026lt;\u0026lt;\u0026#34;- \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt;endl; if(i\u0026gt;=k) s.erase(s.find(nums[i-k])); s.insert(nums[i]); if(s.size()) { auto maxi = prev(s.end() ); res.push_back(*maxi); } } return res; } }; ","date":"2024-01-21T14:54:10+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E6%A0%91/lc.2817.%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E4%B8%8B%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/","tags":["平衡树"],"title":"lc.2817.限制条件下元素之间的最小绝对差"},{"categories":["链表"],"contents":" leetcode 2816.翻倍以链表形式表示的数字 algorithms\nMedium (57.46%)\nLikes: 19\nDislikes: 0\nTotal Accepted: 7.3K\nTotal Submissions: 12.6K\nTestcase Example: \u0026lsquo;[1,8,9]\u0026rsquo;\n给你一个 非空 链表的头节点 head ，表示一个不含前导零的非负数整数。\n将链表 翻倍 后，返回头节点 head 。\n示例 1：\n输入：head = [1,8,9]\n输出：[3,7,8]\n解释：上图中给出的链表，表示数字 189 。返回的链表表示数字 189 * 2 = 378 。\n示例 2：\n输入：head = [9,9,9]\n输出：[1,9,9,8]\n解释：上图中给出的链表，表示数字 999 。返回的链表表示数字 999 * 2 = 1998 。\n提示：\n链表中节点的数目在范围 [1, 10^4] 内\n0 \u0026lt;= Node.val \u0026lt;= 9\n生成的输入满足：链表表示一个不含前导零的数字，除了数字 0 本身。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // @lc code=start /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* doubleIt(ListNode* head) { if(head==NULL) return NULL; if(head-\u0026gt;val \u0026gt;= 5) { head = new ListNode(0,head); } ListNode *p = head; while(p) { p-\u0026gt;val = p-\u0026gt;val *2 %10; if(p-\u0026gt;next \u0026amp;\u0026amp; p-\u0026gt;next-\u0026gt;val \u0026gt;= 5) { p-\u0026gt;val ++; } p=p-\u0026gt;next; } return head; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2816] 翻倍以链表形式表示的数字\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; auto p=k.doubleIt(makeLinkedList(vector\u0026lt;int\u0026gt;{1,8,9} )); print(p); return 0; } ","date":"2024-01-21T14:30:28+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.2816.%E7%BF%BB%E5%80%8D%E4%BB%A5%E9%93%BE%E8%A1%A8%E5%BD%A2%E5%BC%8F%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%95%B0%E5%AD%97/","tags":["链表"],"title":"lc.2816.翻倍以链表形式表示的数字"},{"categories":["贡献"],"contents":" leetcode 2815.数组中的最大数对和 algorithms\nEasy (68.16%)\nLikes: 14\nDislikes: 0\nTotal Accepted: 8K\nTotal Submissions: 11.8K\nTestcase Example: \u0026lsquo;[51,71,17,24,42]\u0026rsquo;\n给你一个下标从 0 开始的整数数组 nums 。请你从 nums 中找出和 最大 的一对数，且这两个数数位上最大的数字相等。\n返回最大和，如果不存在满足题意的数字对，返回 -1 。\n示例 1：\n输入：nums = [51,71,17,24,42]\n输出：88\n解释：\ni = 1 和 j = 2 ，nums[i] 和 nums[j] 数位上最大的数字相等，且这一对的总和 71 + 17 = 88 。\ni = 3 和 j = 4 ，nums[i] 和 nums[j] 数位上最大的数字相等，且这一对的总和 24 + 42 = 66 。\n可以证明不存在其他数对满足数位上最大的数字相等，所以答案是 88 。\n示例 2：\n输入：nums = [1,2,3,4]\n输出：-1\n解释：不存在数对满足数位上最大的数字相等。\n提示：\n2 \u0026lt;= nums.length \u0026lt;= 100\n1 \u0026lt;= nums[i] \u0026lt;= 10^4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // @lc code=start class Solution { public: int maxSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; maxval(10,INT_MIN) ; int ans=-1; for (int bak: nums) { int id = 0; int u = bak; while(u) { id = max(id,u%10) ; u/=10; } ans = max(ans,maxval[id] + bak); maxval[id] = max(maxval[id],bak); } return ans; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2815] 数组中的最大数对和\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; vector\u0026lt;int\u0026gt; nums{51,71,17,24,42} ; println(k.maxSum(nums)); return 0; } ","date":"2024-01-20T23:04:52+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/%E8%B4%A1%E7%8C%AE/lc.2815%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AF%B9%E5%92%8C/","tags":["贡献"],"title":"lc.2815数组中的最大数对和"},{"categories":["单调栈"],"contents":" leetcode\n2867.统计树中的合法路径数目 algorithms\nHard (34.50%)\nLikes: 17\nDislikes: 0\nTotal Accepted: 2.7K\nTotal Submissions: 7.8K\nTestcase Example: \u0026lsquo;5\\n[[1,2],[1,3],[2,4],[2,5]]\u0026rsquo;\n给你一棵 n 个节点的无向树，节点编号为 1 到 n 。给你一个整数 n 和一个长度为 n -\n1 的二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示节点 ui\n和 vi 在树中有一条边。\n请你返回树中的 合法路径数目 。\n如果在节点 a 到节点 b 之间 恰好有一个 节点的编号是质数，那么我们称路径 (a, b) 是\n合法的 。\n注意：\n路径 (a, b) 指的是一条从节点 a 开始到节点 b 结束的一个节点序列，序列中的节点\n互不相同 ，且相邻节点之间在树上有一条边。 路径 (a, b) 和路径 (b, a) 视为\n同一条 路径，且只计入答案 一次 。\n示例 1：\n输入：n = 5, edges = [[1,2],[1,3],[2,4],[2,5]]\n输出：4\n解释：恰好有一个质数编号的节点路径有：\n(1, 2) 因为路径 1 到 2 只包含一个质数 2 。 (1, 3) 因为路径 1 到 3 只包含一个质数 3 。 (1, 4) 因为路径 1 到 4 只包含一个质数 2 。 (2, 4) 因为路径 2 到 4 只包含一个质数 2 。\n只有 4 条合法路径。 示例 2：\n输入：n = 6, edges = [[1,2],[1,3],[2,4],[3,5],[3,6]]\n输出：6\n解释：恰好有一个质数编号的节点路径有：\n(1, 2) 因为路径 1 到 2 只包含一个质数 2 。 (1, 3) 因为路径 1 到 3 只包含一个质数 3 。 (1, 4) 因为路径 1 到 4 只包含一个质数 2 。 (1, 6) 因为路径 1 到 6 只包含一个质数 3 。 (2, 4) 因为路径 2 到 4 只包含一个质数 2 。 (3, 6) 因为路径 3 到 6 只包含一个质数 3 。\n只有 6 条合法路径。 提示：\n1 \u0026lt;= n \u0026lt;= 10^5\nedges.length == n - 1\nedges[i].length == 2\n1 \u0026lt;= ui, vi \u0026lt;= n\n输入保证 edges 形成一棵合法的树。\n质数筛选法原理 把 2,3,4,5 列出来， 然后依次 把 前面的数的倍数标记为 false，应为是倍速\n有因子，一定不是质数，后面没有被标记的就是质数\n这题本质上是求一种类似于「非质数-质数-非质数」的路径个数。\n这让我想到了另外一道题目 2242. 节点序列的最大得分。\n这两题的共同点在于「枚举中间」，请读者细细品味。\n作者：灵茶山艾府\n链接： https://leetcode.cn/problems/count-valid-paths-in-a-tree/solutions/2456716/tu-jie-on-xian-xing-zuo-fa-pythonjavacgo-tjz2/ 来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n统计 排列组合的方式计算 数量\n相关题型 [[..\\递推\\数学归纳法应用.md]]\n[[..\\并查集\\lc.547.省份数量.md]]\n[[..\\字符串\\递归\\lc.1625.执行创作后字典序最小的字符串.md]]\n[[..\\dp\\树形dp\\lc.2920.收集所有金币可获得的最大积分.md]]\n[[..\\dp\\树形dp\\lc.2925.在树上执行操作以后得到的最大分数.md]]\n代码解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 // @lc code=start const int MX = 1e5; bool np[MX + 1]; // 质数=false 非质数=true int init = []() { np[1] = true; for (int i = 2; i *i \u0026lt;= MX; i++) { if (!np[i]) { for (int j = i* i; j \u0026lt;= MX; j += i) { np[j] = true; } } } return 0; }(); class Solution { public: long long countPaths(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;edges) { g = vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;(n+1) ; for (auto \u0026amp;vc : edges) { g[vc[0]].push_back(vc[1]); g[vc[1]].push_back(vc[0]); } vector\u0026lt;int\u0026gt; sizes(n+1) ; long long ans=0,sum=0; for (int x=1;x\u0026lt;=n;x++) { if (np[x]) continue; // x是质数，枚举非质数（l,r)两个端点 int sum=0; for (int y: g[x]) { // 是质数不看 if(!np[y]) continue ; if(sizes[y] == 0) { nodes.clear(); dfs(y,-1); for (int z:nodes) { sizes[z] = nodes.size(); } } ans += (long long) sizes[y] * sum; sum += sizes[y]; } ans += sum; } return ans; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g; vector\u0026lt;int\u0026gt; nodes ; void dfs(int j, int fa ) { nodes.push_back(j); for (int y: g[j]) { if (y != fa \u0026amp;\u0026amp; np[y]) { dfs(y,j); } } } }; // @lc code=end int main() { # ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2867] 统计树中的合法路径数目\u0026#34; \u0026lt;\u0026lt; endl; # endif Solution k; int n = 4; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; edges{ {1,2},{1,4},{3,4}, }; println(k.countPaths(n, edges)); return 0; } ","date":"2024-01-20T19:10:50+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/lc.2867.%E7%BB%9F%E8%AE%A1%E6%A0%91%E7%A7%8D%E7%9A%84%E5%90%88%E6%B3%95%E8%B7%AF%E5%BE%84%E6%95%B0%E7%9B%AE/","tags":["单调栈"],"title":"lc.2867.统计树种的合法路径数目"},{"categories":["单调栈"],"contents":" leetcode 2865.美丽塔\nI algorithms\nMedium (49.24%)\nLikes: 12\nDislikes: 0\nTotal Accepted: 6K\nTotal Submissions: 12.1K\nTestcase Example: \u0026lsquo;[5,3,4,1,1]\u0026rsquo;\n给你一个长度为 n 下标从 0 开始的整数数组 maxHeights 。\n你的任务是在坐标轴上建 n 座塔。第 i 座塔的下标为 i ，高度为 heights[i] 。\n如果以下条件满足，我们称这些塔是 美丽 的：\n1 \u0026lt;= heights[i] \u0026lt;= maxHeights[i]\nheights 是一个 山脉 数组。\n如果存在下标 i 满足以下条件，那么我们称数组 heights 是一个 山脉 数组：\n对于所有 0 \u0026lt; j \u0026lt;= i ，都有 heights[j - 1] \u0026lt;= heights[j]\n对于所有 i \u0026lt;= k \u0026lt; n - 1 ，都有 heights[k + 1] \u0026lt;= heights[k]\n请你返回满足 美丽塔 要求的方案中，高度和的最大值 。\n示例 1：\n输入：maxHeights = [5,3,4,1,1]\n输出：13\n解释：和最大的美丽塔方案为 heights = [5,3,3,1,1] ，这是一个美丽塔方案，因为：\n1 \u0026lt;= heights[i] \u0026lt;= maxHeights[i] heights 是个山脉数组，峰值在 i = 0 处。\n13 是所有美丽塔方案中的最大高度和。 示例 2：\n输入：maxHeights = [6,5,3,9,2,7]\n输出：22\n解释： 和最大的美丽塔方案为 heights = [3,3,3,9,2,2] ，这是一个美丽塔方案，因为：\n1 \u0026lt;= heights[i] \u0026lt;= maxHeights[i] heights 是个山脉数组，峰值在 i = 3 处。\n22 是所有美丽塔方案中的最大高度和。 示例 3：\n输入：maxHeights = [3,2,5,5,2,3]\n输出：18\n解释：和最大的美丽塔方案为 heights = [2,2,5,5,2,2] ，这是一个美丽塔方案，因为：\n1 \u0026lt;= heights[i] \u0026lt;= maxHeights[i] heights 是个山脉数组，最大值在 i = 2 处。\n注意，在这个方案中，i = 3 也是一个峰值。\n18 是所有美丽塔方案中的最大高度和。 提示：\n1 \u0026lt;= n == maxHeights \u0026lt;= 10^3\n1 \u0026lt;= maxHeights[i] \u0026lt;= 10^9\n下面把 maxHeights 简记为 aaa。\n计算从 a[0] 到 a[i]形成山状数组的左侧递增段，元素和最大是多少，记到数组 pre[i]中。\n计算从 a[i] 到 a[n−1] 形成山状数组的右侧递减段，元素和最大是多少，记到数组 suf[i] 中。\n那么答案就是 pre[i]+suf[i+1]的最大值。\n如何计算 pre 和 suf 呢？\n作者：灵茶山艾府\n链接： https://leetcode.cn/problems/beautiful-towers-i/solutions/2456565/on-qian-hou-zhui-fen-jie-dan-diao-zhan-p-w3g0/ 来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n[[..\\解题技巧\\单调栈.md]]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // @lc code=start #define ll long long class Solution { public: long long maximumSumOfHeights(vector\u0026lt;int\u0026gt; \u0026amp;maxHeights) { int n = maxHeights.size(); if (!n) return 0; vector\u0026lt;ll\u0026gt; sumleft(n + 1); vector\u0026lt;ll\u0026gt; sumright(n+1) ; stack\u0026lt;int\u0026gt; s; for (int i = 0; i \u0026lt; n; i++) { int curr = maxHeights[i]; while (s.size() \u0026amp;\u0026amp; curr \u0026lt; maxHeights[s.top()]) { // 把 前面的数变成 curr 然后求和 s.pop(); } int top = s.empty()? -1: s.top(); s.push(i); sumleft[i+1] = sumleft[top+1] + curr*1ll * (i - top); } while(s.size()) s.pop(); for (int i=n-1;i\u0026gt;=0;i--) { int curr = maxHeights[i]; while(s.size() \u0026amp;\u0026amp; curr \u0026lt; maxHeights[s.top()]) s.pop(); //维护一个 从左到右 升序的序列 int top = s.empty()? n: s.top(); s.push(i); sumright[i] = sumright[top] + curr*1ll * (top - i); } #ifdef debug println(sumleft); println(sumright); #endif ll maxx = 0; for (int i=0;i\u0026lt;n;i++) maxx = max(maxx , sumleft[i] + sumright[i]); return maxx; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2865] 美丽塔 I\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; vector\u0026lt;int\u0026gt; nums{5,3,4,1,1} ; println(k.maximumSumOfHeights(nums)); return 0; } ","date":"2024-01-20T16:56:09+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/lc.2865.%E7%BE%8E%E4%B8%BD%E5%A1%94/","tags":["单调栈"],"title":"lc.2865.美丽塔"},{"categories":["单调栈"],"contents":" leetcode 1124.表现良好的最长时间段 algorithms\nMedium (39.53%)\nLikes: 515\nDislikes: 0\nTotal Accepted: 44.9K\nTotal Submissions: 113.5K\nTestcase Example: \u0026lsquo;[9,9,6,0,6,6,9]\u0026rsquo;\n给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。\n我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。\n所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。\n请你返回「表现良好时间段」的最大长度。\n示例 1：\n输入：hours = [9,9,6,0,6,6,9]\n输出：3\n解释：最长的表现良好时间段是 [9,9,6]。\n示例 2：\n输入：hours = [6,6,6]\n输出：0\n提示：\n1 \u0026lt;= hours.length \u0026lt;= 10^4\n0 \u0026lt;= hours[i] \u0026lt;= 16\n例题分析 方法一：贪心\n思路与算法\n我们记工作小时数大于8的为1分，否则为-1分。那么原问题可以看做求解区间分数和大于0\n的最长区间长度。为了方便计算区间分数和，我们首先预处理分数前缀和s:\n1.令s[0]等于0\n2.设n为hours的长度，从小到大遍历i(1≤i≤n),若hours i-1\u0026gt;8,则令sd=s[i]+1,否则令s[i]=s[i-1]-1。\n因此，我们维护一个栈sth,栈中元素为s[0] - s[r一1]的递减项。具体的，我们遍历i(0\u0026lt;i\u0026lt; r一1)，如果s为空或者栈顶元素大于s[，则将s[入栈。求解l时，我们不断的弹出栈顶元\n素，直到栈顶元素是最后一个小于sr]的元素，此时栈顶元素所在位置即为我们要求的1。\n由于过程中单出的元素值都要比当前栈顶元素值小，因比这些弹出的元素仍然可能成为后面π的候\n选。如果按照从左到右的顺序去遍历π，我们仍需将这些弹出的元素值再次入栈。这样做的代价是\n昂贵的，我们不妨试试从大到小遍历”，整个求解过程如下：\n1.我们遍历整个s,求出维护递减序列的栈sh,注意它并不是我们通常意义上的单调栈。\n2.倒序遍历r,对于每个r:\nā.如果当前sh不为空并且栈顶元素小于sπ]，我们设栈顶元素在原数组的下标为1，用\nr一1更新答案，再令栈顶元素出浅。该过程不断循环直到条件不被满足。\nb.否则，继续考虑下一个r。\n思路 定 s[r] - s[l] \u0026gt; 0 ,固定 r，去求端点L, 使得 满足条件的情况下， r-l 最大\n正确性分析：\n1.如果有r1\u0026lt;r2,并且s[r1]\u0026gt;s[r2],那么r1所匹配的左端点l1和\nr2所匹配的左端点l2一定有1≤l2。在stk中，l2相比1更靠近\n栈顶，倘若求解2的过程中弹出了某些元素，也不会影响1的求\n解。对于1=2的情况，由于此时满足2一l2\u0026gt;r1-1,因此我们\n将2弹出栈也不会影响最终答案的求解。\n2.如果有r1\u0026lt;r2,并且s[1]≤s[r2],那么r1永远不会成为最优答案\n的右端点。\n至此，我们通过维护一个栈s,倒序遍历r求解可能成为最优区间的左端点1，在O(n)的时间复杂度内得到答案。\n[[..\\解题技巧\\单调栈.md]]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // @lc code=start class Solution { public: int longestWPI(vector\u0026lt;int\u0026gt;\u0026amp; hours) { int n = hours.size(); // todo: vector\u0026lt;int\u0026gt; s(n+1) ; stack\u0026lt;int\u0026gt; st; st.push(0); for (int i=1;i\u0026lt;=n;i++) { s[i] = s[i-1] + (hours[i-1] \u0026gt;8?1:-1); if(s[i] \u0026lt; s[st.top()]) { st.push(i); } } int maxlen=0; for (int j=n;j\u0026gt;0;j--) { while(st.size() \u0026amp;\u0026amp; s[j] - s[st.top()] \u0026gt; 0) { int k = st.top(); st.pop(); maxlen = max(maxlen,j-k); } } return maxlen; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [1124] 表现良好的最长时间段\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; vector\u0026lt;int\u0026gt; nums{9,9,6,0,6,6,9} ; println(k.longestWPI(nums)); return 0; } ","date":"2024-01-20T01:51:53+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/lc.1124.%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%AE%B5/","tags":["单调栈","贪心"],"title":"lc.1124.表现良好的最长时间段"},{"categories":["单调栈"],"contents":" leetcode 962.最大宽度坡 algorithms\nMedium (47.91%)\nLikes: 242\nDislikes: 0\nTotal Accepted: 26.2K\nTotal Submissions: 54.6K\nTestcase Example: \u0026lsquo;[6,0,8,2,1,5]\u0026rsquo;\n给定一个整数数组 A，坡是元组 (i, j)，其中 i \u0026lt; j 且 A[i] \u0026lt;= A[j]。这样的坡的宽度为 j - i。\n找出 A 中的坡的最大宽度，如果不存在，返回 0 。\n示例 1：\n输入：[6,0,8,2,1,5]\n输出：4\n解释：\n最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5.\n示例 2：\n输入：[9,8,1,0,1,9,4,0,4,1]\n输出：7\n解释：\n最大宽度的坡为 (i, j) = (2, 9): A[2] = 1 且 A[9] = 1.\n提示：\n2 \u0026lt;= A.length \u0026lt;= 50000\n0 \u0026lt;= A[i] \u0026lt;= 50000\n解题代码 这道题是万恶之源！\n先生成一个严格单调递减的数列存进栈中（从0位置开始），这是所有可能的i值，因为大于等于栈中元素的位置\n如果想要成为i值，必然可以被在它左边的比它小的栈中位置替代（因为值更小，位置也更小，否则的话这个元素\n也会入栈），因此我们通过第一步完成了对i的取值的存储；\n接下来为了使得长度最长，我们从最右边开始找j值，一旦栈顶位置元素值小于等于当前j位置的值，我们就可以\n考虑把i的位置向左移动使得长度增加（右边界固定寻找最远的左边界），之后再开始减少右边界，如此循环直到j不再\n满足条件\n作者：游世无双\n链接： https://leetcode.cn/problems/maximum-width-ramp/solutions/1/dan-diao-zhan-bi-shua-ti-by-jiachengpku-okjt/ 来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n[[..\\解题技巧\\单调栈.md]]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // @lc code=start class Solution { public: int maxWidthRamp(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); stack\u0026lt;int\u0026gt; d; for (int i=0;i\u0026lt;n;i++) { if(d.size()==0|| nums[i] \u0026lt; nums[d.top()]) d.push(i); } int maxlen=0; //递减 for (int j=n-1;j\u0026gt;=0;j--) { while(d.size() \u0026amp;\u0026amp; nums[j] \u0026gt;= nums[d.top()]) { int i = d.top(); d.pop(); if (i \u0026lt; j \u0026amp;\u0026amp; j-i \u0026gt; maxlen) maxlen = j-i; } } return maxlen; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [962] 最大宽度坡\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; vector\u0026lt;int\u0026gt; w = {10,10,10,7,1,6,2,1,7} ; println(k.maxWidthRamp(w)); return 0; } ","date":"2024-01-20T00:10:28+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/lc.962.%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6%E5%9D%A1/","tags":["单调栈"],"title":"lc.962.最大宽度坡"},{"categories":["单调栈"],"contents":" leetcode 1019.链表中的下一个更大节点 algorithms\nMedium (64.49%)\nLikes: 326\nDislikes: 0\nTotal Accepted: 57.5K\nTotal Submissions: 89.2K\nTestcase Example: \u0026lsquo;[2,1,5]\u0026rsquo;\n给定一个长度为 n 的链表 head\n对于列表中的每个节点，查找下一个 更大节点 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 严格大于 它的值。\n返回一个整数数组 answer ，其中 answer[i] 是第 i 个节点( 从1开始 )的下一个更大的节点的值。如果第 i\n个节点没有下一个更大的节点，设置 answer[i] = 0 。\n示例 1：\n输入：head = [2,1,5]\n输出：[5,5,0]\n示例 2：\n输入：head = [2,7,4,3,5]\n输出：[7,0,5,5,0]\n提示：\n链表中节点数为 n\n1 \u0026lt;= n \u0026lt;= 10^4\n1 \u0026lt;= Node.val \u0026lt;= 10^9\n*/\n解题思路 [[单调栈.md]]\n[[..\\解题技巧\\单调栈.md]]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // @lc code=start /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; nextLargerNodes(ListNode* head) { stack\u0026lt;int\u0026gt; s; ListNode *p =head; int n=0; while(p) { p=p-\u0026gt;next; n++; } vector\u0026lt;int\u0026gt; res(n); int i=0; while(head) { res[i++] = (-head-\u0026gt;val); head =head-\u0026gt;next; } for (int i=0;i\u0026lt;n;i++) { while(s.size() \u0026amp;\u0026amp; res[i] \u0026lt; res[s.top()]) { int j = s.top(); s.pop(); res[j] = -res[i]; } s.push(i); } for (int i=0;i\u0026lt;n;i++) if(res[i] \u0026lt;0) res[i] =0; return res; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [1019] 链表中的下一个更大节点\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; println(k.nextLargerNodes(makeLinkedList(vector\u0026lt;int\u0026gt; {2,1,5} ))); return 0; } ","date":"2024-01-19T21:42:09+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/lc.1019.%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E8%8A%82%E7%82%B9/","tags":["单调栈"],"title":"lc.1019.链表中的下一个更大节点"},{"categories":["单调栈"],"contents":" leetcode 1475.商品折扣后的最终价格 algorithms\nEasy (73.54%)\nLikes: 218\nDislikes: 0\nTotal Accepted: 73.1K\nTotal Submissions: 99.4K\nTestcase Example: \u0026lsquo;[8,4,6,2,3]\u0026rsquo;\n给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。\n商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j \u0026gt; i 且 prices[j]\n\u0026lt;= prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。\n请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。\n示例 1：\n输入：prices = [8,4,6,2,3]\n输出：[4,2,4,2,3]\n解释：\n商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。\n商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。\n商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。\n商品 3 和 4 都没有折扣。\n示例 2：\n输入：prices = [1,2,3,4,5]\n输出：[1,2,3,4,5]\n解释：在这个例子中，所有商品都没有折扣。\n示例 3：\n输入：prices = [10,1,1,6]\n输出：[9,0,1,6]\n提示：\n1 \u0026lt;= prices.length \u0026lt;= 500\n1 \u0026lt;= prices[i] \u0026lt;= 10^3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // @lc code=start class Solution { public: vector\u0026lt;int\u0026gt; finalPrices(vector\u0026lt;int\u0026gt;\u0026amp; prices) { stack\u0026lt;int\u0026gt; s; int n = prices.size(); if(n==0) return {}; if (n\u0026lt;=1) return {}; vector\u0026lt;int\u0026gt; res(n) ; for (int j=0;j\u0026lt;n;j++) { while(s.size() \u0026amp;\u0026amp; prices[j] \u0026lt;= prices[s.top()]) { int i = s.top();s.pop(); res[i] = prices[i] - prices[j]; } s.push(j); } while(s.size()) { int i = s.top();s.pop(); res[i] = prices[i]; } return res; } }; // @lc code=end ","date":"2024-01-16T22:02:51+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/lc.1475.%E5%95%86%E5%93%81%E6%8A%98%E6%89%A3%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E4%BB%B7%E6%A0%BC/","tags":["单调栈"],"title":"lc.1475.商品折扣后的最终价格"},{"categories":["解题技巧"],"contents":"【题单】单调栈（矩形系列/字典序最小/贡献法）\n原理 单调栈 单调栈原理讲解 739. 每日温度 1475. 商品折扣后的最终价格 1212 496. 下一个更大元素 I 503. 下一个更大元素 II 1019. 链表中的下一个更大节点 1571 962. 最大宽度坡 1608 901. 股票价格跨度 1709 1124. 表现良好的最长时间段 1908 456. 132 模式 ~2000 2866. 美丽塔 II 2072 2454. 下一个更大元素 IV 2175 2289. 使数组按非递减顺序排列 2482 1776. 车队 II 2531 2832. 每个元素为最大值的最大范围 （会员题） 矩形系列 84. 柱状图中最大的矩形 85. 最大矩形 1504. 统计全 1 子矩形 1845 字典序最小 316. 去除重复字母 316 扩展：重复个数不超过 limit 402. 移掉 K 位数字 ~1800 1673. 找出最具竞争力的子序列 1802 321. 拼接最大数 贡献法 907. 子数组的最小值之和 1976 2104. 子数组范围和（最大值-最小值） O(n)\\mathcal{O}(n)O(n) 做法难度大约 2000 1856. 子数组最小乘积的最大值 2051 2818. 操作使得分最大 2397 2281. 巫师的总力量和（最小值×和） 2621 相关链接 简单题 [[..\\单调栈\\lc.1475.商品折扣后的最终价格.md]]\n[[..\\单调栈\\最小栈.md]]\n[[..\\单调栈\\lc.503.下一个更大元素II.md]]\n[[..\\单调栈\\单调栈.md]]\n中等题 [[..\\单调栈\\lc.1856.子数组最小乘积的最大值.md]]\n[[..\\单调栈\\lc.1124.表现良好的最长时间段.md]]\n[[..\\数据结构\\栈\\lc.1124.表现良好的最长时间段.md]]\n[[..\\单调栈\\lc.456.132模式.md]]\n[[..\\单调栈\\lc.2865.美丽塔.md]]\n解题技巧 对于 三个数 ,i,j,k 之间的关系，一般 可以枚举中间 的值 j, 再讨论两边\n单调栈+计算贡献 牛客刷题 题目 类型 难度 愤怒的小鸟 单调栈 ","date":"2024-01-16T00:22:23+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/%E5%8D%95%E8%B0%83%E6%A0%88/","tags":["解题技巧"],"title":"单调栈"},{"categories":["差分"],"contents":" leetcode\n2772.使数组中的所有元素都等于零 algorithms\nMedium (37.08%)\nLikes: 35\nDislikes: 0\nTotal Accepted: 5.5K\nTotal Submissions: 14.9K\nTestcase Example: \u0026lsquo;[2,2,3,1,1,0]\\n3\u0026rsquo;\n给你一个下标从 0 开始的整数数组 nums 和一个正整数 k 。\n你可以对数组执行下述操作 任意次 ：\n从数组中选出长度为 k 的 任一 子数组，并将子数组中每个元素都 减去 1 。\n如果你可以使数组中的所有元素都等于 0 ，返回 true ；否则，返回 false 。\n子数组 是数组中的一个非空连续元素序列。\n示例 1：\n输入：nums = [2,2,3,1,1,0], k = 3\n输出：true\n解释：可以执行下述操作：\n选出子数组 [2,2,3] ，执行操作后，数组变为 nums = [1,1,2,1,1,0] 。 选出子数组 [2,1,1] ，执行操作后，数组变为 nums = [1,1,1,0,0,0] 。 选出子数组 [1,1,1] ，执行操作后，数组变为 nums = [0,0,0,0,0,0] 。 示例 2：\n输入：nums = [1,3,1,1], k = 2\n输出：false\n解释：无法使数组中的所有元素等于 0 。\n提示：\n1 \u0026lt;= k \u0026lt;= nums.length \u0026lt;= 10^5\n0 \u0026lt;= nums[i] \u0026lt;= 10^6\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // @lc code=start class Solution { public: bool checkArray(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { int n = nums.size(); if (!n) return false; vector\u0026lt;int\u0026gt; d(n + 3); d[0] = nums[0]; for (int i = 1; i \u0026lt; n; i++) d[i] = nums[i] - nums[i - 1]; d[n] = -nums[n - 1]; #ifdef debug for (int i = 0; i + k \u0026lt;= n; i++) { if (d[i] == 0) continue; if (d[i] \u0026lt; 0) { return false; for (int i = 0; i + k \u0026lt;= n; i++) { if (d[i] == 0) continue; if (d[i] \u0026lt; 0) { return false; } return true; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2772] 使数组中的所有元素都等于零\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; vector\u0026lt;int\u0026gt; a = {2, 2, 3, 1, 1, 0}; println(k.checkArray(a, 3)); return 0; } 简化版 https://leetcode.cn/problems/apply-operations-to-make-all-array-elements-equal-to-zero/solutions/2336744/chai-fen-shu-zu-pythonjavacgojs-by-endle-8qrt/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: bool checkArray(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { int n = nums.size(); if (!n) return false; vector\u0026lt;int\u0026gt; d(n + 1); //标记数组 mark int pre = 0; for(int i=0;i\u0026lt;n;i++) { pre += d[i]; int x = nums[i] + pre; if(x\u0026lt;0) return false; if(x==0) continue; if(i+k \u0026gt; n) return false; if(x\u0026gt;0) { pre -= x; d[i+k] += x; } } return true; } }; ","date":"2024-01-15T00:49:41+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E5%B7%AE%E5%88%86/lc.2772.%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E9%83%BD%E7%AD%89%E4%BA%8E0/","tags":["差分"],"title":"lc.2772.使数组中的所有元素都等于0"},{"categories":["差分"],"contents":" leetcode 2406.将区间分为最少组数 algorithms\nMedium (46.74%)\nLikes: 62\nDislikes: 0\nTotal Accepted: 9.9K\nTotal Submissions: 21.2K\nTestcase Example: \u0026lsquo;[[5,10],[6,8],[1,5],[2,3],[1,10]]\u0026rsquo;\n给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示 闭 区间 [lefti,\nrighti] 。\n你需要将 intervals 划分为一个或者多个区间 组 ，每个区间 只 属于一个组，且同一个组中任意两个区间 不相交 。\n请你返回 最少 需要划分成多少个组。\n如果两个区间覆盖的范围有重叠（即至少有一个公共数字），那么我们称这两个区间是 相交 的。比方说区间 [1, 5] 和 [5, 8] 相交。\n示例 1：\n输入：intervals = [[5,10],[6,8],[1,5],[2,3],[1,10]]\n输出：3\n解释：我们可以将区间划分为如下的区间组：\n第 1 组：[1, 5] ，[6, 8] 。 第 2 组：[2, 3] ，[5, 10] 。 第 3 组：[1, 10] 。\n可以证明无法将区间划分为少于 3 个组。 示例 2：\n输入：intervals = [[1,3],[5,6],[8,10],[11,13]]\n输出：1\n解释：所有区间互不相交，所以我们可以把它们全部放在一个组内。\n提示：\n1 \u0026lt;= intervals.length \u0026lt;= 10^5\nintervals[i].length == 2\n1 \u0026lt;= lefti \u0026lt;= righti \u0026lt;= 10^6\n*/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // @lc code=start // 解题思路： 上下车模型，l时刻上车,r+1时刻下车, 求 在整个开车过程中，最多同时有多少人在车上 // 差分解法 class Solution { public: int minGroups(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { map\u0026lt;int,int\u0026gt; mp; for (auto \u0026amp;v: intervals) { int l = v[0],r=v[1]; mp[l]+=1; mp[r+1]-=1; } int all=0,mx=1; for (auto [_,v]: mp) { all +=v; mx = max(mx,all); } return mx; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2406] 将区间分为最少组数\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; intervals = {{5,10},{6,8},{1,5},{2,3},{1,10}}; // int u = 3; println(k.minGroups(intervals)); return 0; } ","date":"2024-01-15T00:26:09+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E5%B7%AE%E5%88%86/lc.2406.%E5%B0%86%E5%8C%BA%E9%97%B4%E5%88%86%E4%B8%BA%E6%9C%80%E5%B0%8F%E7%BB%84%E6%95%B0/","tags":["差分"],"title":"lc.2406.将区间分为最小组数"},{"categories":["差分"],"contents":" leetcode 2381.字母移位\nII algorithms\nMedium (39.06%)\nLikes: 24\nDislikes: 0\nTotal Accepted: 6.9K\nTotal Submissions: 17.8K\nTestcase Example: \u0026lsquo;\u0026ldquo;abc\u0026rdquo;\\n[[0,1,0],[1,2,1],[0,2,1]]\u0026rsquo;\n给你一个小写英文字母组成的字符串 s 和一个二维整数数组 shifts ，其中 shifts[i] =\n[starti, endi,\ndirectioni] 。对于每个 i ，将 s 中从下标 starti 到下标 endi （两者都包含）所有字符都进行移位运算，如果\ndirectioni = 1 将字符向后移位，如果 directioni = 0 将字符向前移位。\n将一个字符 向后 移位的意思是将这个字符用字母表中\n下一个 字母替换（字母表视为环绕的，所以 \u0026lsquo;z\u0026rsquo; 变成 \u0026lsquo;a\u0026rsquo;）。类似的，将一个字符 向前\n移位的意思是将这个字符用字母表中\n前一个 字母替换（字母表是环绕的，所以 \u0026lsquo;a\u0026rsquo; 变成 \u0026lsquo;z\u0026rsquo; ）。\n请你返回对 s 进行所有移位操作以后得到的最终字符串。\n示例 1：\n输入：s = \u0026ldquo;abc\u0026rdquo;, shifts = [[0,1,0],[1,2,1],[0,2,1]]\n输出：\u0026ldquo;ace\u0026rdquo;\n解释：首先，将下标从 0 到 1 的字母向前移位，得到 s = \u0026ldquo;zac\u0026rdquo; 。\n然后，将下标从 1 到 2 的字母向后移位，得到 s = \u0026ldquo;zbd\u0026rdquo; 。\n最后，将下标从 0 到 2 的字符向后移位，得到 s = \u0026ldquo;ace\u0026rdquo; 。\n示例 2:\n输入：s = \u0026ldquo;dztz\u0026rdquo;, shifts = [[0,0,0],[1,1,1]]\n输出：\u0026ldquo;catz\u0026rdquo;\n解释：首先，将下标从 0 到 0 的字母向前移位，得到 s = \u0026ldquo;cztz\u0026rdquo; 。\n最后，将下标从 1 到 1 的字符向后移位，得到 s = \u0026ldquo;catz\u0026rdquo; 。\n提示：\n1 \u0026lt;= s.length, shifts.length \u0026lt;= 5 * 10^4\nshifts[i].length == 3\n0 \u0026lt;= starti \u0026lt;= endi \u0026lt; s.length\n0 \u0026lt;= directioni \u0026lt;= 1\ns 只包含小写英文字母。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // @lc code=start class Solution { public: string shiftingLetters(string s, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;shifts) { int n = s.size(); vector\u0026lt;int\u0026gt; d(n + 3); for (auto \u0026amp;shift : shifts) { int start = shift[0], end = shift[1]; int k = shift[2]==0? -1:1; d[start] += k; if (end+1\u0026lt;n) d[end+1] -= k; } #ifdef debug printa(d); #endif int all=0; for (int i=0;i\u0026lt;n;i++) { all += d[i]; if (!all) continue; int offset = (s[i]-\u0026#39;a\u0026#39; + all) % 26; while (offset\u0026lt;0) offset += 26; s[i] = \u0026#39;a\u0026#39;+offset; } return s; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2381] 字母移位 II\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; shifts = {{0, 1, 0}, {1, 2, 1}, {0, 2, 1}}; println(k.shiftingLetters(\u0026#34;abc\u0026#34;, shifts)); return 0; } ","date":"2024-01-15T00:15:55+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E5%B7%AE%E5%88%86/lc.2381.%E5%AD%97%E6%AF%8D%E7%A7%BB%E4%BD%8D/","tags":["差分"],"title":"lc.2381.字母移位"},{"categories":["差分"],"contents":" leetcode 1094.拼车 algorithms\nMedium (53.30%)\nLikes: 363\nDislikes: 0\nTotal Accepted: 102.2K\nTotal Submissions: 191.8K\nTestcase Example: \u0026lsquo;[[2,1,5],[3,3,7]]\\n4\u0026rsquo;\n车上最初有 capacity 个空座位。车 只能 向一个方向行驶（也就是说，不允许掉头或改变方向）\n给定整数 capacity 和一个数组 trips , trip[i] = [numPassengersi, fromi, toi] 表示第 i\n次旅行有 numPassengersi 乘客，接他们和放他们的位置分别是 fromi 和 toi 。这些位置是从汽车的初始位置向东的公里数。\n当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。\n示例 1：\n输入：trips = [[2,1,5],[3,3,7]], capacity = 4\n输出：false\n示例 2：\n输入：trips = [[2,1,5],[3,3,7]], capacity = 5\n输出：true\n提示：\n1 \u0026lt;= trips.length \u0026lt;= 1000\ntrips[i].length == 3\n1 \u0026lt;= numPassengersi \u0026lt;= 100\n0 \u0026lt;= fromi \u0026lt; toi \u0026lt;= 1000\n1 \u0026lt;= capacity \u0026lt;= 10^5\n解题思路 记住差分的2个性质\n性质1： 从左到右累加 d 中的元素，可以得到数组 a。\n性质2： 如下两个操作是等价的。\n区间操作 把区间 [i,j] 对 a数组都 +x 单点操作 ,d[i]+=x, dp[j+1] -= x 专门解决这种判断容量问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // @lc code=start class Solution { public: bool carPooling(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; trips, int capacity) { int N = 1000+10; vector\u0026lt;int\u0026gt; d(N); for (auto \u0026amp;w: trips) { int num = w[0]; int f = w[1],t=w[2]; d[f]+= num ; d[t] -=num; } int all=0; for (int u:d) { all += u ; if(all \u0026gt; capacity) return false; } return true; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [1094] 拼车\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; trips = {{2,1,5},{3,3,7}}; auto capacity = 4; println(k.carPooling(trips,capacity)); return 0; } ","date":"2024-01-14T23:08:41+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E5%B7%AE%E5%88%86/lc.1094.%E6%8B%BC%E8%BD%A6/","tags":["差分"],"title":"lc.1094.拼车"},{"categories":["解题技巧"],"contents":"差分数组 考虑数组a = [1,3,3,5,8], 对其中的相邻元素两两作差 , 得到数组 [2,0,2,3], 补上 a[0] 得到 d = [1,2,0,2,3]\n这有什么用呢？如果从左到右累加 d 中的元素，我们就「还原」回了 a 数组\n差分数组的定义和性质 对于数组 a，定义其差分数组（difference array）为\n$$\nd(i)=\n\\begin{cases}\na(0), i=0\\\na[i] - a[i-1] , i\u0026gt;=1\n\\end{cases}\n$$\n性质1： 从左到右累加 d 中的元素，可以得到数组 a。\n性质2： 如下两个操作是等价的。\n区间操作 把区间 [i,j] 对 a数组都 +x 单点操作 ,d[i]+=x, dp[j+1] -= x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 你有一个长为 n 的数组 a，一开始所有元素均为 0。 // 给定一些区间操作，其中 queries[i] = [left, right, x]， // 你需要把子数组 a[left], a[left+1], ... a[right] 都加上 x。 // 返回所有操作执行完后的数组 a。 vector\u0026lt;int\u0026gt; solve(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; queries) { vector\u0026lt;int\u0026gt; diff(n); // 差分数组 for (auto \u0026amp;q: queries) { int left = q[0], right = q[1], x = q[2]; diff[left] += x; if (right + 1 \u0026lt; n) { diff[right + 1] -= x; } } for (int i = 1; i \u0026lt; n; i++) { diff[i] += diff[i - 1]; // 直接在差分数组上复原数组 a } return diff; } 练习 1094. 拼车 1109. 航班预订统计 2381. 字母移位 II 2406. 将区间分为最少组数 2772. 使数组中的所有元素都等于零 2528. 最大化城市的最小供电站数目 解题笔记 [[../差分/lc.1094.拼车.md]]\n[[../差分/lc.2381.字母移位.md]]\n[[../差分/lc.2406.将区间分为最小组数.md]]\n[[../差分/lc.2772.使数组中的所有元素都等于0.md]]\n","date":"2024-01-14T22:47:22+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/","tags":["解题技巧"],"title":"差分数组"},{"categories":["递归"],"contents":" leetcode 51.N 皇后 algorithms\nHard (73.94%)\nLikes: 2007\nDislikes: 0\nTotal Accepted: 359.3K\nTotal Submissions: 485.8K\nTestcase Example: \u0026lsquo;4\u0026rsquo;\n按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。\nn 皇后问题 研究的是如何将 n 个皇后放置在 n×n\n的棋盘上，并且使皇后彼此之间不能相互攻击。\n给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。\n每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 \u0026lsquo;Q\u0026rsquo; 和 \u0026lsquo;.\u0026rsquo;\n分别代表了皇后和空位。\n示例 1：\n输入：n = 4\n输出：[[\u0026quot;.Q..\u0026quot;,\u0026quot;\u0026hellip;Q\u0026quot;,\u0026ldquo;Q\u0026hellip;\u0026rdquo;,\u0026quot;..Q.\u0026quot;],[\u0026quot;..Q.\u0026quot;,\u0026ldquo;Q\u0026hellip;\u0026rdquo;,\u0026quot;\u0026hellip;Q\u0026quot;,\u0026quot;.Q..\u0026quot;]]\n解释：如上图所示，4 皇后问题存在两个不同的解法。\n示例 2：\n输入：n = 1\n输出：[[\u0026ldquo;Q\u0026rdquo;]]\n提示：\n1 \u0026lt;= n \u0026lt;= 9\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // @lc code=start class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; solveNQueens(int n) { vector\u0026lt;int\u0026gt; row; dfs(row, 0, n); return res; } unordered_set\u0026lt;int\u0026gt; col,d1,d2; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; res; void dfs(vector\u0026lt;int\u0026gt; \u0026amp;row, int k, int n) { if (k == n) { vector\u0026lt;string\u0026gt; tmp; for (int u : row) { string s(n, \u0026#39;.\u0026#39;); s[u] = \u0026#39;Q\u0026#39;; tmp.push_back(s); } res.push_back(tmp); return; } for (int i = 0; i \u0026lt; n; i++) { if (col.count(i)) { continue; } if (d1.count(k+i) ){ continue; } if (d2.count(k-i)) { continue; } col.insert(i); d1.insert(k+i); d2.insert(k-i); row.push_back(i); dfs(row,k+1,n); row.pop_back(); col.erase(i); d1.erase(k+i); d2.erase(k-i); } return; } bool canput(int prev, int idx) { return true; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [51] N 皇后\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; printa(k.solveNQueens(4)); return 0; } ","date":"2024-01-14T22:40:33+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/lc.51n%E7%9A%87%E5%90%8E/","tags":["递归"],"title":"lc.51N皇后"},{"categories":["解题技巧"],"contents":"递归算法两种技巧 有两种考虑思路\n选择或者不选 选哪个 经典例题 N皇后问题 全排列，组合等 参考\nhttps://leetcode.cn/circle/discuss/v2RXSN/ ","date":"2024-01-14T22:40:00+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/","tags":["解题技巧"],"title":"回溯算法技巧"},{"categories":["经典模板题"],"contents":" leetcode 46.全排列 algorithms\nMedium (79.01%)\nLikes: 2792\nDislikes: 0\nTotal Accepted: 986.4K\nTotal Submissions: 1.2M\nTestcase Example: \u0026lsquo;[1,2,3]\u0026rsquo;\n给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序\n返回答案。\n示例 1：\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n示例 2：\n输入：nums = [0,1]\n输出：[[0,1],[1,0]]\n示例 3：\n输入：nums = [1]\n输出：[[1]]\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 6\n-10 \u0026lt;= nums[i] \u0026lt;= 10\nnums 中的所有整数 互不相同\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // @lc code=start class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt; \u0026amp;nums) { vector\u0026lt;int\u0026gt; tmp; makeVec(0, nums, tmp); return all; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; all; void makeVec(int state, vector\u0026lt;int\u0026gt; \u0026amp;nums, vector\u0026lt;int\u0026gt; \u0026amp;res) { int n = nums.size(); for (int i = 0; i \u0026lt; n; i++) { int newst = state; if ( ((state \u0026gt;\u0026gt; i) \u0026amp; 1) == 0) { newst |= 1 \u0026lt;\u0026lt; i; res.push_back(nums[i]); makeVec(newst, nums, res); if (res.size() == n) { all.push_back(res); } res.pop_back(); } } } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [46] 全排列\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; vector\u0026lt;int\u0026gt; tp = {1,2,3} ; printa(k.permute(tp)); return 0; } ","date":"2024-01-14T21:38:29+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/%E7%BB%8F%E5%85%B8%E6%A8%A1%E6%9D%BF%E9%A2%98/lc.46.%E5%85%A8%E6%8E%92%E5%88%97/","tags":["经典模板题"],"title":"lc.46.全排列"},{"categories":["经典模板题"],"contents":" leetcode 77.组合 algorithms\nMedium (77.07%)\nLikes: 1570\nDislikes: 0\nTotal Accepted: 640.6K\nTotal Submissions: 831.2K\nTestcase Example: \u0026lsquo;4\\n2\u0026rsquo;\n给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n你可以按 任何顺序 返回答案。\n示例 1：\n输入：n = 4, k = 2\n输出：\n[\n⁠ [2,4],\n⁠ [3,4],\n⁠ [2,3],\n⁠ [1,2],\n⁠ [1,3],\n⁠ [1,4],\n]\n示例 2：\n输入：n = 1, k = 1\n输出：[[1]]\n提示：\n1\n1\n*/\n思路和原理 求位运算子集：\n1111 =》 1110,1101,1011,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // @lc code=start class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combine(int n, int k) { int all = (1\u0026lt;\u0026lt;n)-1; int s = all; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; res ; do { s = (s-1) \u0026amp; all; if (countbin(k,s)) { res.push_back(makeVec(s,n)); } }while(s != all); return res ; } vector\u0026lt;int\u0026gt; makeVec(int state,int n) { vector\u0026lt;int\u0026gt; res ; for (int i=0;i\u0026lt;n;i++) { if ( state\u0026gt;\u0026gt;i \u0026amp; 1) { res.push_back(i+1); } } return res; } bool countbin(int k,int state) { while(state) { state -= state \u0026amp; (-state); k--; if(k\u0026lt;0) return false; } return k == 0; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [77] 组合\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; printa(k.combine(4,2)); return 0; } ","date":"2024-01-14T21:23:25+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/%E7%BB%8F%E5%85%B8%E6%A8%A1%E6%9D%BF%E9%A2%98/lc.77.%E7%BB%84%E5%90%88/","tags":["经典模板题"],"title":"lc.77.组合"},{"categories":["经典模板题"],"contents":" leetcode 78.子集 algorithms\nMedium (81.18%)\nLikes: 2224\nDislikes: 0\nTotal Accepted: 717.6K\nTotal Submissions: 884K\nTestcase Example: \u0026lsquo;[1,2,3]\u0026rsquo;\n给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\n解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n示例 1：\n输入：nums = [1,2,3]\n输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n示例 2：\n输入：nums = [0]\n输出：[[],[0]]\n提示：\n1\n-10\nnums 中的所有元素 互不相同\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // @lc code=start class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int all = 0; for (int i=0;i\u0026lt;n;i++) all |= (1\u0026lt;\u0026lt;i); vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; res; int s = all; do { s = (s-1) \u0026amp; all ; res.push_back(makeVec(s,nums)); } while (s != all); return res; } vector\u0026lt;int\u0026gt; makeVec(int state, vector\u0026lt;int\u0026gt; \u0026amp; nums ) { int n = nums.size(); vector\u0026lt;int\u0026gt; res; for (int i=0;i\u0026lt;n;i++) { if ((state \u0026gt;\u0026gt; i) \u0026amp; 1) { res.push_back(nums[i]); } } return res; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [78] 子集\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; vector\u0026lt;int \u0026gt; nums = {1,2,3} ; printa( k.subsets(nums)); return 0; } 其他写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: vector\u0026lt;int\u0026gt; t; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); for (int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; n); ++mask) { t.clear(); for (int i = 0; i \u0026lt; n; ++i) { if (mask \u0026amp; (1 \u0026lt;\u0026lt; i)) { t.push_back(nums[i]); } } ans.push_back(t); } return ans; } }; 暴力解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: vector\u0026lt;int\u0026gt; t; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; void dfs(int cur, vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (cur == nums.size()) { ans.push_back(t); return; } t.push_back(nums[cur]); dfs(cur + 1, nums); t.pop_back(); dfs(cur + 1, nums); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { dfs(0, nums); return ans; } }; 作者：力扣官方题解 链接：https://leetcode.cn/problems/subsets/solutions/420294/zi-ji-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2024-01-14T21:07:10+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/%E7%BB%8F%E5%85%B8%E6%A8%A1%E6%9D%BF%E9%A2%98/lc.78.%E5%AD%90%E9%9B%86/","tags":["经典模板题"],"title":"lc.78.子集"},{"categories":["位运算"],"contents":"从集合论到位运算，常见位运算技巧分类总结 本文参考 :\nhttps://leetcode.cn/circle/discuss/CaOJ45/ 1 2 3 4 s = 101100 ~s = 010011 (~s)+1 = 010100 // 根据补码的定义，这就是 -s 最低 1 左侧取反，右侧不变 s \u0026amp; -s = 000100 // lowbit 集合问题有4类\n集合与集合 集合与元素 遍历集合 枚举集合 集合与元素 术语 集合 位运算 举例 空集 \u0026mdash; 0 \u0026mdash; 单元素集 \u0026mdash; 1 \u0026laquo; i 1 \u0026laquo; 2 全集 \u0026mdash; (1 \u0026laquo; n)−1 \u0026mdash; 属于 \u0026mdash; (s \u0026raquo; i) \u0026amp; 1=1 \u0026mdash; 不属于 \u0026mdash; (s \u0026raquo; i) \u0026amp; 1=0 \u0026mdash; 添加元素 \u0026mdash; s ∣ (1 \u0026laquo; i) 1001 ∣ (1 \u0026laquo; 2) 删除元素 \u0026mdash; s\u0026amp;∼(1 \u0026laquo; i) 1101\u0026amp;∼(1 \u0026laquo; 2) 删除最小元素 \u0026mdash; s\u0026amp;(s−1) 见下 1 2 3 s = 101100 s-1 = 101011 // 最低位的 1 变成 0，同时 1 右边的 0 都取反，变成 1 s\u0026amp;(s-1) = 101000 集合遍历 1 2 3 4 5 for (int i = 0; i \u0026lt; n; i++) { if ((s \u0026gt;\u0026gt; i) \u0026amp; 1) { // i 在 s 中 // 处理 i 的逻辑 } } 枚举集合 设元素范围从 0 到 n−1，从空集 枚举到全集 U：\n1 2 3 for (int s = 0; s \u0026lt; (1 \u0026lt;\u0026lt; n); s++) { // 处理 s 的逻辑 } 设集合为 s，从大到小枚举 s 的所有非空子集 sub：\n1 2 3 for (int sub = s; sub; sub = (sub - 1) \u0026amp; s) { // 处理 sub 的逻辑 } 为什么要写成 sub = (sub - 1) \u0026amp; s 呢？\n暴力做法是从 s 出发，不断减一，直到 0\n但这样做，中途会遇到很多并不是 s 的子集的情况\n例如 s=10101 时，减一得到 10100，这是 s 的子集。但再减一就得到 10011 了，这并不是 s 的子集\n把所有的合法子集按顺序列出来，会发现我们做的相当于「压缩版」的二进制减法，例如\n1 10101→10100→10001→10000→00101 数字的变化和二进制减法是一样的\n如果要从大到小枚举 s 的所有子集 (从 s 枚举到空集 )\n1 2 3 4 5 int sub = s; do { // 处理 sub 的逻辑 sub = (sub - 1) \u0026amp; s; } while (sub != s); 原理是当 sub=0为空，-1 得到1111\u0026hellip;1, 再 \u0026amp; s 得到 s\n练习题目 用位运算完成如下题目：\n78. 子集 77. 组合 46. 全排列 然后是一些状态压缩 DP。这类题目通常和排列/子集有关，可以先从暴力回溯开始思考，再过渡到记忆化搜索和递推。\n2172. 数组的最大与和 ， 题解 1125. 最小的必要团队 ， 题解 2305. 公平分发饼干 ， 题解 1494. 并行课程 II ， 题解 LCP 53. 守护太空城 ， 题解 1879. 两个数组最小的异或值之和 1986. 完成任务的最少工作时间段 更多题目，可以在题库中同时选上「动态规划」和「位运算」这两个标签： 链接 。\n其他参考 https://oi-wiki.org/math/bit/#%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0 取数的最大/最小值 1 2 3 4 // 如果 a \u0026gt;= b, (a - b) \u0026gt;\u0026gt; 31 为 0，否则为 -1 int max(int a, int b) { return (b \u0026amp; ((a - b) \u0026gt;\u0026gt; 31)) | (a \u0026amp; (~(a - b) \u0026gt;\u0026gt; 31)); } int min(int a, int b) { return (a \u0026amp; ((a - b) \u0026gt;\u0026gt; 31)) | (b \u0026amp; (~(a - b) \u0026gt;\u0026gt; 31)); } 判断两非零数符号是否相同 1 2 3 4 bool isSameSign(int x, int y) { // 有 0 的情况例外 return (x ^ y) \u0026gt;= 0; } 获取一个数二进制的某一位 1 2 int getBit(int a, int b) { return (a \u0026gt;\u0026gt; b) \u0026amp; 1; } 将一个数二进制的某一位设置为 0 1 int unsetBit(int a, int b) { return a \u0026amp; ~(1 \u0026lt;\u0026lt; b); } 将一个数二进制的某一位设置为 1 1 int setBit(int a, int b) { return a | (1 \u0026lt;\u0026lt; b); } 将一个数二进制的某一位取反 1 2 // 将 a 的第 b 位取反 ，最低位编号为 0 int flapBit(int a, int b) { return a ^ (1 \u0026lt;\u0026lt; b); } ","date":"2024-01-14T18:56:07+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/%E4%BD%8D%E8%BF%90%E7%AE%97%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/","tags":["位运算"],"title":"位运算集合类型解题技巧"},{"categories":["位运算"],"contents":" leetcode\n2897.对数组执行操作使平方和最大 algorithms\nHard (57.22%)\nLikes: 13\nDislikes: 0\nTotal Accepted: 2.3K\nTotal Submissions: 4.1K\nTestcase Example: \u0026lsquo;[2,6,5,8]\\n2\u0026rsquo;\n给你一个下标从 0 开始的整数数组 nums 和一个 正 整数 k 。\n你可以对数组执行以下操作 任意次 ：\n选择两个互不相同的下标 i 和 j ，同时 将 nums[i] 更新为 (nums[i] AND nums[j])\n且将 nums[j] 更新为 (nums[i] OR nums[j]) ，OR 表示按位 或 运算，AND 表示按位\n与 运算。\n你需要从最终的数组里选择 k 个元素，并计算它们的 平方 之和。\n请你返回你可以得到的 最大 平方和。\n由于答案可能会很大，将答案对 10^9 + 7 取余 后返回。\n示例 1：\n输入：nums = [2,6,5,8], k = 2\n输出：261\n解释：我们可以对数组执行以下操作：\n选择 i = 0 和 j = 3 ，同时将 nums[0] 变为 (2 AND 8) = 0 且 nums[3] 变为 (2 OR = 10 ，结果数组为 nums = [0,6,5,10] 。 选择 i = 2 和 j = 3 ，同时将 nums[2] 变为 (5 AND 10) = 0 且 nums[3] 变为 (5 OR = 15 ，结果数组为 nums = [0,6,0,15] 。 从最终数组里选择元素 15 和 6\n，平方和为 15^2 + 6^2 = 261 。 261 是可以得到的最大结果。 示例 2：\n输入：nums = [4,5,4,7], k = 3\n输出：90\n解释：不需要执行任何操作。\n选择元素 7 ，5 和 4 ，平方和为 7^2 + 5^2 + 4^2 = 90 。\n90 是可以得到的最大结果。\n提示：\n1 \u0026lt;= k \u0026lt;= nums.length \u0026lt;= 10^5\n1 \u0026lt;= nums[i] \u0026lt;= 10^9\n解题思路 交换比不交换好\n对于同一个比特位，由于 AND 和 OR 不会改变都为 000 和都为 111 的情况，所以操作等价于：\n把一个数的 000 和另一个数的同一个比特位上的 111 交换。\n设交换前两个数是 xxx 和 yyy，且 x\u0026gt;yx\u0026gt;yx\u0026gt;y。把小的数上的 111 给大的数，假设交换后 xxx 增加了 ddd，那么 yyy 也减少了 ddd。\nhttps://leetcode.cn/circle/discuss/CaOJ45/ 解题代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // @lc code=start class Solution { public: int maxSum(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { int blen = 30; // n = nums.size(); vector\u0026lt;int\u0026gt; cnt(blen, 0); for (int x : nums) { for (int i = 0; i \u0026lt; blen; i++) { cnt[i] += (x \u0026gt;\u0026gt; i) \u0026amp; 1; } } long long ans = 0; const int MOD = 1e9+7; while (k-- \u0026gt; 0) { int x = 0; for (int i = 0; i \u0026lt; blen; i++) { if (cnt[i]) { cnt[i] -= 1; x |= 1 \u0026lt;\u0026lt; i; } } ans = (ans + (long long)x * x) % MOD; } return ans; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2897] 对数组执行操作使平方和最大\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; int u = 2; vector\u0026lt;int\u0026gt; nums = {2, 6, 5, 8}; println(k.maxSum(nums, u)); return 0; } ","date":"2024-01-14T18:51:21+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/lc.2897.%E5%AF%B9%E6%95%B0%E7%BB%84%E6%89%A7%E8%A1%8C%E5%88%9B%E4%BD%9C%E4%BD%BF%E5%B9%B3%E6%96%B9%E5%92%8C%E6%9C%80%E5%A4%A7/","tags":["位运算"],"title":"lc.2897.对数组执行创作使平方和最大"},{"categories":["划分型dp"],"contents":" leetcode\n2896.执行操作使两个字符串相等 algorithms\nMedium (31.27%)\nLikes: 44\nDislikes: 0\nTotal Accepted: 3.8K\nTotal Submissions: 12.1K\nTestcase Example: \u0026lsquo;\u0026ldquo;1100011000\u0026rdquo;\\n\u0026quot;0101001010\u0026quot;\\n2\u0026rsquo;\n给你两个下标从 0 开始的二进制字符串 s1\n和 s2 ，两个字符串的长度都是 n ，再给你一个正整数 x 。\n你可以对字符串 s1 执行以下操作 任意次 ：\n选择两个下标 i 和 j ，将 s1[i] 和 s1[j] 都反转，操作的代价为 x 。\n选择满足 i \u0026lt; n - 1 的下标 i ，反转 s1[i] 和 s1[i + 1] ，操作的代价为 1 。\n请你返回使字符串 s1 和 s2 相等的 最小 操作代价之和，如果无法让二者相等，返回 -1 。\n注意 ，反转字符的意思是将 0 变成 1 ，或者 1 变成 0 。\n示例 1：\n输入：s1 = \u0026ldquo;1100011000\u0026rdquo;, s2 = \u0026ldquo;0101001010\u0026rdquo;, x = 2\n输出：4\n解释：我们可以执行以下操作：\n选择 i = 3 执行第二个操作。结果字符串是 s1 = \u0026ldquo;1101111000\u0026rdquo; 。 选择 i = 4 执行第二个操作。结果字符串是 s1 = \u0026ldquo;1101001000\u0026rdquo; 。 选择 i = 0 和 j = 8 ，执行第一个操作。结果字符串是 s1 = \u0026ldquo;0101001010\u0026rdquo; = s2 。\n总代价是 1 + 1 + 2 = 4 。这是最小代价和。 示例 2：\n输入：s1 = \u0026ldquo;10110\u0026rdquo;, s2 = \u0026ldquo;00011\u0026rdquo;, x = 4\n输出：-1\n解释：无法使两个字符串相等。\n提示：\nn == s1.length == s2.length\n1 \u0026lt;= n, x \u0026lt;= 500\ns1 和 s2 只包含字符 \u0026lsquo;0\u0026rsquo; 和 \u0026lsquo;1\u0026rsquo; 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 // @lc code=start class Solution { public: int count1(string \u0026amp;s, char f = \u0026#39;1\u0026#39;) { int a = 0; for (auto u : s) { if (u == f) { ++a; } } return a; } vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; memo; // string s1; // string s2; // int x; int minOperations(string s1, string s2, int x) { if (count1(s1) % 2 != count1(s2) % 2) { return -1; } int n = s1.size(), m = s2.size(); if (n != m) return -1; // memo = vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt;( // n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n + 1, vector\u0026lt;int\u0026gt;(2, -1))); // int l = dfstree(n - 1, 0, false,s1,s2,x); // if (l == INT_MAX) // return -1; vector\u0026lt;int\u0026gt; dp ; for (int i=0;i\u0026lt;n;i++) { if (s1[i] != s2[i]) dp.push_back(i); } if(dp.size() % 2) return -1; int func1=x, func2=0; for (int i=1;i\u0026lt;dp.size();i++) { int fcost = min(func1 + x, func2 + (dp[i] - dp[i-1]) * 2); func2 = func1 ; func1 = fcost; } return func1/2; } int dfstree(int p, int xcount, bool prev_flip,string \u0026amp;s1,string \u0026amp;s2,int x) { #define dfs(p,xcount,prev_flip) dfstree(p,xcount,prev_flip,s1,s2,x) if (p \u0026lt; 0) { if (xcount || prev_flip) return INT_MAX / 2; return 0; } if (memo[p][xcount][prev_flip] \u0026gt; 0) { return memo[p][xcount][prev_flip]; } if ((s1[p] == s2[p]) == !prev_flip) { return dfs(p - 1, xcount, false); } // x int l = dfs(p - 1, xcount + 1, false) + x; int r = dfs(p - 1, xcount, true) + 1; int res = min(l, r); if (xcount \u0026gt; 0) { res = min(res, dfs(p - 1, xcount - 1, false)); } memo[p][xcount][prev_flip] = res; return res; } }; // @lc code=end int main() { # ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2896] 执行操作使两个字符串相等\u0026#34; \u0026lt;\u0026lt; endl; # endif Solution k; println(k.minOperations(\u0026#34;1100011000\u0026#34;, \u0026#34;0101001010\u0026#34;, 2)); return 0; } ","date":"2024-01-14T18:15:03+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E5%8C%BA%E9%97%B4dp/lc.2896.%E6%89%A7%E8%A1%8C%E5%88%9B%E4%BD%9C%E4%BD%BF%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/","tags":["划分型dp"],"title":"lc.2896.执行创作使两个字符串相等"},{"categories":["贪心"],"contents":" leetcode\n2895.最小处理时间 algorithms\nMedium (77.12%)\nLikes: 9\nDislikes: 0\nTotal Accepted: 5.2K\nTotal Submissions: 6.8K\nTestcase Example: \u0026lsquo;[8,10]\\n[2,2,3,1,8,7,4,5]\u0026rsquo;\n你有 n 颗处理器，每颗处理器都有 4 个核心。现有 n * 4\n个待执行任务，每个核心只执行 一个 任务。\n给你一个下标从 0 开始的整数数组 processorTime\n，表示每颗处理器最早空闲时间。另给你一个下标从 0 开始的整数数组 tasks\n，表示执行每个任务所需的时间。返回所有任务都执行完毕需要的 最小时间 。\n注意：每个核心独立执行任务。\n示例 1：\n输入：processorTime = [8,10], tasks = [2,2,3,1,8,7,4,5]\n输出：16\n解释：\n最优的方案是将下标为 4, 5, 6, 7 的任务分配给第一颗处理器（最早空闲时间 time =\n8），下标为 0, 1, 2, 3 的任务分配给第二颗处理器（最早空闲时间 time = 10）。\n第一颗处理器执行完所有任务需要花费的时间 = max(8 + 8, 8 + 7, 8 + 4, 8 + 5) = 16\n。 第二颗处理器执行完所有任务需要花费的时间 = max(10 + 2, 10 + 2, 10 + 3, 10 +\n= 13 。 因此，可以证明执行完所有任务需要花费的最小时间是 16 。 示例 2：\n输入：processorTime = [10,20], tasks = [2,3,1,2,5,8,4,3]\n输出：23\n解释：\n最优的方案是将下标为 1, 4, 5, 6 的任务分配给第一颗处理器（最早空闲时间 time =\n10），下标为 0, 2, 3, 7 的任务分配给第二颗处理器（最早空闲时间 time = 20）。\n第一颗处理器执行完所有任务需要花费的时间 = max(10 + 3, 10 + 5, 10 + 8, 10 + 4) =\n18 。 第二颗处理器执行完所有任务需要花费的时间 = max(20 + 2, 20 + 1, 20 + 2, 20\n= 23 。 因此，可以证明执行完所有任务需要花费的最小时间是 23 。 提示：\n1 \u0026lt;= n == processorTime.length \u0026lt;= 25000\n1 \u0026lt;= tasks.length \u0026lt;= 10^5\n0 \u0026lt;= processorTime[i] \u0026lt;= 10^9\n1 \u0026lt;= tasks[i] \u0026lt;= 10^9\ntasks.length == 4 * n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // @lc code=start class Solution { public: int minProcessingTime(vector\u0026lt;int\u0026gt; \u0026amp;processorTime, vector\u0026lt;int\u0026gt; \u0026amp;tasks) { sort(processorTime.begin(), processorTime.end()); sort(tasks.begin(), tasks.end(), greater\u0026lt;int\u0026gt;()); #ifdef debug printa(tasks); #endif int mx = INT_MIN; int n = processorTime.size(); int k = 0; for (int i = 0; i \u0026lt; n; i++) { mx = max(tasks[i * 4] + processorTime[i], mx); // for (int j=0;j\u0026lt;4;j++) { // mx = max(tasks[k]+ processorTime[i],mx); // k += 1; // } } return mx; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2895] 最小处理时间\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; array processorTime = {8, 10}, tasks = {2, 2, 3, 1, 8, 7, 4, 5}; println(k.minProcessingTime(processorTime, tasks)); return 0; } ","date":"2024-01-14T17:16:22+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/%E8%B4%AA%E5%BF%83/lc.2895.%E6%9C%80%E5%B0%8F%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4/","tags":["贪心"],"title":"lc.2895.最小处理时间"},{"categories":["划分型dp"],"contents":" leetcode 2909.元素和最小的山形三元组 II algorithms\nMedium (51.11%)\nLikes: 15\nDislikes: 0\nTotal Accepted: 6.4K\nTotal Submissions: 12.4K\nTestcase Example: \u0026lsquo;[8,6,1,5,3]\u0026rsquo;\n给你一个下标从 0 开始的整数数组 nums 。\n如果下标三元组 (i, j, k) 满足下述全部条件，则认为它是一个 山形三元组 ：\ni \u0026lt; j \u0026lt; k\nnums[i] \u0026lt; nums[j] 且 nums[k] \u0026lt; nums[j]\n请你找出 nums 中 元素和最小 的山形三元组，并返回其 元素和 。如果不存在满足条件的三元组，返回 -1 。\n示例 1：\n输入：nums = [8,6,1,5,3]\n输出：9\n解释：三元组 (2, 3, 4) 是一个元素和等于 9 的山形三元组，因为：\n2 \u0026lt; 3 \u0026lt; 4 nums[2] \u0026lt; nums[3] 且 nums[4] \u0026lt; nums[3]\n这个三元组的元素和等于 nums[2] + nums[3] + nums[4] = 9 。可以证明不存在元素和小于 9 的山形三元组。 示例 2：\n输入：nums = [5,4,8,7,10,2]\n输出：13\n解释：三元组 (1, 3, 5) 是一个元素和等于 13 的山形三元组，因为：\n1 \u0026lt; 3 \u0026lt; 5 nums[1] \u0026lt; nums[3] 且 nums[5] \u0026lt; nums[3]\n这个三元组的元素和等于 nums[1] + nums[3] + nums[5] = 13 。可以证明不存在元素和小于 13 的山形三元组。 示例 3：\n输入：nums = [6,5,4,3,4,5]\n输出：-1\n解释：可以证明 nums 中不存在山形三元组。\n提示：\n3 \u0026lt;= nums.length \u0026lt;= 10^5\n1 \u0026lt;= nums[i] \u0026lt;= 10^8\n解题思路 最长上升子序列问题\n前后缀分解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // @lc code=start class Solution { public: int minimumSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // [a,b,c] , ab 上升,bc下降 int n = nums.size(); if(!n) return -1; if (n\u0026lt;3) return -1; vector\u0026lt;int\u0026gt; values(n,0) ; values[0] = nums[0]; for (int i=1;i\u0026lt;n;i++) { if (nums[i] \u0026gt; values[i-1]) { values[i] = values[i-1]; }else { values[i] = nums[i]; //记录前面的最小值 } } #ifdef debug printa(values); #endif int ans = INT_MAX; int r = nums[n-1]; for (int i=n-1-1;i\u0026gt;0;i--) { int curr = nums[i]; if ( curr \u0026gt; r \u0026amp;\u0026amp; curr \u0026gt; values[i-1]) { ans = min(ans,curr + r + values[i-1]); } r = min(nums[i],r); } if (ans == INT_MAX) return -1; return ans; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2909] 元素和最小的山形三元组 II\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; vector\u0026lt;int \u0026gt; nums = {5,4,8,7,10,2 }; cout \u0026lt;\u0026lt; k.minimumSum(nums) \u0026lt;\u0026lt;endl; return 0; } ","date":"2024-01-14T13:06:16+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E5%8C%BA%E9%97%B4dp/lc.2909.%E5%85%83%E7%B4%A0%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B1%B1%E5%9E%8B%E4%B8%89%E5%85%83%E7%BB%84/","tags":["划分型dp"],"title":"lc.2909.元素和最小的山型三元组"},{"categories":["差分"],"contents":" leetcode\n2933.高访问员工 algorithms\nMedium (49.73%)\nLikes: 1\nDislikes: 0\nTotal Accepted: 4.8K\nTotal Submissions: 9.7K\nTestcase Example:\n\u0026lsquo;[[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;0549\u0026rdquo;],[\u0026ldquo;b\u0026rdquo;,\u0026ldquo;0457\u0026rdquo;],[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;0532\u0026rdquo;],[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;0621\u0026rdquo;],[\u0026ldquo;b\u0026rdquo;,\u0026ldquo;0540\u0026rdquo;]]\u0026rsquo;\n给你一个长度为 n 、下标从 0 开始的二维字符串数组 access_times 。对于每个 i（0 \u0026lt;=\ni \u0026lt;= n - 1 ），access_times[i][0] 表示某位员工的姓名，access_times[i][1]\n表示该员工的访问时间。access_times 中的所有条目都发生在同一天内。\n访问时间用 四位 数字表示， 符合 24 小时制 ，例如 \u0026ldquo;0800\u0026rdquo; 或 \u0026ldquo;2250\u0026rdquo; 。\n如果员工在 同一小时内 访问系统 三次或更多 ，则称其为 高访问 员工。\n时间间隔正好相差一小时的时间 不 被视为同一小时内。例如，\u0026ldquo;0815\u0026rdquo; 和 \u0026ldquo;0915\u0026rdquo;\n不属于同一小时内。\n一天开始和结束时的访问时间不被计算为同一小时内。例如，\u0026ldquo;0005\u0026rdquo; 和 \u0026ldquo;2350\u0026rdquo;\n不属于同一小时内。\n以列表形式，按任意顺序，返回所有 高访问 员工的姓名。\n示例 1：\n输入：access_times =\n[[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;0549\u0026rdquo;],[\u0026ldquo;b\u0026rdquo;,\u0026ldquo;0457\u0026rdquo;],[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;0532\u0026rdquo;],[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;0621\u0026rdquo;],[\u0026ldquo;b\u0026rdquo;,\u0026ldquo;0540\u0026rdquo;]]\n输出：[\u0026ldquo;a\u0026rdquo;]\n解释：\u0026ldquo;a\u0026rdquo; 在时间段 [05:32, 06:31] 内有三条访问记录，时间分别为 05:32 、05:49 和\n06:21 。 但是 \u0026ldquo;b\u0026rdquo; 的访问记录只有两条。 因此，答案是 [\u0026ldquo;a\u0026rdquo;] 。\n示例 2：\n输入：access_times =\n[[\u0026ldquo;d\u0026rdquo;,\u0026ldquo;0002\u0026rdquo;],[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;0808\u0026rdquo;],[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;0829\u0026rdquo;],[\u0026ldquo;e\u0026rdquo;,\u0026ldquo;0215\u0026rdquo;],[\u0026ldquo;d\u0026rdquo;,\u0026ldquo;1508\u0026rdquo;],[\u0026ldquo;d\u0026rdquo;,\u0026ldquo;1444\u0026rdquo;],[\u0026ldquo;d\u0026rdquo;,\u0026ldquo;1410\u0026rdquo;],[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;0809\u0026rdquo;]]\n输出：[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;d\u0026rdquo;]\n解释：\u0026ldquo;c\u0026rdquo; 在时间段 [08:08, 09:07] 内有三条访问记录，时间分别为 08:08 、08:09 和\n08:29 。 \u0026ldquo;d\u0026rdquo; 在时间段 [14:10, 15:09] 内有三条访问记录，时间分别为 14:10 、14:44\n和 15:08 。 然而，\u0026ldquo;e\u0026rdquo; 只有一条访问记录，因此不能包含在答案中，最终答案是\n[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;d\u0026rdquo;] 。\n示例 3：\n输入：access_times =\n[[\u0026ldquo;cd\u0026rdquo;,\u0026ldquo;1025\u0026rdquo;],[\u0026ldquo;ab\u0026rdquo;,\u0026ldquo;1025\u0026rdquo;],[\u0026ldquo;cd\u0026rdquo;,\u0026ldquo;1046\u0026rdquo;],[\u0026ldquo;cd\u0026rdquo;,\u0026ldquo;1055\u0026rdquo;],[\u0026ldquo;ab\u0026rdquo;,\u0026ldquo;1124\u0026rdquo;],[\u0026ldquo;ab\u0026rdquo;,\u0026ldquo;1120\u0026rdquo;]]\n输出：[\u0026ldquo;ab\u0026rdquo;,\u0026ldquo;cd\u0026rdquo;]\n解释：\u0026ldquo;ab\u0026quot;在时间段 [10:25, 11:24] 内有三条访问记录，时间分别为 10:25 、11:20 和\n11:24 。 \u0026ldquo;cd\u0026rdquo; 在时间段 [10:25, 11:24] 内有三条访问记录，时间分别为 10:25 、10:46\n和 10:55 。 因此，答案是 [\u0026ldquo;ab\u0026rdquo;,\u0026ldquo;cd\u0026rdquo;] 。\n提示：\n1 \u0026lt;= access_times.length \u0026lt;= 100\naccess_times[i].length == 2\n1 \u0026lt;= access_times[i][0].length \u0026lt;= 10\naccess_times[i][0] 仅由小写英文字母组成。\naccess_times[i][1].length == 4\naccess_times[i][1] 采用24小时制表示时间。\naccess_times[i][1] 仅由数字 \u0026lsquo;0\u0026rsquo; 到 \u0026lsquo;9\u0026rsquo; 组成。\n// @lc code=start\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class Solution { public: vector\u0026lt;string\u0026gt; findHighAccessEmployees(vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; \u0026amp;access_times) { unordered_map\u0026lt;string, vector\u0026lt;int\u0026gt;\u0026gt; mp; for (auto vec : access_times) { auto name = vec[0]; auto ss = vec[1]; auto d = str2int(ss.substr(0, 2)) *60 + str2int(ss.substr(2)); mp[name].push_back(d); } vector\u0026lt;string\u0026gt; res; vector\u0026lt;int\u0026gt; sum(25* 60); for (auto [k, vec] : mp) { fill(sum.begin(), sum.end(), 0); int n = sum.size(); for (int k : vec) { sum[k] += 1; if (k + 60 \u0026lt; n) sum[k + 60]--; } int all = 0; for (int i = 0; i \u0026lt; n; i++) { all += sum[i]; if (all \u0026gt;= 3) { res.push_back(k); break; } } } return res; } int str2int(string a) { int k = 0; for (int i = 0, n = a.size(); i \u0026lt; n; i++) { k = k * 10 + (a[i] - \u0026#39;0\u0026#39;); } return k; } bool cmp(int a, int b) { return a \u0026lt; b; } }; // @lc code=end int main() { # ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2933] 高访问员工\u0026#34; \u0026lt;\u0026lt; endl; # endif Solution k; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; res = {{\u0026#34;a\u0026#34;, \u0026#34;0549\u0026#34;}, {\u0026#34;b\u0026#34;, \u0026#34;0457\u0026#34;}, {\u0026#34;a\u0026#34;, \u0026#34;0532\u0026#34;}, {\u0026#34;a\u0026#34;, \u0026#34;0621\u0026#34;}, {\u0026#34;b\u0026#34;, \u0026#34;0540\u0026#34;}}; // cout \u0026lt;\u0026lt; \u0026lt;\u0026lt; endl; printa(k.findHighAccessEmployees(res)); return 0; } ","date":"2024-01-13T21:42:51+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E5%B7%AE%E5%88%86/lc.2933.%E9%AB%98%E8%AE%BF%E9%97%AE%E5%91%98%E5%B7%A5/","tags":["差分"],"title":"lc.2933.高访问员工"},{"categories":["树形dp"],"contents":" leetcode 2920.收集所有金币可获得的最大积分 algorithms\nHard (41.70%)\nLikes: 10\nDislikes: 0\nTotal Accepted: 2.7K\nTotal Submissions: 6.5K\nTestcase Example: \u0026lsquo;[[0,1],[1,2],[2,3]]\\n[10,10,3,3]\\n5\u0026rsquo;\n有一棵由 n 个节点组成的无向树，以 0 为根节点，节点编号从 0 到 n - 1 。给你一个长度为 n - 1 的二维 整数 数组 edges\n，其中 edges[i] = [ai, bi] 表示在树上的节点 ai 和 bi 之间存在一条边。另给你一个下标从 0 开始、长度为 n 的数组\ncoins 和一个整数 k ，其中 coins[i] 表示节点 i 处的金币数量。\n从根节点开始，你必须收集所有金币。要想收集节点上的金币，必须先收集该节点的祖先节点上的金币。\n节点 i 上的金币可以用下述方法之一进行收集：\n收集所有金币，得到共计 coins[i] - k 点积分。如果 coins[i] - k 是负数，你将会失去 abs(coins[i] - k)\n点积分。\n收集所有金币，得到共计 floor(coins[i] / 2) 点积分。如果采用这种方法，节点 i 子树中所有节点 j 的金币数 coins[j]\n将会减少至 floor(coins[j] / 2) 。\n返回收集 所有 树节点的金币之后可以获得的最大积分。\n示例 1：\n输入：edges = [[0,1],[1,2],[2,3]], coins = [10,10,3,3], k = 5\n输出：11\n解释：\n使用第一种方法收集节点 0 上的所有金币。总积分 = 10 - 5 = 5 。\n使用第一种方法收集节点 1 上的所有金币。总积分 = 5 + (10 - 5) = 10 。\n使用第二种方法收集节点 2 上的所有金币。所以节点 3 上的金币将会变为 floor(3 / 2) = 1 ，总积分 = 10 + floor(3 /\n2) = 11 。\n使用第二种方法收集节点 3 上的所有金币。总积分 = 11 + floor(1 / 2) = 11.\n可以证明收集所有节点上的金币能获得的最大积分是 11 。\n示例 2：\n⁠\n输入：edges = [[0,1],[0,2]], coins = [8,4,4], k = 0\n输出：16\n解释：\n使用第一种方法收集所有节点上的金币，因此，总积分 = (8 - 0) + (4 - 0) + (4 - 0) = 16 。\n提示：\nn == coins.length\n2 \u0026lt;= n \u0026lt;= 10^5\n0 \u0026lt;= coins[i] \u0026lt;= 10^4\nedges.length == n - 1\n0 \u0026lt;= edges[i][0], edges[i][1] \u0026lt; n\n0 \u0026lt;= k \u0026lt;= 10^4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // @lc code=start #define ll int class Solution { public: int maximumPoints(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, vector\u0026lt;int\u0026gt;\u0026amp; coins, int k) { int n = coins.size(); g = vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;(n) ; this-\u0026gt;k = k; for(auto w: edges){ g[w[0]].push_back(w[1]); g[w[1]].push_back(w[0]); } memo = vector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt;(n,vector\u0026lt;ll\u0026gt; (14,-1)) ; return dfs(0,0,-1,coins); } vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;g ; vector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; memo; int k; ll dfs(int i, int j,int fa,vector\u0026lt;int\u0026gt; \u0026amp;coins) { // if (i == g.size()) return 0; auto p = memo[i][j]; if(p!=-1) return p; ll res1 = (coins[i] \u0026gt;\u0026gt; j) - k ; ll res2 = coins[i] \u0026gt;\u0026gt; (j+1); for (auto ne: g[i]) { if (ne == fa) continue; res1 += dfs(ne,j,i,coins); if (j \u0026lt; 13) { //2 \u0026lt;= n \u0026lt;= 10^5 , log(1e5) ~= 12 ,只要超过或者12，那么 所有的数一定会变成0 res2 += dfs(ne,j+1,i,coins); } } memo[i][j] = max(res1,res2); return memo[i][j]; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2920] 收集所有金币可获得的最大积分\u0026#34; \u0026lt;\u0026lt; endl; #endif vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; edges = {{0,1},{1,2},{2,3}}; vector\u0026lt;int\u0026gt; coins = {10,10,3,3}; int k = 5; Solution b; cout\u0026lt;\u0026lt; to_string(1e4)\u0026lt;\u0026lt;\u0026#34; \u0026#34; \u0026lt;\u0026lt; log(1e4)\u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; b.maximumPoints(edges,coins,k)\u0026lt;\u0026lt;endl; return 0; } ","date":"2023-12-31T17:25:20+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E6%A0%91%E5%BD%A2dp/lc.2920.%E6%94%B6%E9%9B%86%E6%89%80%E6%9C%89%E9%87%91%E5%B8%81%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%A7%AF%E5%88%86/","tags":["树形dp"],"title":"lc.2920.收集所有金币可获得的最大积分"},{"categories":["记忆化搜索"],"contents":" leetcode 2919.使数组变美的最小增量运算数 algorithms\nMedium (39.07%)\nLikes: 34\nDislikes: 0\nTotal Accepted: 4.1K\nTotal Submissions: 10.6K\nTestcase Example: \u0026lsquo;[2,3,0,0,2]\\n4\u0026rsquo;\n给你一个下标从 0 开始、长度为 n 的整数数组 nums ，和一个整数 k 。\n你可以执行下述 递增 运算 任意 次（可以是 0 次）：\n从范围 [0, n - 1] 中选择一个下标 i ，并将 nums[i] 的值加 1 。\n如果数组中任何长度 大于或等于 3 的子数组，其 最大 元素都大于或等于 k ，则认为数组是一个 美丽数组 。\n以整数形式返回使数组变为 美丽数组 需要执行的 最小 递增运算数。\n子数组是数组中的一个连续 非空 元素序列。\n示例 1：\n输入：nums = [2,3,0,0,2], k = 4\n输出：3\n解释：可以执行下述递增运算，使 nums 变为美丽数组：\n选择下标 i = 1 ，并且将 nums[1] 的值加 1 -\u0026gt; [2,4,0,0,2] 。\n选择下标 i = 4 ，并且将 nums[4] 的值加 1 -\u0026gt; [2,4,0,0,3] 。\n选择下标 i = 4 ，并且将 nums[4] 的值加 1 -\u0026gt; [2,4,0,0,4] 。\n长度大于或等于 3 的子数组为 [2,4,0], [4,0,0], [0,0,4], [2,4,0,0], [4,0,0,4], [2,4,0,0,4]\n。\n在所有子数组中，最大元素都等于 k = 4 ，所以 nums 现在是美丽数组。\n可以证明无法用少于 3 次递增运算使 nums 变为美丽数组。\n因此，答案为 3 。\n示例 2：\n输入：nums = [0,1,3,3], k = 5\n输出：2\n解释：可以执行下述递增运算，使 nums 变为美丽数组：\n选择下标 i = 2 ，并且将 nums[2] 的值加 1 -\u0026gt; [0,1,4,3] 。\n选择下标 i = 2 ，并且将 nums[2] 的值加 1 -\u0026gt; [0,1,5,3] 。\n长度大于或等于 3 的子数组为 [0,1,5]、[1,5,3]、[0,1,5,3] 。\n在所有子数组中，最大元素都等于 k = 5 ，所以 nums 现在是美丽数组。\n可以证明无法用少于 2 次递增运算使 nums 变为美丽数组。\n因此，答案为 2 。\n示例 3：\n输入：nums = [1,1,2], k = 1\n输出：0\n解释：在这个示例中，只有一个长度大于或等于 3 的子数组 [1,1,2] 。\n其最大元素 2 已经大于 k = 1 ，所以无需执行任何增量运算。\n因此，答案为 0 。\n提示：\n3 \u0026lt;= n == nums.length \u0026lt;= 10^5\n0 \u0026lt;= nums[i] \u0026lt;= 10^9\n0 \u0026lt;= k \u0026lt;= 10^9\n解题思路和教程 解题思路参考 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // @lc code=start class Solution { /** 思路： 每个元素选或者不选 dfs(i,j) 表示nums[i] 右边有 j个数字没选 选择： dfs(i,j) = dfs(i-1,0) + max(k - nums[i], 0) 不选： dfs(i,j) = dfs(i-1,j+1) 从右到左遍历： 入口： dfs(n-1,0) */ public: #define ll long long long long minIncrementOperations(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); memo = vector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; (n,vector\u0026lt;ll\u0026gt; (3,-1) ) ; return dfs(nums,n-1,0,k); } // dp: // dp[i+1][j] = dp[i][0] + max(k - nums[i],0) // dp[i+1][j] = dp[i][j+1] // 递推法 vector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; memo; ll dfs(vector\u0026lt;int\u0026gt; \u0026amp;nums ,int i,int j,int k) { if (i\u0026lt;0) return 0; if (memo[i][j] != -1) return memo[i][j]; // 选择 ll res= dfs(nums,i-1,0,k) + max(k - nums[i],0); if(j \u0026lt; 2) { // 不选择 res = min(res,dfs(nums,i-1,j+1,k)); } memo[i][j] = res; return res; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2919] 使数组变美的最小增量运算数\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; vector\u0026lt;int\u0026gt; a = {0,1,3,3}; print(k.minIncrementOperations(a,5)); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { /** 思路： 每个元素选或者不选 dfs(i,j) 表示nums[i] 右边有 j个数字没选 选择： dfs(i,j) = dfs(i-1,0) + max(k - nums[i], 0) 不选： dfs(i,j) = dfs(i-1,j+1) 从右到左遍历： 入口： dfs(n-1,0) */ public: #define ll long long long long minIncrementOperations(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { // int n = nums.size(); // memo = vector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; (n,vector\u0026lt;ll\u0026gt; (3,-1) ) ; // return dfs(nums,n-1,0,k); int n = nums.size(); // memo = vector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; (n,vector\u0026lt;ll\u0026gt; (3,-1) ) ; // return dfs(nums,n-1,0,k); vector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; dp(n+1,vector\u0026lt;ll\u0026gt; (3,0)) ; for(int i=0;i\u0026lt;n;i++) { for (int j=0 ;j\u0026lt;3 ; j++) { dp[i+1][j] = dp[i][0] + max(k-nums[i],0); if (j\u0026lt;2) { dp[i+1][j] = min(dp[i+1][j],dp[i][j+1]); } } } return dp[n][0]; } // vector\u0026lt;vector\u0026lt;ll\u0026gt; \u0026gt; memo; // ll dfs(vector\u0026lt;int\u0026gt; \u0026amp;nums ,int i,int j,int k) { // if (i\u0026lt;0) return 0; // if (memo[i][j] != -1) return memo[i][j]; // // 选择 // ll res= dfs(nums,i-1,0,k) + max(k - nums[i],0); // if(j \u0026lt; 2) { // // 不选择 // res = min(res,dfs(nums,i-1,j+1,k)); // } // memo[i][j] = res; // return res; // } }; ","date":"2023-12-31T15:26:30+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/lc.2919.%E4%BD%BF%E6%95%B0%E7%BB%84%E5%8F%98%E7%BE%8E%E7%9A%84%E6%9C%80%E5%B0%8F%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E6%95%B0/","tags":["记忆化搜索"],"title":"lc.2919.使数组变美的最小递增运算数"},{"categories":["代办事项"],"contents":"工作技巧总结 番茄钟工作法 番茄工作法（意大利语：Pomodoro Technique）是一种简单易行的时间管理方法，它是由意大利人弗朗西斯科·西里洛于1992年创立的一种时间管理方法。在番茄工作法一个个短短的25分钟内，收获的不仅仅是效率，还会有意想不到的成就感。\n执行番茄工作法的基本要求：\n1）番茄钟不可分割；\n2）耗时超过6个番茄钟的任务需要再拆分；\n3）每个番茄钟开始后就不能暂停，一旦暂停，只能作废重来；\n4）若一项活动花费时间很短，不到一个番茄钟，可与其他活动合并；\n5）番茄工作法不用于假期和休息期的活动。\n番茄工作法划分工作和休息时间，将时间划分为小块，有利于提高工作和休息的效率，提高时间的感知和掌控。\n利用整个番茄时间，专注于某一段时间，减少打断，提高时间的感知和掌控。\n一个人番茄时间为25分钟工作+5分钟休息，4个番茄时间为一轮，之后休息30分钟（如图3所示）。\n时间管理软件 自己做课代表，10个推荐，等于更新了10期，对吧？\nhttps://juejin.cn/post/7085510669616807966#heading-2 ","date":"2023-12-30T17:37:55+08:00","permalink":"https://lyr-2000.github.io/code/post/%E4%BB%A3%E5%8A%9E%E4%BA%8B%E9%A1%B9/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/","tags":["代办事项"],"title":"时间管理"},{"categories":["逻辑题"],"contents":" leetcode 2918.数组的最小相等和 algorithms\nMedium (35.36%)\nLikes: 8\nDislikes: 0\nTotal Accepted: 5.3K\nTotal Submissions: 15.1K\nTestcase Example: \u0026lsquo;[3,2,0,1,0]\\n[6,5,0]\u0026rsquo;\n给你两个由正整数和 0 组成的数组 nums1 和 nums2 。\n你必须将两个数组中的 所有 0 替换为 严格 正整数，并且满足两个数组中所有元素的和 相等 。\n返回 最小 相等和 ，如果无法使两数组相等，则返回 -1 。\n示例 1：\n输入：nums1 = [3,2,0,1,0], nums2 = [6,5,0]\n输出：12\n解释：可以按下述方式替换数组中的 0 ：\n用 2 和 4 替换 nums1 中的两个 0 。得到 nums1 = [3,2,2,1,4] 。 用 1 替换 nums2 中的一个 0 。得到 nums2 = [6,5,1] 。\n两个数组的元素和相等，都等于 12 。可以证明这是可以获得的最小相等和。 示例 2：\n输入：nums1 = [2,0,2,0], nums2 = [1,4]\n输出：-1\n解释：无法使两个数组的和相等。\n提示：\n1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 10^5\n0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 10^6\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // @lc code=start #define ll long long class Solution { public: struct E { ll l; ll r; int cnt; }; E counte(vector\u0026lt;int\u0026gt; \u0026amp;a) { E e = {0,0,0}; for(int u:a) { int f = u==0; if(f) e.cnt++; e.l+=u; } e.l = e.l+e.cnt; if(e.cnt) e.r = LONG_MAX; else e.r = e.l; return e; } long long minSum(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { auto a = counte(nums1); auto b = counte(nums2); if(a.r \u0026lt; b.l || b.r \u0026lt; a.l) { // 无交集 return -1; } auto L = max(a.l,b.l); return L; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2918] 数组的最小相等和\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; vector\u0026lt;int\u0026gt; a = {3,2,0,1,0} ; vector\u0026lt;int\u0026gt; b = {6,5,0} ; cout \u0026lt;\u0026lt; k.minSum(a,b)\u0026lt;\u0026lt;endl; return 0; } ","date":"2023-12-30T17:28:08+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/%E9%80%BB%E8%BE%91%E9%A2%98/lc.2918.%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9B%B8%E7%AD%89%E5%92%8C/","tags":["逻辑题"],"title":"lc.2918.数组的最小相等和"},{"categories":["位运算"],"contents":" [2917] 找出数组中的 K-or 值 algorithms\nEasy (70.73%)\nLikes: 5\nDislikes: 0\nTotal Accepted: 5.5K\nTotal Submissions: 7.8K\nTestcase Example: \u0026lsquo;[7,12,9,8,9,15]\\n4\u0026rsquo;\n给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。\nnums 中的 K-or 是一个满足以下条件的非负整数：\n只有在 nums 中，至少存在 k 个元素的第 i 位值为 1 ，那么 K-or 中的第 i 位的值才是 1 。\n返回 nums 的 K-or 值。\n注意 ：对于整数 x ，如果 (2^i AND x) == 2^i ，则 x 中的第 i 位值为 1 ，其中 AND 为按位与运算符。\n示例 1：\n输入：nums = [7,12,9,8,9,15], k = 4\n输出：9\n解释：nums[0]、nums[2]、nums[4] 和 nums[5] 的第 0 位的值为 1 。\nnums[0] 和 nums[5] 的第 1 位的值为 1 。\nnums[0]、nums[1] 和 nums[5] 的第 2 位的值为 1 。\nnums[1]、nums[2]、nums[3]、nums[4] 和 nums[5] 的第 3 位的值为 1 。\n只有第 0 位和第 3 位满足数组中至少存在 k 个元素在对应位上的值为 1 。因此，答案为 2^0 + 2^3 = 9 。\n示例 2：\n输入：nums = [2,12,1,11,4,5], k = 6\n输出：0\n解释：因为 k == 6 == nums.length ，所以数组的 6-or 等于其中所有元素按位与运算的结果。因此，答案为 2 AND 12 AND\n1 AND 11 AND 4 AND 5 = 0 。\n示例 3：\n输入：nums = [10,8,5,9,11,6,8], k = 1\n输出：15\n解释：因为 k == 1 ，数组的 1-or 等于其中所有元素按位或运算的结果。因此，答案为 10 OR 8 OR 5 OR 9 OR 11 OR 6\nOR 8 = 15 。\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 50\n0 \u0026lt;= nums[i] \u0026lt; 2^31\n1 \u0026lt;= k \u0026lt;= nums.length\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // @lc code=start class Solution { public: int findKOr(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { vector\u0026lt;int\u0026gt; cnt(33,0); int n = nums.size(); for (int i=0;i\u0026lt;n;i++) { int x = nums[i]; int j=0; while (j\u0026lt;=31) { if((x\u0026gt;\u0026gt;j)\u0026amp;1) cnt[j]++; j++; } } int mask=0; for (int i=0;i\u0026lt;31;i++) { if (cnt[i] \u0026gt;=k) { mask |= (1\u0026lt;\u0026lt;i); } } #ifdef debug printa(nums); printa(cnt); printn(itoa2(mask)); #endif return mask; } }; // @lc code=end int main() { #ifdef debug cout \u0026lt;\u0026lt; \u0026#34; * [2917] 找出数组中的 K-or 值\u0026#34; \u0026lt;\u0026lt; endl; #endif Solution k; vector\u0026lt;int\u0026gt; x = {7,12,9,8,9,15}; cout \u0026lt;\u0026lt; k.findKOr(x,4)\u0026lt;\u0026lt;endl; return 0; } ","date":"2023-12-30T16:52:50+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/lc.2917.%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84-k-or-%E5%80%BC/","tags":["位运算"],"title":"lc.2917.找出数组中的-k-or-值"},{"categories":["树状数组优化"],"contents":"[2926] 平衡子序列的最大和\nhttps://leetcode.cn/problems/maximum-balanced-subsequence-sum/description/ algorithms\nHard (37.65%)\nLikes: 17\nDislikes: 0\nTotal Accepted: 2.7K\nTotal Submissions: 7.1K\nTestcase Example: \u0026lsquo;[3,3,5,6]\u0026rsquo;\n给你一个下标从 0 开始的整数数组 nums 。\nnums 一个长度为 k 的 子序列 指的是选出 k 个 下标 i0 \u0026lt; i1 \u0026lt; \u0026hellip; \u0026lt; ik-1 ，如果这个子序列满足以下条件，我们说它是\n平衡的 ：\n对于范围 [1, k - 1] 内的所有 j ，nums[ij] - nums[ij-1] \u0026gt;= ij - ij-1 都成立。\nnums 长度为 1 的 子序列 是平衡的。\n请你返回一个整数，表示 nums 平衡 子序列里面的 最大元素和 。\n一个数组的 子序列 指的是从原数组中删除一些元素（也可能一个元素也不删除）后，剩余元素保持相对顺序得到的 非空 新数组。\n示例 1：\n输入：nums = [3,3,5,6]\n输出：14\n解释：这个例子中，选择子序列 [3,5,6] ，下标为 0 ，2 和 3 的元素被选中。\nnums[2] - nums[0] \u0026gt;= 2 - 0 。\nnums[3] - nums[2] \u0026gt;= 3 - 2 。\n所以，这是一个平衡子序列，且它的和是所有平衡子序列里最大的。\n包含下标 1 ，2 和 3 的子序列也是一个平衡的子序列。\n最大平衡子序列和为 14 。\n示例 2：\n输入：nums = [5,-1,-3,8]\n输出：13\n解释：这个例子中，选择子序列 [5,8] ，下标为 0 和 3 的元素被选中。\nnums[3] - nums[0] \u0026gt;= 3 - 0 。\n所以，这是一个平衡子序列，且它的和是所有平衡子序列里最大的。\n最大平衡子序列和为 13 。\n示例 3：\n输入：nums = [-2,-1]\n输出：-1\n解释：这个例子中，选择子序列 [-1] 。\n这是一个平衡子序列，而且它的和是 nums 所有平衡子序列里最大的。\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5\n-10^9 \u0026lt;= nums[i] \u0026lt;= 10^9\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 // @lc code=start class Solution { /* nums[i] - i \u0026gt;= nums[j] -j b[i] = nums[i] - i 求 b[i] 是递增的序列 即转化为 求最长递增子序列问题 f[i] = 以下标i结尾的子序列，对应 nums的元素合的最大值 f[i] = f[j] + nums[i] j 满足 b[j] \u0026lt;= b[i] and j\u0026lt;i 在从左到右 遍历的情况下：一定满足 j\u0026lt;i 只要要 b[j] \u0026lt;= b[i] 即可 用若干个小区间合并为一个大区间 树状数组模板 【树形 DP + 树状数组优化 DP【力扣周赛 370】】 【精准空降到 44:54】 \u0026lt;https://www.bilibili.com/video/BV1Fc411R7xA/?share_source=copy_web\u0026amp;vd_source=74fd53b3c51a4a795f4749ab033306f4\u0026amp;t=2694\u0026gt; */ public: #define ll long long #define lowbit(x) x \u0026amp; (-x) vector\u0026lt;ll\u0026gt; tree; void update(int i,ll val) { while (i \u0026amp;\u0026amp; i\u0026lt;tree.size()) { tree[i] = max(tree[i],val); i+= i \u0026amp; -i; } } long long premax(int i) { ll mx= INT_MIN; while (i\u0026gt;0) { mx = max(mx,tree[i]); i -= i \u0026amp; -i; } return mx; } /* 数组a: -3 6 -1 2 转化为 rank数组： 1 4 2 3 例如 6是最大的排在第 4位, 通过离散化映射下标，就能使用数组了 */ long long maxBalancedSubsequenceSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { auto b = remap0(nums) ; // for (int i=0;)r #ifdef printa printa(nums); printa(b); #endif tree.resize(b.size()+1,0); ll ans= -1e9; int n = nums.size(); for (int i=0;i\u0026lt;n;i++) { int rank = lower_bound(b.begin(),b.end(),nums[i] - i) - b.begin()+1; // ll curmax = max(premax(rank) + (nums[i] ), (ll) nums[i]); ll curmax = max(premax(rank),(ll)0) + nums[i]; update(rank,curmax); ans = max(ans,curmax); } return ans; } vector\u0026lt;int\u0026gt; remap0(vector\u0026lt;int\u0026gt; \u0026amp;nums) { auto b = nums; int n = nums.size(); for (int i=0;i\u0026lt;n;i++) { b[i] -= i; } sort(b.begin(),b.end()); b.erase( unique(b.begin(),b.end()),b.end()); return b; } vector\u0026lt;int\u0026gt; remap(vector\u0026lt;int\u0026gt; \u0026amp;nums ) { vector\u0026lt;int\u0026gt; b = nums; int n = nums.size(); for (int i=0;i\u0026lt;n;i++) { b[i] -= i; } sort(b.begin(),b.end()); unordered_set\u0026lt;int\u0026gt; se; vector\u0026lt;int\u0026gt; news; for (int k:b) { if(!se.count(k)) { se.insert(k); news.push_back(k); } } return news; } }; // @lc code=end int main() { cout \u0026lt;\u0026lt; \u0026#34; * [2926] 平衡子序列的最大和\u0026#34; \u0026lt;\u0026lt; endl; Solution k; vector\u0026lt;int\u0026gt; a = {3,3,5,6}; cout \u0026lt;\u0026lt; k.maxBalancedSubsequenceSum(a)\u0026lt;\u0026lt;endl; return 0; } [[....\\数据结构\\树状数组\\树状数组基础.md]]\n","date":"2023-12-30T16:22:49+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96/lc.2926.%E5%B9%B3%E8%A1%A1%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/","tags":["树状数组优化"],"title":"lc.2926.平衡子序列的最大和"},{"categories":["递归"],"contents":"[1625] 执行操作后字典序最小的字符串\nhttps://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/description/ algorithms\nMedium (66.67%)\nLikes: 116\nDislikes: 0\nTotal Accepted: 17.5K\nTotal Submissions: 26.3K\nTestcase Example: \u0026lsquo;\u0026ldquo;5525\u0026rdquo;\\n9\\n2\u0026rsquo;\n给你一个字符串 s 以及两个整数 a 和 b 。其中，字符串 s 的长度为偶数，且仅由数字 0 到 9 组成。\n你可以在 s 上按任意顺序多次执行下面两个操作之一：\n累加：将 a 加到 s 中所有下标为奇数的元素上（下标从 0 开始）。数字一旦超过 9 就会变成 0，如此循环往复。例如，s = \u0026ldquo;3456\u0026rdquo; 且 a\n= 5，则执行此操作后 s 变成 \u0026ldquo;3951\u0026rdquo;。\n轮转：将 s 向右轮转 b 位。例如，s = \u0026ldquo;3456\u0026rdquo; 且 b = 1，则执行此操作后 s 变成 \u0026ldquo;6345\u0026rdquo;。\n请你返回在 s 上执行上述操作任意次后可以得到的 字典序最小 的字符串。\n如果两个字符串长度相同，那么字符串 a 字典序比字符串 b 小可以这样定义：在 a 和 b 出现不同的第一个位置上，字符串 a\n中的字符出现在字母表中的时间早于 b 中的对应字符。例如，\u0026ldquo;0158” 字典序比 \u0026ldquo;0190\u0026rdquo; 小，因为不同的第一个位置是在第三个字符，显然 \u0026lsquo;5\u0026rsquo;\n出现在 \u0026lsquo;9\u0026rsquo; 之前。\n示例 1：\n输入：s = \u0026ldquo;5525\u0026rdquo;, a = 9, b = 2\n输出：\u0026ldquo;2050\u0026rdquo;\n解释：执行操作如下：\n初态：\u0026ldquo;5525\u0026rdquo;\n轮转：\u0026ldquo;2555\u0026rdquo;\n累加：\u0026ldquo;2454\u0026rdquo;\n累加：\u0026ldquo;2353\u0026rdquo;\n轮转：\u0026ldquo;5323\u0026rdquo;\n累加：\u0026ldquo;5222\u0026rdquo;\n累加：\u0026ldquo;5121\u0026rdquo;\n轮转：\u0026ldquo;2151\u0026rdquo;\n累加：\u0026ldquo;2050\u0026quot;​​​​​\n无法获得字典序小于 \u0026ldquo;2050\u0026rdquo; 的字符串。\n示例 2：\n输入：s = \u0026ldquo;74\u0026rdquo;, a = 5, b = 1\n输出：\u0026ldquo;24\u0026rdquo;\n解释：执行操作如下：\n初态：\u0026ldquo;74\u0026rdquo;\n轮转：\u0026ldquo;47\u0026rdquo;\n累加：\u0026ldquo;42\u0026rdquo;\n轮转：\u0026ldquo;24\u0026quot;​​​​​\n无法获得字典序小于 \u0026ldquo;24\u0026rdquo; 的字符串。\n示例 3：\n输入：s = \u0026ldquo;0011\u0026rdquo;, a = 4, b = 2\n输出：\u0026ldquo;0011\u0026rdquo;\n解释：无法获得字典序小于 \u0026ldquo;0011\u0026rdquo; 的字符串。\n提示：\n2 \u0026lt;= s.length \u0026lt;= 100\ns.length 是偶数\ns 仅由数字 0 到 9 组成\n1 \u0026lt;= a \u0026lt;= 9\n1 \u0026lt;= b \u0026lt;= s.length - 1\n字符串解题思路 直接深度搜索，把所有状态存到 set 里面，然后比较\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // @lc code=start class Solution { public: string ans=\u0026#34;\u0026#34;; string findLexSmallestString(string s, int a, int b) { int n = s.size(); string ss(n,\u0026#39;9\u0026#39;); ans = ss; dfs(s,a,b); return ans; } unordered_set\u0026lt;string\u0026gt; se; string rotate(string s,int b) { string news = s+s; string xx = news.substr(b,s.size()); return xx; } string adda(string s,int a) { int n= s.size(); for (int i=1;i\u0026lt;n;i+=2) { int k = s[i] - \u0026#39;0\u0026#39;; int res = (k+a) % 10; s[i] = res + \u0026#39;0\u0026#39;; } return s; } void dfs(string s,int a,int b) { if (se.count(s)) { return ; } if (s \u0026lt; ans) { ans = s; } se.insert(s); string l = rotate(s,b); string r = adda(s,a); dfs(l,a,b); dfs(r,a,b); } }; // @lc code=end int main() { cout \u0026lt;\u0026lt; \u0026#34;[1625] 执行操作后字典序最小的字符串\u0026#34; \u0026lt;\u0026lt; endl; Solution k; // 初态：\u0026#34;5525\u0026#34; // 轮转：\u0026#34;2555\u0026#34; // cout \u0026lt;\u0026lt; k.rotate(\u0026#34;5525\u0026#34;,2) \u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; k.findLexSmallestString(\u0026#34;5525\u0026#34;,9,2) \u0026lt;\u0026lt;endl; return 0; } ","date":"2023-12-30T13:54:29+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E9%80%92%E5%BD%92/lc.1625.%E6%89%A7%E8%A1%8C%E5%88%9B%E4%BD%9C%E5%90%8E%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","tags":["递归"],"title":"lc.1625.执行创作后字典序最小的字符串"},{"categories":["树形dp"],"contents":"[2925] 在树上执行操作以后得到的最大分数\nhttps://leetcode.cn/problems/maximum-score-after-applying-operations-on-a-tree/description/ algorithms\nMedium (47.02%)\nLikes: 22\nDislikes: 0\nTotal Accepted: 3.8K\nTotal Submissions: 8.1K\nTestcase Example: \u0026lsquo;[[0,1],[0,2],[0,3],[2,4],[4,5]]\\n[5,2,5,2,1,1]\u0026rsquo;\n*\n有一棵 n 个节点的无向树，节点编号为 0 到 n - 1 ，根节点编号为 0 。给你一个长度为 n - 1 的二维整数数组 edges\n表示这棵树，其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 有一条边。\n同时给你一个长度为 n 下标从 0 开始的整数数组 values ，其中 values[i] 表示第 i 个节点的值。\n一开始你的分数为 0 ，每次操作中，你将执行：\n选择节点 i 。\n将 values[i] 加入你的分数。\n将 values[i] 变为 0 。\n如果从根节点出发，到任意叶子节点经过的路径上的节点值之和都不等于 0 ，那么我们称这棵树是 健康的 。\n你可以对这棵树执行任意次操作，但要求执行完所有操作以后树是 健康的 ，请你返回你可以获得的 最大分数 。\n示例 1：\n输入：edges = [[0,1],[0,2],[0,3],[2,4],[4,5]], values = [5,2,5,2,1,1]\n输出：11\n解释：我们可以选择节点 1 ，2 ，3 ，4 和 5 。根节点的值是非 0 的。所以从根出发到任意叶子节点路径上节点值之和都不为 0\n。所以树是健康的。你的得分之和为 values[1] + values[2] + values[3] + values[4] + values[5] =\n11 。\n11 是你对树执行任意次操作以后可以获得的最大得分之和。\n示例 2：\n输入：edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [20,10,9,7,4,3,5]\n输出：40\n解释：我们选择节点 0 ，2 ，3 和 4 。\n从 0 到 4 的节点值之和为 10 。 从 0 到 3 的节点值之和为 10 。 从 0 到 5 的节点值之和为 3 。 从 0 到 6 的节点值之和为 5 。\n所以树是健康的。你的得分之和为 values[0] + values[2] + values[3] + values[4] = 40 。\n40 是你对树执行任意次操作以后可以获得的最大得分之和。 提示：\n2 \u0026lt;= n \u0026lt;= 2 * 10^4\nedges.length == n - 1\nedges[i].length == 2\n0 \u0026lt;= ai, bi \u0026lt; n\nvalues.length == n\n1 \u0026lt;= values[i] \u0026lt;= 10^9\n输入保证 edges 构成一棵合法的树。\n// @lc code=start\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 # define ll long long //思路： 在固定和不变的情况下，求最大分数就等价于求出最小的分数 // 要求出最小的分数，尽量保证 每个节点不选 /** dfs(x) = 对于一个 x为根的子树，如果这个树是健康的，损失的最小分数是多少 树形dp:模板题 */ class Solution { public: long long maximumScoreAfterOperations(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, vector\u0026lt;int\u0026gt;\u0026amp; values) { int n = values.size(); ll sum = 0; for (int u:values) sum+=u ; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g(n,vector\u0026lt;int\u0026gt; (0)); g[0].push_back(-1); for (auto w: edges) { g[w[0]].push_back(w[1]); g[w[1]].push_back(w[0]); } return sum - dfs(0,-1,g,values); } long long dfs(int x,int fa,vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;g,vector\u0026lt;int\u0026gt; \u0026amp;val ) { if (g[x].size() == 1) return val[x]; ll lost = 0; for (int ne: g[x]) { if (ne != fa) { lost += dfs(ne,x,g,val); } } return min((ll)val[x],lost); } }; // @lc code=end int main() { cout \u0026lt;\u0026lt; \u0026#34; * [2925] 在树上执行操作以后得到的最大分数\u0026#34; \u0026lt;\u0026lt; endl; Solution k; return 0; } ","date":"2023-12-29T21:05:16+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E6%A0%91%E5%BD%A2dp/lc.2925.%E5%9C%A8%E6%A0%91%E4%B8%8A%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%90%8E%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/","tags":["树形dp"],"title":"lc.2925.在树上执行操作以后得到的最大分数"},{"categories":["代办事项"],"contents":" 博客优化 教程 hugo支持思维导图 教程 ","date":"2023-12-28T00:39:19+08:00","permalink":"https://lyr-2000.github.io/code/post/%E4%BB%A3%E5%8A%9E%E4%BA%8B%E9%A1%B9/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E4%BA%8B%E9%A1%B9/","tags":["代办事项"],"title":"博客优化事项"},{"categories":["算法"],"contents":"1. 读书学习计划 刷题教程 链接 时间安排 算法刷题 - 教程 b站教程链接 下午4点到晚上7点 Mysql 45讲 gitee教程 黄帝内经 b站教程链接 孟子 b站教程链接 荀子 b站教程链接 视频剪辑 b站教程链接 12点到下午4点 Spark b站教程链接 ","date":"2023-12-28T00:33:39+08:00","permalink":"https://lyr-2000.github.io/code/post/%E4%BB%A3%E5%8A%9E%E4%BA%8B%E9%A1%B9/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E5%BE%85%E5%8A%9E/","tags":["算法"],"title":"算法刷题教程总结"},{"categories":["度数"],"contents":"[2924] 找到冠军 II\nhttps://leetcode.cn/problems/find-champion-ii/description/ algorithms\nMedium (56.27%)\nLikes: 5\nDislikes: 0\nTotal Accepted: 5.4K\nTotal Submissions: 9.6K\nTestcase Example: \u0026lsquo;3\\n[[0,1],[1,2]]\u0026rsquo;\n一场比赛中共有 n 支队伍，按从 0 到 n - 1 编号。每支队伍也是\n有向无环图（DAG） 上的一个节点。\n给你一个整数 n 和一个下标从 0 开始、长度为 m 的二维整数数组 edges\n表示这个有向无环图，其中 edges[i] = [ui, vi] 表示图中存在一条从 ui 队到 vi\n队的有向边。\n从 a 队到 b 队的有向边意味着 a 队比 b 队 强 ，也就是 b 队比 a 队 弱 。\n在这场比赛中，如果不存在某支强于 a 队的队伍，则认为 a 队将会是 冠军 。\n如果这场比赛存在 唯一 一个冠军，则返回将会成为冠军的队伍。否则，返回 -1 。\n注意\n环 是形如 a1, a2, \u0026hellip;, an, an+1 的一个序列，且满足：节点 a1 与节点 an+1\n是同一个节点；节点 a1, a2, \u0026hellip;, an 互不相同；对于范围 [1, n] 中的每个 i\n，均存在一条从节点 ai 到节点 ai+1 的有向边。 有向无环图\n是不存在任何环的有向图。\n示例 1：\n输入：n = 3, edges = [[0,1],[1,2]]\n输出：0\n解释：1 队比 0 队弱。2 队比 1 队弱。所以冠军是 0 队。\n示例 2：\n输入：n = 4, edges = [[0,2],[1,3],[1,2]]\n输出：-1\n解释：2 队比 0 队和 1 队弱。3 队比 1 队弱。但是 1 队和 0\n队之间不存在强弱对比。所以答案是 -1 。\n提示：\n1 \u0026lt;= n \u0026lt;= 100\nm == edges.length\n0 \u0026lt;= m \u0026lt;= n*(n - 1) / 2\nedges[i].length == 2\n0 \u0026lt;= edge[i][j] \u0026lt;= n - 1\nedges[i][0] != edges[i][1]\n生成的输入满足：如果 a 队比 b 队强，就不存在 b 队比 a 队强\n生成的输入满足：如果 a 队比 b 队强，b 队比 c 队强，那么 a 队比 c 队强\n解题代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // @lc code=start class Solution { public: int findChampion(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;edges) { vector\u0026lt;int\u0026gt; indeg(n, 0); for (auto ve : edges) { auto ne = ve[1]; indeg[ne]++; // 入度+1 } int ans = -1; for (int i = 0; i \u0026lt; n; i++) { if (indeg[i] == 0) { if (ans != -1) return -1; ans = i; } } return ans; } }; // @lc code=end int main() { cout \u0026lt;\u0026lt; \u0026#34; * [2924] 找到冠军 II\u0026#34; \u0026lt;\u0026lt; endl; Solution k; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; v = {{0, 2}, {1, 3}, {1, 2}}; print(k.findChampion(4, v)); return 0; } ","date":"2023-12-28T00:21:17+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E5%BA%A6%E6%95%B0/lc.2924.%E6%89%BE%E5%88%B0%E5%86%A0%E5%86%9B/","tags":["度数"],"title":"lc.2924.找到冠军"},{"categories":["递归"],"contents":"[2193] 得到回文串的最少操作次数\nhttps://leetcode.cn/problems/minimum-number-of-moves-to-make-palindrome/description/ algorithms\nHard (49.26%)\nLikes: 53\nDislikes: 0\nTotal Accepted: 3.6K\nTotal Submissions: 7.3K\nTestcase Example: \u0026lsquo;\u0026ldquo;aabb\u0026rdquo;\u0026rsquo;\n给你一个只包含小写英文字母的字符串 s 。\n每一次 操作 ，你可以选择 s 中两个 相邻 的字符，并将它们交换。\n请你返回将 s 变成回文串的 最少操作次数 。\n注意 ，输入数据会确保 s 一定能变成一个回文串。\n示例 1：\n输入：s = \u0026ldquo;aabb\u0026rdquo;\n输出：2\n解释：\n我们可以将 s 变成 2 个回文串，\u0026ldquo;abba\u0026rdquo; 和 \u0026ldquo;baab\u0026rdquo; 。\n我们可以通过 2 次操作得到 \u0026ldquo;abba\u0026rdquo; ：\u0026ldquo;aabb\u0026rdquo; -\u0026gt; \u0026ldquo;abab\u0026rdquo; -\u0026gt; \u0026ldquo;abba\u0026rdquo; 。\n我们可以通过 2 次操作得到 \u0026ldquo;baab\u0026rdquo; ：\u0026ldquo;aabb\u0026rdquo; -\u0026gt; \u0026ldquo;abab\u0026rdquo; -\u0026gt; \u0026ldquo;baab\u0026rdquo; 。\n因此，得到回文串的最少总操作次数为 2 。\n示例 2：\n输入：s = \u0026ldquo;letelt\u0026rdquo;\n输出：2\n解释：\n通过 2 次操作从 s 能得到回文串 \u0026ldquo;lettel\u0026rdquo; 。\n其中一种方法是：\u0026ldquo;letelt\u0026rdquo; -\u0026gt; \u0026ldquo;letetl\u0026rdquo; -\u0026gt; \u0026ldquo;lettel\u0026rdquo; 。\n其他回文串比方说 \u0026ldquo;tleelt\u0026rdquo; 也可以通过 2 次操作得到。\n可以证明少于 2 次操作，无法得到回文串。\n提示：\n1 \u0026lt;= s.length \u0026lt;= 2000\ns 只包含小写英文字母。\ns 可以通过有限次操作得到一个回文串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // @lc code=start class Solution { public: int minMovesToMakePalindrome(string s) { // unordered_map\u0026lt;char,int\u0026gt; mp; // for(char k:s) { // if(mp[k]) mp[k]--; // else { // mp[k]++; // } // } // int cnt=0; // for (auto [k,v]: mp) { // if(cnt \u0026amp;\u0026amp; (v \u0026amp; 1)==1) { // return 0; // } // } // 一定会变回文 return dp(s); } int dp(string s) { int n = s.size(); if(n\u0026lt;=1) return 0; for (int i=n-1;i\u0026gt;0;i--) { if (s[i] == s[0]) { // i //a a b N: //0 1 2 3 int sz = n-i-1; // aabb auto ns = s.substr(1,i-1) + s.substr(i+1); // cout \u0026lt;\u0026lt; ns\u0026lt;\u0026lt;endl; return sz + dp(ns); } } int m = n/2; return m + dp(s.substr(1)); } }; // @lc code=end int main() { cout \u0026lt;\u0026lt; \u0026#34; * [2193] 得到回文串的最少操作次数\u0026#34; \u0026lt;\u0026lt; endl; Solution k; print(k.minMovesToMakePalindrome(\u0026#34;aabb\u0026#34;)); return 0; } ","date":"2023-12-26T23:53:41+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E9%80%92%E5%BD%92/lc.2193.%E5%BE%97%E5%88%B0%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","tags":["递归"],"title":"lc.2193.得到回文串的最少操作次数"},{"categories":["容斥原理"],"contents":"@lc app=leetcode.cn id=940 lang=cpp\n[940] 不同的子序列 II\nhttps://leetcode.cn/problems/distinct-subsequences-ii/description/ algorithms\nHard (53.10%)\nLikes: 328\nDislikes: 0\nTotal Accepted: 31.3K\nTotal Submissions: 59K\nTestcase Example: \u0026lsquo;\u0026ldquo;abc\u0026rdquo;\u0026rsquo;\n给定一个字符串 s，计算 s 的 不同非空子序列 的个数。因为结果可能很大，所以返回答案需要对 10^9 + 7 取余 。\n字符串的 子序列 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。\n例如，\u0026ldquo;ace\u0026rdquo; 是 \u0026ldquo;abcde\u0026rdquo; 的一个子序列，但 \u0026ldquo;aec\u0026rdquo; 不是。\n示例 1：\n输入：s = \u0026ldquo;abc\u0026rdquo;\n输出：7\n解释：7 个不同的子序列分别是 \u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;c\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;, \u0026ldquo;ac\u0026rdquo;, \u0026ldquo;bc\u0026rdquo;, 以及 \u0026ldquo;abc\u0026rdquo;。\n示例 2：\n输入：s = \u0026ldquo;aba\u0026rdquo;\n输出：6\n解释：6 个不同的子序列分别是 \u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;, \u0026ldquo;ba\u0026rdquo;, \u0026ldquo;aa\u0026rdquo; 以及 \u0026ldquo;aba\u0026rdquo;。\n示例 3：\n输入：s = \u0026ldquo;aaa\u0026rdquo;\n输出：3\n解释：3 个不同的子序列分别是 \u0026ldquo;a\u0026rdquo;, \u0026ldquo;aa\u0026rdquo; 以及 \u0026ldquo;aaa\u0026rdquo;。\n提示：\n1 \u0026lt;= s.length \u0026lt;= 2000\ns 仅由小写英文字母组成\n解题思路 参考 根据题意我们设dp[i]为前i个字符可以组成的不同的子序列，则有\n$$\ndp[i] = dp[i - 1] + newCount - repeatCount\n$$\n解题代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // @lc code=start class Solution { long long M = 1e9 + 7; public: int distinctSubseqII(string s) { #define ll long long int n = s.size(); vector\u0026lt;ll\u0026gt; m(26,0); ll su = 0; for (int i=0;i\u0026lt;n;i++) { ll t = m[s[i] - \u0026#39;a\u0026#39;]; // 以 s[i] 结尾的个数 m[s[i] - \u0026#39;a\u0026#39;] = su + 1; su += (su +1 - t) % M; } return su % M; } }; // @lc code=end int main() { cout \u0026lt;\u0026lt; \u0026#34; * [940] 不同的子序列 II\u0026#34; \u0026lt;\u0026lt; endl; Solution k; print( k.distinctSubseqII(\u0026#34;aaa\u0026#34;)); print( k.distinctSubseqII(\u0026#34;aba\u0026#34;)); print( k.distinctSubseqII(\u0026#34;abc\u0026#34;)); return 0; } 网友题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public: /* abcbb a:\t\u0026#34;\u0026#34; a ab:\t\u0026#34;\u0026#34;,\ta b,\tab abc: \u0026#34;\u0026#34;, a, b, ab c,\tac,bc,abc abcb:\u0026#34;\u0026#34;, a, b, ab, c, ac, bc, abc (b, ab),bb,abb,cb,acb,bcb,abcb\t//重复部分是上一次新增字符b的新增部分 abcbb:\u0026#34;\u0026#34;, a, b, ab, c, ac, bc, abc, b, ab, bb, abb, cb, acb, bcb, abcb (b,ab,bb,abb,cb,acb,bcb,abcb),bb,abb,bbb,abbb,cbb,acbb,bcbb,abcbb //重复部分是上一次新增字符b的新增部分 = 第一次新增b的净新增部分 b,ab 加上 第二次新增b的净新增部分 bb,abb,cb,acb,bcb,abcb */ int distinctSubseqII(string s) { //为了记录上一次增加相同字符时的新增量 vector\u0026lt;int\u0026gt; pre(26); //初始条件：0个字符时，有1个子序列（空字符串） int newCount, ans = 1, mod = 1e9 + 7; for(char chs : s) { //新增子序列（不考虑重复的部分） newCount = ans; //dp[i + 1] = dp[i] + 新增子序列（不考虑重复的部分） - 重复部分（上次增加相同字符时的所有新增部分（每次新增相同字符的净新增的总和）） ans = ((ans \u0026lt;\u0026lt; 1) % mod - pre[chs - \u0026#39;a\u0026#39;] % mod + mod) % mod; //更新该字符上次新增的部分 pre[chs - \u0026#39;a\u0026#39;] = newCount; } return ((ans - 1 + mod) % mod); } }; ","date":"2023-12-26T00:50:58+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/lc.940.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%972/","tags":["容斥原理"],"title":"lc.940.不同的子序列2"},{"categories":["容斥原理"],"contents":"[1987] 不同的好子序列数目\nhttps://leetcode.cn/problems/number-of-unique-good-subsequences/description/ algorithms\nHard (51.16%)\nLikes: 54\nDislikes: 0\nTotal Accepted: 2.7K\nTotal Submissions: 5.2K\nTestcase Example: \u0026lsquo;\u0026ldquo;001\u0026rdquo;\u0026rsquo;\n给你一个二进制字符串 binary 。 binary 的一个 子序列 如果是 非空 的且没有 前导 0 （除非数字是 \u0026ldquo;0\u0026rdquo; 本身），那么它就是一个 好\n的子序列。\n请你找到 binary 不同好子序列 的数目。\n比方说，如果 binary = \u0026ldquo;001\u0026rdquo; ，那么所有 好 子序列为 [\u0026ldquo;0\u0026rdquo;, \u0026ldquo;0\u0026rdquo;, \u0026ldquo;1\u0026rdquo;] ，所以 不同 的好子序列为 \u0026ldquo;0\u0026rdquo; 和 \u0026ldquo;1\u0026rdquo; 。\n注意，子序列 \u0026ldquo;00\u0026rdquo; ，\u0026ldquo;01\u0026rdquo; 和 \u0026ldquo;001\u0026rdquo; 不是好的，因为它们有前导 0 。\n请你返回 binary 中 不同好子序列 的数目。由于答案可能很大，请将它对 10^9 + 7 取余 后返回。\n一个 子序列 指的是从原数组中删除若干个（可以一个也不删除）元素后，不改变剩余元素顺序得到的序列。\n示例 1：\n输入：binary = \u0026ldquo;001\u0026rdquo;\n输出：2\n解释：好的二进制子序列为 [\u0026ldquo;0\u0026rdquo;, \u0026ldquo;0\u0026rdquo;, \u0026ldquo;1\u0026rdquo;] 。\n不同的好子序列为 \u0026ldquo;0\u0026rdquo; 和 \u0026ldquo;1\u0026rdquo; 。\n示例 2：\n输入：binary = \u0026ldquo;11\u0026rdquo;\n输出：2\n解释：好的二进制子序列为 [\u0026ldquo;1\u0026rdquo;, \u0026ldquo;1\u0026rdquo;, \u0026ldquo;11\u0026rdquo;] 。\n不同的好子序列为 \u0026ldquo;1\u0026rdquo; 和 \u0026ldquo;11\u0026rdquo; 。\n示例 3：\n输入：binary = \u0026ldquo;101\u0026rdquo;\n输出：5\n解释：好的二进制子序列为 [\u0026ldquo;1\u0026rdquo;, \u0026ldquo;0\u0026rdquo;, \u0026ldquo;1\u0026rdquo;, \u0026ldquo;10\u0026rdquo;, \u0026ldquo;11\u0026rdquo;, \u0026ldquo;101\u0026rdquo;] 。\n不同的好子序列为 \u0026ldquo;0\u0026rdquo; ，\u0026ldquo;1\u0026rdquo; ，\u0026ldquo;10\u0026rdquo; ，\u0026ldquo;11\u0026rdquo; 和 \u0026ldquo;101\u0026rdquo; 。\n提示：\n1 \u0026lt;= binary.length \u0026lt;= 10^5\nbinary 只含有 \u0026lsquo;0\u0026rsquo; 和 \u0026lsquo;1\u0026rsquo; 。\n解题思路： 参考 leetcode: 940. 不同的子序列 II /*\n尝试构造状态dp[i]，表示截止第i个字符为止，我们能够创建的distinct子序列有多少．对于这个dp[i]的定义，我们并不要求s[i]必须是子序列的一部分。\n接下来，对于第i个字符ch，我们尝试思考它如何参与到已有子序列dp[i-1]的构建来．\n情况I:如果它不参与到子序列的构建，那么dp[i-1]有多少子序列，dp[i]一定会保留全部的这些，所以dp[i]+=dp[i-1]。举个例子，如果对于dp[i-1]已经有了如下的不同子序列\nXXXX (1)\nXXX (2)\nXXX (3)\nXX (4)\n那么对于dp[i]而言，以上这些字符串仍然是其一部分。\n情况II:如果它参与到子序列的构建，那么dp[i-1]有多少子序列（包括空序列），末位加上S[i]之后，就能生成同样数目的新子序列．所以继续有dp[i]+=dp[i-1]．假设s[i]==\u0026lsquo;a\u0026rsquo;，那么我们就可以构造出新的子序列（接上面的例子\nXXXXa (5)\nXXXa (6)\nXXXa (7)\nXXa (8)\n所以综合一下，dp[i]=dp[i-1]2 ()\n但是我们显然要处理一种重复的情况，比如说(1)和(6)会不会重复？出现重复的原因在于，如果(1)中的最后一个字符也是\u0026rsquo;a\u0026rsquo;，当(1)中的前三个字符和(6)中的前三个字符的来源相同时，这些序列的数目就在(*)式里面被重复计算了两遍。\n如何去掉这个重复呢？对于(1)而言，我们需要定位第四个字符\u0026rsquo;a\u0026rsquo;的位置j。这个j是i之前最后一次出现字符\u0026rsquo;a\u0026rsquo;的index。我们可以验证，dp[j-1]所对应子序列xxx，加上s[j]，可以得到\u0026quot;xxxa\u0026quot;的形式；同时dp[j-1]所对应子序列xxx，加上s[i]，也可以得到\u0026quot;xxxa\u0026quot;的形式。这两部分的子序列是完全相同的，是被(*)式所重复计算的，所以我们需要减去。\n所以综上，dp[i]的更新式子是:dp[i] = dp[i-1]*2-dp[j-1]其中j就是i前面最后一个满足S[j]==S[i]的index。\n此题是字符串序列的一道经典题。如果第一次做的话，可能会觉得有难度。\n尝试构造状态dp[i]，表示截止第i个字符为止，我们能够创建的distinct子序列有多少．对于这个dp[i]的定义，我们并不要求s[i]必须是子序列的一部分。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // @lc code=start class Solution { public: long M = 1e9 + 7; int numberOfUniqueGoodSubsequences(string s) { int n = s.size(); if(!n) return 0; if(n==1) return 1; // unordered_map\u0026lt;char,int\u0026gt; m; // dp[0][1] = 1; int w = 0; long long v[2] = {0,0}; for (int i=1;i\u0026lt;=n;i++) { char c = s[i-1]; if (c == \u0026#39;0\u0026#39;) { w = 1; v[0] = (v[0] + v[1]) %M; // v[1] 不变 }else { v[1] = (v[0] + v[1]+1) %M; // v[0] 不变 } } return (w + v[0] + v[1] ) % M; } }; // @lc code=end int main() { cout \u0026lt;\u0026lt; \u0026#34; * [1987] 不同的好子序列数目\u0026#34; \u0026lt;\u0026lt; endl; Solution k; print ( k.numberOfUniqueGoodSubsequences(\u0026#34;101\u0026#34;) ); return 0; } ","date":"2023-12-26T00:28:54+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/lc.1987.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%A5%BD%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE/","tags":["容斥原理"],"title":"lc.1987.不同的好子序列数目"},{"categories":["并查集"],"contents":"/*\n@lc app=leetcode.cn id=547 lang=cpp\n*\n[547] 省份数量\n*\nhttps://leetcode.cn/problems/number-of-provinces/description/ *\nalgorithms\nMedium (62.14%)\nLikes: 1077\nDislikes: 0\nTotal Accepted: 293.8K\nTotal Submissions: 472.8K\nTestcase Example: \u0026lsquo;[[1,1,0],[1,1,0],[0,0,1]]\u0026rsquo;\n*\n有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c\n间接相连。\n省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。\n给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而\nisConnected[i][j] = 0 表示二者不直接相连。\n返回矩阵中 省份 的数量。\n示例 1：\n输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n输出：2\n示例 2：\n输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n输出：3\n提示：\n1\nn == isConnected.length\nn == isConnected[i].length\nisConnected[i][j] 为 1 或 0\nisConnected[i][i] == 1\nisConnected[i][j] == isConnected[j][i]\n*/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // @lc code=start class Solution { public: int findCircleNum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; isConnected) { int n = isConnected.size(); vector\u0026lt;int\u0026gt; mp(n,-1); for (int i=0;i\u0026lt;n;++i) mp[i] = i; for (int i=0;i\u0026lt;n;i++) { for(int j=0;j\u0026lt;n;j++) { if (isConnected[i][j]) { //connected mp[find(mp,i)] = find(mp,j); } } } int cnt = 0; for (int i=0;i\u0026lt;n;i++) { if (mp[i] == i) cnt++; } return cnt; } int find(vector\u0026lt;int\u0026gt; mp,int i) { if (mp[i] == i) return i; return mp[i] = find(mp,mp[i]); } }; // @lc code=end int main() { cout \u0026lt;\u0026lt; \u0026#34; * [547] 省份数量\u0026#34; \u0026lt;\u0026lt; endl; Solution k; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; a = { {1,0,0}, {0,1,0}, {0,0,1}, }; cout \u0026lt;\u0026lt; k.findCircleNum(a) \u0026lt;\u0026lt;endl; return 0; } ","date":"2023-12-24T14:59:42+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E5%B9%B6%E6%9F%A5%E9%9B%86/lc.547.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/","tags":["并查集"],"title":"lc.547.省份数量"},{"categories":["状态压缩"],"contents":"@lc app=leetcode.cn id=864 lang=cpp\n*\n[864] 获取所有钥匙的最短路径\n*\nhttps://leetcode.cn/problems/shortest-path-to-get-all-keys/description/ *\nalgorithms\nHard (59.25%)\nLikes: 275\nDislikes: 0\nTotal Accepted: 21.7K\nTotal Submissions: 36.7K\nTestcase Example: \u0026lsquo;[\u0026quot;@.a..\u0026quot;,\u0026quot;###.#\u0026quot;,\u0026ldquo;b.A.B\u0026rdquo;]\u0026rsquo;\n*\n给定一个二维网格 grid ，其中：\n\u0026lsquo;.\u0026rsquo; 代表一个空房间\n\u0026lsquo;#\u0026rsquo; 代表一堵墙\n\u0026lsquo;@\u0026rsquo; 是起点\n小写字母代表钥匙\n大写字母代表锁\n我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。\n假设 k 为 钥匙/锁 的个数，且满足 1 \u0026lt;= k \u0026lt;= 6，字母表中的前 k\n个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。\n返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。\n示例 1：\n输入：grid = [\u0026quot;@.a.#\u0026quot;,\u0026quot;###.#\u0026quot;,\u0026ldquo;b.A.B\u0026rdquo;]\n输出：8\n解释：目标是获得所有钥匙，而不是打开所有锁。\n示例 2：\n输入：grid = [\u0026quot;@..aA\u0026quot;,\u0026quot;..B#.\u0026quot;,\u0026quot;\u0026hellip;.b\u0026quot;]\n输出：6\n示例 3:\n输入: grid = [\u0026quot;@Aa\u0026quot;]\n输出: -1\n提示：\nm == grid.length\nn == grid[i].length\n1 \u0026lt;= m, n \u0026lt;= 30\ngrid[i][j] 只含有 \u0026lsquo;.\u0026rsquo;, \u0026lsquo;#\u0026rsquo;, \u0026lsquo;@\u0026rsquo;, \u0026lsquo;a\u0026rsquo;-\u0026lsquo;f\u0026rsquo; 以及 \u0026lsquo;A\u0026rsquo;-\u0026lsquo;F\u0026rsquo;\n钥匙的数目范围是 [1, 6]\n每个钥匙都对应一个 不同 的字母\n每个钥匙正好打开一个对应的锁\n解题思路 把所有钥匙压缩为状态进行表示，1 表示 获得，0没获得，最后 状态一定要到达 (1\u0026lt;\u0026lt;m) -1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 // @lc code=start class Solution { public: bool iskey(char f) { return f\u0026gt;=\u0026#39;a\u0026#39; \u0026amp;\u0026amp; f\u0026lt;=\u0026#39;z\u0026#39;; } bool isblock(char f) { return f==\u0026#39;#\u0026#39;; } bool islock(char f) { return f\u0026gt;=\u0026#39;A\u0026#39; \u0026amp;\u0026amp; f\u0026lt;=\u0026#39;Z\u0026#39;; } struct node { int x; int y; int mask; }; int shortestPathAllKeys(vector\u0026lt;string\u0026gt;\u0026amp; grid) { int n= grid.size(); if(!n) return 0; int m = grid[0].size(); int state = 0; unordered_map\u0026lt;int,int\u0026gt; idxkey; unordered_map\u0026lt;int,bool\u0026gt; vis; int x=0,y=0; for (int i=0;i\u0026lt;grid.size();++i) { for (int j=0;j\u0026lt;grid[i].size();j++) { if (iskey(grid[i][j])) { idxkey[grid[i][j]] = state++; } if(grid[i][j] == \u0026#39;@\u0026#39;) { x=i,y=j; } } } queue\u0026lt;node\u0026gt; q; q.push({x,y,0}); vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026gt; dist(n,vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; (m,vector\u0026lt;int\u0026gt; (1\u0026lt;\u0026lt;state,-1))); dist[x][y][0] = 0; vector\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; dirs = { {1,0}, {0,1}, {-1,0}, {0,-1}, }; while( q.size()) { auto [x,y,mask] = q.front();q.pop(); for(auto [a,b]: dirs) { auto nx = a+x; auto ny = b+y; if(nx\u0026lt;0 || nx\u0026gt;=n || ny\u0026lt;0||ny\u0026gt;=m) continue; auto f= grid[nx][ny]; if(f == \u0026#39;.\u0026#39; || f == \u0026#39;@\u0026#39;) { if (dist[nx][ny][mask] == -1) { dist[nx][ny][mask] = dist[x][y][mask]+1; q.push({nx,ny,mask}); } }else if(f == \u0026#39;#\u0026#39;) {//block continue; }else if (islock(f)) { //has lock auto id = idxkey[(f-\u0026#39;A\u0026#39; +\u0026#39;a\u0026#39;)]; if ((mask \u0026gt;\u0026gt; id) \u0026amp; 1) { // success if(dist[nx][ny][mask]==-1) { dist[nx][ny][mask] = dist[x][y][mask]+1; q.push({nx,ny,mask}); } } }else if (iskey(f)) { auto id = idxkey[f]; int m = mask | (1\u0026lt;\u0026lt;id); // success if(dist[nx][ny][m] == -1) { dist[nx][ny][m] = dist[x][y][mask]+1; q.push({nx,ny,m}); } if (m == (1\u0026lt;\u0026lt;state)-1) { return dist[nx][ny][m]; } } } } return -1; } }; ","date":"2023-12-23T18:58:05+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/lc.864.%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/","tags":["状态压缩"],"title":"lc.864.获取所有钥匙最短路径"},{"categories":["状态压缩"],"contents":"@lc app=leetcode.cn id=1655 lang=cpp\n*\n[1655] 分配重复整数\n*\nhttps://leetcode.cn/problems/distribute-repeating-integers/description/ *\nalgorithms\nHard (39.88%)\nLikes: 51\nDislikes: 0\nTotal Accepted: 4.4K\nTotal Submissions: 11.1K\nTestcase Example: \u0026lsquo;[1,2,3,4]\\n[2]\u0026rsquo;\n*\n给你一个长度为 n 的整数数组 nums ，这个数组中至多有 50 个不同的值。同时你有 m 个顾客的订单 quantity ，其中，整数\nquantity[i] 是第 i 位顾客订单的数目。请你判断是否能将 nums 中的整数分配给这些顾客，且满足：\n第 i 位顾客 恰好 有 quantity[i] 个整数。\n第 i 位顾客拿到的整数都是 相同的 。\n每位顾客都满足上述两个要求。\n如果你可以分配 nums 中的整数满足上面的要求，那么请返回 true ，否则返回 false 。\n示例 1：\n输入：nums = [1,2,3,4], quantity = [2]\n输出：false\n解释：第 0 位顾客没办法得到两个相同的整数。\n示例 2：\n输入：nums = [1,2,3,3], quantity = [2]\n输出：true\n解释：第 0 位顾客得到 [3,3] 。整数 [1,2] 都没有被使用。\n示例 3：\n输入：nums = [1,1,2,2], quantity = [2,2]\n输出：true\n解释：第 0 位顾客得到 [1,1] ，第 1 位顾客得到 [2,2] 。\n提示：\nn == nums.length\n1 \u0026lt;= n \u0026lt;= 10^5\n1 \u0026lt;= nums[i] \u0026lt;= 1000\nm == quantity.length\n1 \u0026lt;= m \u0026lt;= 10\n1 \u0026lt;= quantity[i] \u0026lt;= 10^5\nnums 中至多有 50 个不同的数字。\n解题关键公式 每个订单状态只有满足 和 不满足 2种情况， 用 一个 二进制数表示 这组订单的状态\n例如： 110 表示 最后1个订单不能满足，其他的订单满足 的情况\n$$ dp[i][111] = dp[i-1][110] \\ and \\ cnt[i] \u0026gt;= need(001) $$\nor\n$$ dp[i][111] = dp[i-1][100] \\ and \\ cnt[i] \u0026gt;= need(011) $$\n即为\n$\ndp[i][mask] = dp[i-1][sub] \\ and \\ cnt[i] \u0026gt;= need(mask - sub)\n$\nstate = mask \u0026amp; (state - 1)\nstate 表示 mask的子集\ndp[i][state] 表示 到达 state 状态，前i件物品能否满足，如果无法到达 state，则 值为 false\n解题代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class Solution { public: bool isok(int ned,int state,vector\u0026lt;int\u0026gt; qu,int m) { for (int i=0;i\u0026lt;m;i++) { if ((state \u0026gt;\u0026gt; i) \u0026amp; 1) { ned -= qu[i]; } if (ned \u0026lt; 0) return false; } return ned \u0026gt;= 0; } bool canDistribute(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;int\u0026gt;\u0026amp; quantity) { int m = quantity.size(); unordered_map\u0026lt;int,int\u0026gt; mp; for(auto d: nums ) mp[d]++; vector\u0026lt;int\u0026gt; cnt; for(auto d: mp ) cnt.push_back(d.second); int n= cnt.size(); vector\u0026lt;vector\u0026lt;bool\u0026gt; \u0026gt; dp(n+1,vector\u0026lt;bool\u0026gt; (1\u0026lt;\u0026lt;m)); vector\u0026lt;int\u0026gt; sum(1\u0026lt;\u0026lt;m); for (int j=0;j\u0026lt;1\u0026lt;\u0026lt;m;j++) { for(int i=0;i\u0026lt; m;i++) { if ((j\u0026gt;\u0026gt;i) \u0026amp; 1) { sum[j] += quantity[i]; } } } for(int i=0;i\u0026lt; n;i++) { dp[i][0] = 1; } for (int i=1;i\u0026lt;=n;i++) { // n个物品循环去试 for (int state = 1; state \u0026lt; (1\u0026lt;\u0026lt;m); state ++) { // 子节点 if(dp[i-1][state]) { dp[i][state] = true; continue; } for (int sub = state;sub ; sub = (sub-1) \u0026amp; state) { //孙节点 // 求子集 if(!dp[i-1][state - sub]) continue; if (cnt[i-1] \u0026gt;= sum[sub]) { // 能满足 sub中的全部要求 dp[i][state] = 1; } // if(isok(cnt[i-1],sub,quantity,m)) // dp[i][state] = 1; } } } return dp[n][(1\u0026lt;\u0026lt;m)-1]; } }; https://github.com/wisdompeak/LeetCode/tree/master/Dynamic_Programming/1655.Distribute-Repeating-Integers 其他解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /* if ((i \u0026amp; (1 \u0026lt;\u0026lt; j)) != 0) { int left = i - (1 \u0026lt;\u0026lt; j); sum[i] = sum[left] + quantity[j]; break; } // 要求出子集 i 的订单总和，首先我们找出子集 i 中的任意一个元素 j，这样剩下的部分就是 i - (1 \u0026lt;\u0026lt; j)，因此订单总和就是子集 i - (1 \u0026lt;\u0026lt; j) 的和加上第 j 个订单的值。 */ class Solution { public: bool canDistribute(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;int\u0026gt;\u0026amp; quantity) { unordered_map\u0026lt;int, int\u0026gt; cache; for (int x: nums) { cache[x]++; } vector\u0026lt;int\u0026gt; cnt; for (auto\u0026amp; kv: cache) { cnt.push_back(kv.second); } int n = cnt.size(), m = quantity.size(); vector\u0026lt;int\u0026gt; sum(1 \u0026lt;\u0026lt; m, 0); for (int i = 1; i \u0026lt; (1 \u0026lt;\u0026lt; m); i++) { for (int j = 0; j \u0026lt; m; j++) { if ((i \u0026amp; (1 \u0026lt;\u0026lt; j)) != 0) { int left = i - (1 \u0026lt;\u0026lt; j); sum[i] = sum[left] + quantity[j]; break; } } } vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(n, vector\u0026lt;bool\u0026gt;(1 \u0026lt;\u0026lt; m, false)); for (int i = 0; i \u0026lt; n; i++) { dp[i][0] = true; } for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; (1 \u0026lt;\u0026lt; m); j++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; dp[i-1][j]) { dp[i][j] = true; continue; } for (int s = j; s != 0; s = ((s - 1) \u0026amp; j)) { // 子集枚举，详见 https://oi-wiki.org/math/bit/#_14 int prev = j - s; // 前 i-1 个元素需要满足子集 prev = j-s bool last = (i == 0) ? (prev == 0): dp[i-1][prev]; // cnt[0..i-1] 能否满足子集 prev bool need = sum[s] \u0026lt;= cnt[i]; // cnt[i] 能否满足子集 s if (last \u0026amp;\u0026amp; need) { dp[i][j] = true; break; } } } } return dp[n-1][(1\u0026lt;\u0026lt;m)-1]; } }; 作者：火箭少女杨超越\n链接： https://leetcode.cn/problems/distribute-repeating-integers/solutions/1/zi-ji-mei-ju-jing-dian-tao-lu-zhuang-ya-dp-by-arse/ 其他参考例题 [[....\\位运算\\经典模板题\\lc.78.子集.md]]\n[[..\\序列边界\\lc.2741.特别的排列.md]]\n","date":"2023-12-23T16:43:20+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/lc.1655.%E5%88%86%E9%85%8D%E9%87%8D%E5%A4%8D%E6%95%B4%E6%95%B0/","tags":["状态压缩"],"title":"lc.1655.分配重复整数"},{"categories":["状态转移"],"contents":" 337. House Robber III @lc app=leetcode.cn id=337 lang=cpp\n[337] 打家劫舍 III\nhttps://leetcode.cn/problems/house-robber-iii/description/ algorithms\nMedium (61.50%)\nLikes: 1923\nDislikes: 0\nTotal Accepted: 325.4K\nTotal Submissions: 529.1K\nTestcase Example: \u0026lsquo;[3,2,3,null,3,null,1]\u0026rsquo;\n小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。\n除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果\n两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。\n给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。\n示例 1:\n输入: root = [3,2,3,null,3,null,1]\n输出: 7\n解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7\n示例 2:\n输入: root = [3,4,5,1,3,null,1]\n输出: 9\n解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9\n提示：\n树的节点数在 [1, 10^4] 范围内\n0 \u0026lt;= Node.val \u0026lt;= 10^4\nExample 1:\n1 2 3 Input: root = [3,2,3,null,3,null,1] Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2:\n1 2 3 Input: root = [3,4,5,1,3,null,1] Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. Constraints:\nThe number of nodes in the tree is in the range [1, 10^4]. 0 \u0026lt;= Node.val \u0026lt;= 10^4 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // @lc code=start /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int rob(TreeNode* root) { return dp(root,true); } unordered_map\u0026lt;TreeNode*,int\u0026gt; mp; unordered_map\u0026lt;TreeNode*,int\u0026gt; st; int dp(TreeNode *root,bool steal) { if(root==NULL) return 0; if (steal) { if (st.count(root)) return st[root]; // 能偷， ，result = max(偷，不偷) // 偷 int stealres = root-\u0026gt;val + dp(root-\u0026gt;left,false) + dp(root-\u0026gt;right,false); // 对比2种情况 int r= max(stealres,dp(root,false)); st[root]=r; return r; }else { if (mp.count(root)) { return mp[root]; } // 不偷 int ans = dp(root-\u0026gt;left,true) + dp(root-\u0026gt;right,true); mp[root] = ans; return ans; } } }; // @lc code=end 题解2，网友解法 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: unordered_map\u0026lt;TreeNode*, vector\u0026lt;int\u0026gt;\u0026gt; dp; int rob(TreeNode* root, bool canRob = true) { if(!root) return 0; if(dp.count(root) \u0026amp;\u0026amp; dp[root][canRob] != -1) return dp[root][canRob]; dp[root] = {-1,-1}; int dontRob = rob(root -\u0026gt; left, true) + rob(root -\u0026gt; right, true); int robRoot = canRob ? root -\u0026gt; val + rob(root -\u0026gt; left, false) + rob(root -\u0026gt; right, false) : -1; return dp[root][canRob] = max(dontRob, robRoot); } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: pair\u0026lt;int,int\u0026gt; solve(TreeNode* root){ if(root == NULL){ return {0,0}; } pair\u0026lt;int,int\u0026gt; left = solve(root-\u0026gt;left); pair\u0026lt;int,int\u0026gt; right = solve(root-\u0026gt;right); pair\u0026lt;int,int\u0026gt; temp; temp.first = root-\u0026gt;val + left.second + right.second; temp.second = max(left.first,left.second) + max(right.first,right.second); return temp; } int rob(TreeNode* root) { pair\u0026lt;int,int\u0026gt; ans = solve(root); return max(ans.first,ans.second); } }; ","date":"2023-12-22T23:29:34+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BBdp/lc.337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D3/","tags":["状态转移"],"title":"lc.337.打家劫舍3"},{"categories":["位运算"],"contents":"题目描述 Description Difficulty: undefined\nRelated Topics: 位运算 , 字典树 , 数组 , 哈希表 解题分析：\n利用异或运算，利用前缀树索引 每个数符号位，快速查找找到最大值的路径\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;vector \u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; /* * @lc app=leetcode.cn id=421 lang=cpp * * [421] 数组中两个数的最大异或值 * * https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/description/ * * algorithms * Medium (60.04%) * Likes: 670 * Dislikes: 0 * Total Accepted: 61.5K * Total Submissions: 102.4K * Testcase Example: \u0026#39;[3,10,5,25,2,8]\u0026#39; * * 给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j \u0026lt; n 。 * * * * * * 示例 1： * * * 输入：nums = [3,10,5,25,2,8] * 输出：28 * 解释：最大运算结果是 5 XOR 25 = 28. * * 示例 2： * * * 输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70] * 输出：127 * * * * * 提示： * * * 1 \u0026lt;= nums.length \u0026lt;= 2 * 10^5 * 0 \u0026lt;= nums[i] \u0026lt;= 2^31 - 1 * * * * */ // @lc code=start class Node { public: Node *v0; Node* v1; }; // int 有31位，第32为符号位， 0为开始，所以减去1 #define hi (31-1) class Solution { public: Node *makeTree(Node *root,int w) { if(!root) return NULL; // if (w==0) return root; for (int k=hi;k\u0026gt;=0;k--) { int b = (w\u0026gt;\u0026gt;k) \u0026amp; 1; if(b) { if(!root-\u0026gt;v1)root-\u0026gt;v1 = new Node(); root = root-\u0026gt;v1; }else { if(!root-\u0026gt;v0) root-\u0026gt;v0 = new Node(); root = root-\u0026gt;v0; } } return root; } int xorTree(Node *p,int x) { int ans=0; for(int i=hi;i\u0026gt;=0;i--) { int b = (x\u0026gt;\u0026gt;i) \u0026amp; 1; if(b) { // 1 if(p-\u0026gt;v0) { ans = ans *2 +1; p = p-\u0026gt;v0; }else if(p-\u0026gt;v1) { ans = ans *2; p = p-\u0026gt;v1; } }else { // 0 if(p-\u0026gt;v1) { ans = ans *2 +1; p = p-\u0026gt;v1; }else{ p = p-\u0026gt;v0; ans = ans *2; } } } return ans; } int findMaximumXOR(vector\u0026lt;int\u0026gt; \u0026amp;nums) { Node p = {NULL,NULL}; int ans=0; // 经可能为1 for(int i=1,n= nums.size();i\u0026lt;n;i++) { // xor是对称的， a^b = b^a ,这样只需要遍历1遍即可 makeTree(\u0026amp;p,nums[i-1]); ans = max(ans,xorTree(\u0026amp;p,nums[i])); } // 0 ^ 0 =\u0026gt;0 // 0 ^ 1 =\u0026gt; 1 // 1 ^ 1 =\u0026gt; 0 return ans; } }; // @lc code=end int main() { cout \u0026lt;\u0026lt; \u0026#34; * [421] 数组中两个数的最大异或值\u0026#34; \u0026lt;\u0026lt; endl; Solution k; vector\u0026lt;int\u0026gt; ans = { 0,8 }; cout \u0026lt;\u0026lt; \u0026#34;result: \u0026#34; \u0026lt;\u0026lt; k.findMaximumXOR(ans) \u0026lt;\u0026lt; endl; return 0; } ","date":"2023-12-19T23:53:43+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/421.%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/","tags":["位运算"],"title":"421.数组中两个数最大异或值"},{"categories":["基础入门"],"contents":"go语法坑总结 闭包延时绑定 闭包里面使用闭包外的参数，其值最终调用时候确定下来的。 闭包很强大，但是要小心延时绑定, 一般 可以在代码块前面 重新定义 i ，例如 i:=i\n1 2 3 4 5 6 7 8 9 func Delay() { fns := make([]func(),0,10) for i:=0;i\u0026lt;10;i++ { fns = append(fns,func() { fmt.Println(i) }) } for _,v := range fns { v() } } ","date":"2022-11-23T00:13:07+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/go%E8%AF%AD%E6%B3%95%E5%BF%85%E7%9F%A5/","tags":["基础入门"],"title":"go语法必知"},{"categories":["基础入门"],"contents":" 35. 搜索插入位置 Description Difficulty: 简单\nRelated Topics: 数组 , 二分查找 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n请必须使用时间复杂度为 O(log n) 的算法。\n示例 1:\n1 2 输入: nums = [1,3,5,6], target = 5 输出: 2 示例 2:\n1 2 输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3:\n1 2 输入: nums = [1,3,5,6], target = 7 输出: 4 提示:\n1 \u0026lt;= nums.length \u0026lt;= 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 为 无重复元素的 升序排列数组 -104 \u0026lt;= target \u0026lt;= 104 Solution Language: Go\n1 2 3 4 5 6 func·searchInsert(nums·[]int,·target·int)·int·{ ····i·:=·sort.Search(len(nums),func(i·int)·bool··{ ········return·nums[i]·\u0026gt;=·target;·//·最小值·，lower_bound ····}) ····return·i· } ","date":"2022-11-22T23:39:47+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/lc.35.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/","tags":["基础入门"],"title":"lc.35.搜索插入位置"},{"categories":["基础入门"],"contents":" 1. 两数之和 Description Difficulty: 简单\nRelated Topics: 数组 , 哈希表 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n示例 1：\n1 2 3 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2：\n1 2 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：\n1 2 输入：nums = [3,3], target = 6 输出：[0,1] 提示：\n2 \u0026lt;= nums.length \u0026lt;= 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 -109 \u0026lt;= target \u0026lt;= 109 只会存在一个有效答案 **进阶：**你可以想出一个时间复杂度小于 O(n2) 的算法吗？\nSolution Language: Go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func twoSum(nums []int, target int) []int { m := make(map[int]int,len(nums)) for i,v := range nums { //a+b = target --\u0026gt; target-b = a _,ok := m[target - v] if ok { return []int{ m[target-v],i } } m[v] = i } return []int{-1,-1} } ","date":"2022-11-22T22:49:43+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/lc.1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","tags":["基础入门"],"title":"lc.1.两数之和"},{"categories":["多层感知机"],"contents":"多层感知机 MLP 多层感知机（MLP，Multilayer Perceptron）也叫人工神经网络（ANN，Artificial Neural Network），除了输入输出层，它中间可以有多个隐层，最简单的MLP只含一个隐层，即三层的结构，如下图：\nkeras 理解 Keras 是一个用 Python 编写的高级神经网络 API，它能够以 TensorFlow, CNTK, 或者 Theano 作为后端运行。Keras 的开发重点是支持快速的实验。能够以最小的时延把你的想法转换为实验结果，是做好研究的关键。\n用户友好。 Keras 是为人类而不是为机器设计的 API。它把用户体验放在首要和中心位置。Keras 遵循减少认知困难的最佳实践：它提供一致且简单的 API，将常见用例所需的用户操作数量降至最低，并且在用户错误时提供清晰和可操作的反馈。\n模块化。 模型被理解为由独立的、完全可配置的模块构成的序列或图。这些模块可以以尽可能少的限制组装在一起。特别是神经网络层、损失函数、优化器、初始化方法、激活函数、正则化方法，它们都是可以结合起来构建新模型的模块。\n易扩展性。 新的模块是很容易添加的（作为新的类和函数），现有的模块已经提供了充足的示例。由于能够轻松地创建可以提高表现力的新模块，Keras 更加适合高级研究。\n基于 Python 实现。 Keras 没有特定格式的单独配置文件。模型定义在 Python 代码中，这些代码紧凑，易于调试，并且易于扩展。\nTensorflow 是一个数据流图，用于数字计算的开源软件库，自动计算模型相关的微分导数， 非常适合用于神经网络模型求解。\nkeras 可以看出是tensorflow 的一个接口。\nkeras 建立MLP模型 1 2 3 4 5 6 7 8 9 10 11 12 from keras.model import Sequential model = Sequential() from keras.layers import Dense # 叠加各层网络 model.add(Dense(units=3,activation = \u0026#39;sigmoid\u0026#39;,input_dim = 3)) model.add(Dense(units=1,activation = \u0026#39;sigmoid\u0026#39; ) # 损失函数 model.compile(loss = \u0026#39;categorical_crossentropy\u0026#39;,optimizer = \u0026#39;sgd\u0026#39;) # 训练模型 model.fit(x_train, y_train,epochs = 5) 1 2 conda install keras conda install tensorflow MLP 实战非线性二分类 2维数据，20个神经元\n一个隐藏层，\n1 2 3 4 5 6 7 8 9 10 11 12 13 from keras.models import Sequential from keras.layers import Dense,Activation mlp = Sequential() mlp.add(Dense(20,input_dim=2, activation = \u0026#39;Sigmoid\u0026#39;)) mlp.summary() # 配置模型参数 mlp.compile(optimizer = \u0026#39;adam\u0026#39; ,loss = \u0026#39;binary_cross_entropy\u0026#39;) # 模型训练 mlp.fit(x_train,y_train, epochs = 3000) # 结果预测 y_test_predict = mlp.predict_classes(x_test) ","date":"2022-11-13T15:42:19+08:00","permalink":"https://lyr-2000.github.io/code/post/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BAmlp/","tags":["多层感知机"],"title":"多层感知机MLP"},{"categories":["逻辑回归"],"contents":"决策树 和 逻辑回归 任务：\n根据用户的学习动力，能力提升意愿，兴趣度 判断是否适合学习本门课程, 通过多层判断，从训练集归纳出一组分类规则\n$w=w1动力+w2能力+w3兴趣+w4时间$\n决策树使用：\n计算量小，运算速度快 易于理解，可以清晰查看各个属性的重要性。 缺点：\n忽略属性的相关性， 样本类别分布不均匀时候，容易影响模型表现。\n异常点 参考文章 sklearn 中的决策树 sklearn中决策树的类都在”tree“这个模块之下\n方法 作用 tree.DecisionTreeClassifier 分类树 tree.DecisionTreeRegressor 回归树 tree.export_graphviz 将决策树导出为 dot格式，用于画图 tree.ExtraTreeClassifier 高随机版本的分类树 tree.ExtraTreeRegressor 高随机版本的回归树 sklearn 基本建模流程 1 2 3 4 from sklearn import tree clf = tree.DecisionTreeClassifier() clf = clf.fit(X_train,y_train) # 训练模型 result = clf.score(X_test,y_test) # 导入测试机 测试 分类葡萄酒类型实战 参考文档 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from sklearn import tree from sklearn.datasets import load_wine from sklearn.model_selection import train_test_split wine = load_wine() wine.data # 特征 import pandas as pd pd.concat([pd.DataFrame(wine.data),pd.DataFrame(wine.target)],axis=1) xtrain,xtest,ytrain,ytest = train_test_split(wine.data,wine.target,test_size=0.3) xtrain.shape # 实例化 clf = tree.DecisionTreeClassifier(criterion=\u0026#34;entropy\u0026#34;) clf = clf.fit(xtrain,ytrain) score = clf.score(xtest,ytest) score # 目前已经建立完模型 # 绘制树 import graphviz feature_name = [\u0026#39;酒精\u0026#39;,\u0026#39;苹果酸\u0026#39;,\u0026#39;灰\u0026#39;,\u0026#39;灰的碱性\u0026#39;,\u0026#39;镁\u0026#39;,\u0026#39;总酚\u0026#39;,\u0026#39;类黄酮\u0026#39;,\u0026#39;非黄烷类酚类\u0026#39;,\u0026#39;花青素\u0026#39;,\u0026#39;颜 色强度\u0026#39;,\u0026#39;色调\u0026#39;,\u0026#39;od280/od315稀释葡萄酒\u0026#39;,\u0026#39;脯氨酸\u0026#39;] dot_data = tree.export_graphviz(clf ,feature_names= feature_name ,class_names=[\u0026#34;琴酒\u0026#34;,\u0026#34;雪莉\u0026#34;,\u0026#34;贝尔摩德\u0026#34;] ,filled=True ,rounded=True ) graph = graphviz.Source(dot_data) graph 探索 决策树的应用 减枝参数 在不加限制的情况下，一棵决策树会生长到衡量不纯度的指标最优，或者没有更多的特征可用为止。这样的决策树 往往会过拟合，这就是说，它会在训练集上表现很好，在测试集上却表现糟糕。我们收集的样本数据不可能和整体 的状况完全一致，因此当一棵决策树对训练数据有了过于优秀的解释性，它找出的规则必然包含了训练样本中的噪 声，并使它对未知数据的拟合程度不足。 正确的减枝是决策树的核心\nmax_depth 限制树高度 max_features min_samples 无论如何，剪枝参数的默认值会让树无尽地生长，这些树在某些数据集上可能非常巨大，对内存的消耗。所以如果 你手中的数据集非常大，你已经预测到无论如何你都是要剪枝的，那提前设定这些参数来控制树的复杂性和大小会 比较好。\n我们可以 循环参数树的深度，然后把图都绘制出来，然后直观的选择 精度最大的一个深度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import matplotlib.pyplot as plt test = [] for i in range(10): clf = tree.DecisionTreeClassifier(max_depth=i+1 ,criterion=\u0026#34;entropy\u0026#34; ,random_state=30 ,splitter=\u0026#34;random\u0026#34; ) clf = clf.fit(Xtrain, Ytrain) score = clf.score(Xtest, Ytest) test.append(score) plt.plot(range(1,11),test,color=\u0026#34;red\u0026#34;,label=\u0026#34;max_depth\u0026#34;) plt.legend() plt.show() 随机森林 随机森林就是通过集成学习的Bagging思想将多棵树集成的一种算法：它的基本单元就是决策树。随机森林的名称中有两个关键词，一个是“随机”，一个就是“森林”。“森林”很好理解，一棵叫做树，那么成百上千棵就可以叫做森林了，其实这也是随机森林的主要思想\u0026ndash;集成思想的体现。“随机”的含义我们会在下面讲到。\n我们要将一个输入样本进行分类，就需要将它输入到每棵树中进行分类。将若干个弱分类器的分类结果进行投票选择，从而组成一个强分类器，这就是随机森林bagging的思想：\n","date":"2022-11-12T22:11:17+08:00","permalink":"https://lyr-2000.github.io/code/post/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/%E5%86%B3%E7%AD%96%E6%A0%91/","tags":["逻辑回归"],"title":"决策树"},{"categories":["监督学习"],"contents":"KNN 算法 K近邻算法\n思路简单 数学知识少 效果好 KNN算法缺点\n算法存储了所有训练数据，所以对内存要求较高\n预测时间可能较长\n对不相关的功能和数据规模敏感\n比如判断患者肿瘤的严重性，可以从肿瘤大小和患病时间两个维度分析，时间越久，越大就越危险，越小，越早发现就越安全。\n参考博客 相关概念 一般而言，我们只选择样本数据集中前k个最相似的数据，这就是KNN算法中K的由来，通常k是不大于20的整数。最后，选择k个最相似数据中出现次数最多的类别，作为新数据的分类。\n欧拉距离 代码实战 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 import numpy as np import matplotlib.pyplot as plt from collections import Counter # 为了做投票 # raw_data_x属于特征值，分别属于患病时间和肿瘤大小 raw_data_x = [[3.3935, 2.3312], [3.1101, 1.7815], [1.3438, 3.3684], [3.5823, 4.6792], [2.2804, 2.8670], [7.4234, 4.6965], [5.7451, 3.5340], [9.1722, 2.5111], [7.7928, 3.4241], [7.9398, 0.7916]] # raw_data_y属于目标值，0代表良性肿瘤，1代表恶性肿瘤 row_data_y = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1] class KNNClassifier: def __init__(self, k): assert k \u0026gt; 1, \u0026#34;K值必须大于1\u0026#34; self.k = k self.x_train = None self.y_train = None def fit(self, x_train, y_train): \u0026#34;\u0026#34;\u0026#34;根据训练数据集x_train和y_train训练分类器 x_train: 训练数据的特征 y_train: 训练数据的目标 \u0026#34;\u0026#34;\u0026#34; assert x_train.shape[0] == y_train.shape[0], \u0026#34;x_train的大小必须等于y_train的大小\u0026#34; assert self.k \u0026lt;= x_train.shape[0], \u0026#34;x_train的大小必须大于K\u0026#34; self.x_train = x_train self.y_train = y_train def euc_dis(self, instance1, instance2): \u0026#34;\u0026#34;\u0026#34; 计算两个样本instance1和instance2之间的欧式距离 instance1: 第一个样本， array型 instance2: 第二个样本， array型 \u0026#34;\u0026#34;\u0026#34; dist = np.sqrt(sum((instance1 - instance2) ** 2)) return dist def knn_classify(self, testInstance): \u0026#34;\u0026#34;\u0026#34; 给定一个测试数据testInstance, 通过KNN算法来预测它的标签。 testInstance: 测试数据，这里假定一个测试数据为array型 \u0026#34;\u0026#34;\u0026#34; distances = [self.euc_dis(x, testInstance) for x in self.x_train] kneighbors = np.argsort(distances)[:self.k] count = Counter(self.y_train[kneighbors]) return count.most_common()[0][0] def score(self, x_test, y_test): \u0026#34;\u0026#34;\u0026#34;根据测试样本x_test进行预测，和真实的目标值y_test进行比较，计算预测结果的准确度\u0026#34;\u0026#34;\u0026#34; predictions = [self.knn_classify(x) for x in x_test] correct = np.count_nonzero((predictions == y_test) == True) return float(correct)/len(x_test) def __repr__(self): return \u0026#34;KNN(k={})\u0026#34;.format(self.k) if __name__ == \u0026#34;__main__\u0026#34;: # 从数据集中选择2个样本为测试样本, 其余的均为训练样本 x_train = np.array(raw_data_x[:-2]) y_train = np.array(row_data_y[:-2]) x_test = np.array(raw_data_x[-2:]) y_test = np.array(row_data_y[-2:]) knn = KNNClassifier(3) knn.fit(x_train, y_train) score = knn.score(x_test, y_test) print(\u0026#34;测试精确度为: %.3f\u0026#34; % score) # 未知的待分类样本 x_test2 = np.array([8.9093, 3.3657]) result = knn.knn_classify(x_test2) if result == 0: result = \u0026#34;良性肿瘤\u0026#34; else: result = \u0026#34;恶性肿瘤\u0026#34; print(\u0026#34;对[8.9093, 3.3657]的预测结果为:【%s】\u0026#34; % result) ","date":"2022-11-06T23:37:48+08:00","permalink":"https://lyr-2000.github.io/code/post/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/knn%E7%AE%97%E6%B3%95/","tags":["监督学习"],"title":"KNN算法"},{"categories":["聚类"],"contents":"非监督式学习 Kmeans, KNN, Kmean-shift 算法\n其中KNN 是监督式学习\n非监督式学习没有对和错，只是寻找数据的共同点\n","date":"2022-11-06T16:09:39+08:00","permalink":"https://lyr-2000.github.io/code/post/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%81%9A%E7%B1%BB/%E8%81%9A%E7%B1%BB%E5%9F%BA%E7%A1%80/","tags":["聚类"],"title":"聚类基础"},{"categories":["机器学习"],"contents":"numpy 详细使用方法 numpy 创建数组 1 2 3 4 5 6 7 8 9 10 11 12 import numpy as np np.__version__ L = [i for i in range (10)] print(L) ll = np.array([i for i in range (10)]) print(ll) print(ll.dtype) 属性 描述 dtype 数组类型 dtype 数组类型 numpy 方法使用 方法 总结 full 填充数字 arange 等同于 [i for i in range(1,10)] linspace 生成等差数列 random.randint 生成随机矩阵 random.normal 正太分布矩阵 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import numpy as np np.full((3,5),666) # 3行5列的 矩阵 import numpy as np np.full(shape=(3,5),fill_value=666) # 等同于 [i for i in range(0,1,0.2)], 但是 这样会报错，numpy 可以做到， newarr = np.arange(0,1,0.2) print(newarr) # 生成 3x5 的随机矩阵 l = np.random.randint(4,5,size=(3,5)) print(l) numpy 矩阵操作 矩阵方法 方法 解释 reshape 可以把1维数组转化为多维数组 1 2 3 4 5 6 7 8 9 10 11 12 l = np.arange(15) # 一维数组 l = l.reshape(3,5) # 转二维数组 print(l) \u0026#34;\u0026#34;\u0026#34; [[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14]] \u0026#34;\u0026#34;\u0026#34; 矩阵属性 属性 说明 ndim 维度数量，比如 n*m, 维度是2 shape 元组，表示 维度和大小 ，例如 (n,m) size 元素数量 数据访问 访问一个元素 1 2 3 4 5 6 7 8 9 10 11 12 x = np.arange(0,1,size=(3,5)) print(x[0][0]) # 访问第二行第二列， 可以将 (2,2),简写，得到 x[2,2] print(x[(2,2)]) # 推荐用上面这种原组写法代替数组写法 # 切片 访问一组元素 参考文章 1 2 3 4 5 print(x[:5]) print(x[:2,:3]) # 获取 2x3 的矩阵切片 , 2行3列 numpy 矩阵运算 universal function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 n = 10 L = np.arange(n) A = 2*L print(L) C = A+B C = A-B print(C) # 对应元素相乘 print(A*B) # 标准矩阵运算乘法 # A * B print(A.dot(B) ) # 矩阵转置 =\u0026gt; 行列对角交换 A.T numpy 矩阵乘法的实现原理： 参考文章 python中是支持运算符重载的，只要重载某个函数，就可以实现\nnumpy矩阵运算 1 2 3 4 5 6 7 8 9 np.sin(L) np.cos(L) np.tan(L) np.exp(L) np.power(3,L) # 3^x ,每个矩阵元素 np.log(L) np.log2(L) np.log10(L) 矩阵和向量运算 1 2 # plus C = A+B 其他方法 1 2 np.random.shuffle(x) ","date":"2022-10-30T18:12:46+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python%E8%AF%AD%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/numpy%E8%AF%A6%E7%BB%86%E7%94%A8%E6%B3%95/","tags":["机器学习"],"title":"numpy详细用法"},{"categories":["逻辑回归"],"contents":"逻辑回归实战 分类散点图可视化 逻辑回归模型使用 建立新书籍 模型评估 分类散点图可视化 1 2 3 4 5 6 7 8 9 # 未区分类别散点图 plt.scatter(x1,x2) #区分类别散点图 mask = y==1 type1 = plt.scatter(x1[mask],x2[mask]) type2 = plt.scatter(x1[~mask],x2[~mask],maker=\u0026#39;^\u0026#39;) 逻辑回归实现二分类算法 1 2 3 4 5 6 7 8 9 10 11 # 训练模型 from sklearn.linear_model import logisticRegression lr_model = logisticRegression() lr_model.fit(x,y) # 边界函数 theta1,theta2 = LR.conef_[0][0],LR.coef[0][1] thea0 = LR.intercept_[0] # 数据预测 predictions = lr_model.predict(x_new) 计算准确率 1 2 3 4 5 6 7 8 9 10 11 from sklearn.mertrics import accuracy_score y_predict = LR.predict(x) accuracy = accuracy_score(y,y_predict) # 画图来查看边界效果，可视化模型表现 # 绘制预测的模型图像 plt.plot(x1,x2_boundary) # 绘制周围实际数据的散点图 passed = plt.scatter(x1[mask],x2[mask]) failed = plt.scatter(x1[~mask],x2[~mask],maker=\u0026#39;^\u0026#39;) 预测考试通过率 数据如下：\nExam1, Exam2, Pass\n34 78 0\n30 43 0\n60 86 1\n若干数据\n加载数据集 1 2 3 4 5 6 import pandas as pd import numpy as np data = pd.read_csv(\u0026#39;examdata.csv\u0026#39;) data.head() 绘制散点图 绘制 exam2 为y轴，exam1 为 x轴的图\n定义 mask 为 pass ,如果是 1 就是通过，对mask 取反 就是不通过\n分别绘制 mask, 和 ~mask 的曲线，得到散点图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 %matplotlib inline from matplotlib import pyplot as plt plt.figure(figsize=(4,4)) # plt.figure() \u0026#34;\u0026#34;\u0026#34; plt.scatter(data.loc[:,\u0026#39;Exam1\u0026#39;],data.loc[:,\u0026#39;Exam2\u0026#39;]) plt.title(\u0026#39;exam1 and exam2\u0026#39;) plt.xlabel(\u0026#39;Exam1\u0026#39;) plt.ylabel(\u0026#39;Exam2\u0026#39;) plt.show() \u0026#34;\u0026#34;\u0026#34; # mask --\u0026gt; 通过的， ~mask 表示不通过的 mask = data.loc[:,\u0026#39;Pass\u0026#39;] == 1 # print(mask) fig2 = plt.figure(figsize=(4,4)) passed = plt.scatter(data.loc[:,\u0026#39;Exam1\u0026#39;][mask],data.loc[:,\u0026#39;Exam2\u0026#39;][mask],color=\u0026#39;green\u0026#39;) failed = plt.scatter(data.loc[:,\u0026#39;Exam1\u0026#39;][~mask],data.loc[:,\u0026#39;Exam2\u0026#39;][~mask],color=\u0026#39;red\u0026#39;) plt.xlabel(\u0026#39;Exam1\u0026#39;) plt.ylabel(\u0026#39;Exam2\u0026#39;) plt.legend((passed,failed),(\u0026#39;passed\u0026#39;,\u0026#39;failed\u0026#39;)) plt.show() 模型精准度评估 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 绘制曲线模拟 # 删除最后一列 x = data.drop([\u0026#39;Pass\u0026#39;],axis=1) # print(X) # 获取最后一列 y = data.loc[:,\u0026#39;Pass\u0026#39;] # print(y) x1 = data.loc[:,\u0026#39;Exam1\u0026#39;] x2 = data.loc[:,\u0026#39;Exam2\u0026#39;] # x.head() # 开始训练模式-- 逻辑回归模型 from sklearn.linear_model import LogisticRegression model = LogisticRegression() print(x.shape,y.shape) model.fit(x,y) # 训练模型结束 predict_yvalue = model.predict(x) # print(predict_yvalue) # 准确率 from sklearn.metrics import accuracy_score score = accuracy_score(y,predict_yvalue) print(\u0026#34;模型得分：\u0026#34;,score) # 预测两个考试成绩为 70,65分的是否能通过 print(\u0026#39;passed\u0026#39; if model.predict([[70,65]]) == 1 else \u0026#39;failed\u0026#39;) 绘制拟合曲线 定义拟合曲线 ax+by+c = 0, 求出 曲线系数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 系数 model.coef_ # 截距 model.intercept_ a,b = model.coef_[0][0],model.coef_[0][1] c = model.intercept_ print(a,b,c) y2 = -(c + a* x1)/b print(y2) plt.plot(x1,y2) # plt.show() # ax+by+c = 0 , 线性方程 # ---draw # mask --\u0026gt; 通过的， ~mask 表示不通过的 mask = data.loc[:,\u0026#39;Pass\u0026#39;] == 1 # print(mask) # fig2 = plt.figure(figsize=(4,4)) passed = plt.scatter(data.loc[:,\u0026#39;Exam1\u0026#39;][mask],data.loc[:,\u0026#39;Exam2\u0026#39;][mask],color=\u0026#39;green\u0026#39;) failed = plt.scatter(data.loc[:,\u0026#39;Exam1\u0026#39;][~mask],data.loc[:,\u0026#39;Exam2\u0026#39;][~mask],color=\u0026#39;red\u0026#39;) plt.xlabel(\u0026#39;Exam1\u0026#39;) plt.ylabel(\u0026#39;Exam2\u0026#39;) plt.legend((passed,failed),(\u0026#39;passed\u0026#39;,\u0026#39;failed\u0026#39;)) plt.show() 结果如图所示：\n","date":"2022-10-30T16:37:11+08:00","permalink":"https://lyr-2000.github.io/code/post/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%AE%9E%E6%88%98%E5%87%86%E5%A4%87/","tags":["逻辑回归"],"title":"逻辑回归实战准备"},{"categories":["逻辑回归"],"contents":"逻辑回归模型 由于逻辑回归模型简单，可解释强，易实现，广泛应用于机器学习、深度学习、推荐系统、广告预估、智能营销、金融风控、社会学、生物学、经济学等领域。\n逻辑回归主要场景是分类问题\n$$\np(x) = 1/(1+e^{-(a*x+b)})\n\\\ny=\\left{\n\\begin{array}{rcl}\n1 \u0026amp; \u0026amp; {P(x) \\geq 0 }\\\n0 \u0026amp; \u0026amp; {P(x) \\lt 0}\n\\end{array} \\right.\n$$\n利用逻辑回归预测皮马人糖尿病数据 参考文章 LR逻辑回归模型 皮马人糖尿病预测数据集 判断三角形还是圆形 $$\nP(x) = 1/(1+e^{-g(x)})\n\\\ng(x) = a+bx_1 + cx_2\n$$\n这里我们可以很直观的用高中数学学到的知识，求出这个线性函数表达式\ng(x) = -4 + x_1 + x_2 \u0026gt; 0: 三角形\ng(x) = -4 +x_1 +x_2 \u0026lt;0: 圆形\n我们的目标就是区分三角形和圆形， 要求出这个 g(x) 的表达式\n复杂的数学表达式\n如图所示，我们用上面的方法，也能够实现\n$$\nP(x) = 1/(1+e^{-g(x)})\n\\\ng(x) = a_0 + a_1x_1 + a_2x_2 + a_3x_1^2 + a_4x_2^4\n$$\n我们很容易的求出g(x),\n$g(x) = x_1^2 + x_2 ^2 -1$\ng(x) \u0026gt; 0 是三角形，g(x) \u0026lt; 0 是圆形\n逻辑回归结合多项式边界函数，可以解决复杂的分类问题。\n损失函数 线性回归求解， 最小化损失函数 (J):\n$$\nJ = \\frac{1}{2m}\\sum_{i=1}^{m}(y^{\u0026rsquo;}_i - y_i)\n$$\n上面是线性回归的损失函数，由于这里说的是分类问题，在分类问题中，标签(值)，预测结果都是离散的点，使用这个瞬时函数无法寻找极小值， 因此我们要找到一个 特别的瞬时函数，当 $y_i=0$ 的时候，返回1， $y_i=1$ 的时候，返回0， 得到的 J非常大，来实现惩罚值，告诉计算机\n逻辑回归求解，最小化损失函数 (J):\n$$\nJ_{i}=\\left{\n\\begin{array}{rcl}\n-log(P(x_i)) \u0026amp; \u0026amp; { y_i = 1 }\\\n-log(1-p(x_i) \u0026amp; \u0026amp; {y_i = 0}\n\\end{array} \\right.\n$$\n损失值越大，表示预测越不准确，用来评判一个模型的好坏的\n$$\nJ=\\frac{1}{m}\\sum_{i=1}^{m}j_i = -\\frac{1}{m}[\\sum_{i=1}^{m}(y_i log(P(x_i )) + (1-y_i) log(1-P(x_i)))]\n$$\n","date":"2022-10-30T15:35:07+08:00","permalink":"https://lyr-2000.github.io/code/post/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/","tags":["逻辑回归"],"title":"逻辑回归模型"},{"categories":["线性回归"],"contents":"多因子房价预测 我们要建立一个模型，去预测未来的房价\n以面积为输入变量，建立单子模型，评估模型表现，可视化线性回归预测结果\n以income,house age, numbers of rooms, population、 area为输入变量，建立多因子模型，评估模型表现\nAvg. Area Income Avg. Area House Age Avg. Area Number of Rooms Area Population size Price\n79545.45857 5.317138678 7.009188143 23086.8005 188.2142121 1059033.558\n79248.64245 4.997100192 6.730821019 40173.07217 160.0425258 1505890.915\n61287.06718 5.13411016 8.51272743 36882.1594 227.2735445 1058987.988\n63345.24005 3.811763905 5.586728665 34310.24283 164.8166303 1260616.807\n59982.19723 5.959445477 7.839387785 26354.10947 161.9666587 630943.4893\n80175.75416 6.011592242 6.104512439 26748.42842 156.5346563 1068138.074\n","date":"2022-10-29T21:20:06+08:00","permalink":"https://lyr-2000.github.io/code/post/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/%E5%A4%9A%E5%9B%A0%E5%AD%90%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B/","tags":["线性回归"],"title":"多因子房价预测"},{"categories":["机器学习"],"contents":"回归分析 一元回归 y = f(x) 多元回归 $y = f(x1,x2,x3,x4\u0026hellip;,xn) $ 线性回归 $y=ax+b$ 非线性回归 $y=ax^2+bx $ 过程：\n$P = f(A)$\n确定 P、A的定量关系 scikit-learn 框架介绍 python 中的开源框架，针对机器学习发展起来的， 可以做数据预处理，分类，回归，降维，模型选择等常用的机器学习算法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from sklearn.linear_model import LinearRegression import numpy as np import matplotlib.pyplot as plt # 读取数据 data = np.genfromtxt(\u0026#39;data.csv\u0026#39;, delimiter=\u0026#39;,\u0026#39;) x_data = data[:, 0] y_data = data[:, 1] x_2data = x_data[:, np.newaxis] # 添加列，增加维度，转为二维数据 y_2data = y_data[:, np.newaxis] # 添加列，增加维度，转为二维数据 # 创建并训练模型 model = LinearRegression() model.fit(x_2data, y_2data) # 绘制训练拟合好的模型 plt.scatter(x_data, y_data, c=\u0026#39;b\u0026#39;, s=50) plt.plot(x_data, model.predict(x_2data), color=\u0026#39;red\u0026#39;, linewidth=1.0) plt.show() matplotlib绘图 1 2 3 4 5 6 x = [1,2,3] y = x from matplotlib import pyplot as plt plt.figure(figsize=(20,20)) plt.scatter(x,y) plt.show() sklearn 预测线性函数的值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 x = [i for i in range (1,16)] y = x from matplotlib import pyplot as plt plt.figure(figsize=(4,3)) plt.scatter(x,y) plt.show() # 绘制图像 # sklearn 建立模型 from sklearn.linear_model import LinearRegression model = LinearRegression() import numpy as np x = np.array(x) x = x.reshape(-1,1) y = np.array(y) y = y.reshape(-1,1) model.fit(x,y) predict = model.predict(x) ny = predict # ny 和 y 是一样的，说明 用sklearn 通过 x 预测y值成功 # 输入 12，得到 y的预测值 ans = model.predict([[12]]) print(ans) from sklearn.metrics import mean_squared_error,r2_score mse = mean_squared_error(y,ny) r2 = r2_score(y,ny) print(mse,r2) # mse 接近0， r2 接近1 ，说明拟合非常的好 plt.figure(figsize=(1,1)) plt.plot(x,ny) plt.show() plt.figure(figsize=(1,1)) plt.plot(x,y) plt.show() # 我们可以看到 ny 和 y是一样的，图形也可以看出来 loc 函数用法 参考博客 ","date":"2022-10-29T17:15:11+08:00","permalink":"https://lyr-2000.github.io/code/post/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/","tags":["机器学习"],"title":"监督学习-回归分析"},{"categories":["机器学习"],"contents":"机器学习算法介绍 传统的算法是，给定一函数 $y = 1000 * 1.1^x$\n输入 x,就出各种y\n机器学习这是，输入 x,y ,自动求出 $f(x)$ 的表达式\n机器学习的应用场景：\n数据挖掘 计算机视觉 自然语言处理 医学诊断 证券分析 DNA 测序 机器学习类别 监督学习 (supervised learning) (训练数据包括正确的结果（标签-label)) 无监督学习 【训练数据不包括正确结果】 半监督学习 （训练数据包括少量正确的结果-semi supervised learning) 强化学习（根据每次结果收获的奖惩进行学习，实现优化) 监督学习\u0026ndash; 人脸识别，语音翻译\n无监督学习-新闻聚类\n强化学习 \u0026ndash; alphaGo\n举例子：\n线性回归：\n$距离=速度*t + s_0$\n线性回归其实属于机器学习里面的监督学习\n环境搭建 1 2 3 4 5 6 7 8 9 # 更新 python conda update python conda update pandas conda update numpy conda update scikit-learn # 一次性更新--时间比较长 conda update --all 很多时候 如果能使用 conda 就不使用 pip , pip安装一部分库的时候可能 会出现异常，原因是pip默认下载的一部分库的版本（如SciPy）可能只适用于linux系统，而Anaconda的安装一般不 会有这个问题\n由Anaconda安装的库在使用pip卸载或是更新的时候，可能 出现无法卸载干净，无法正常更新，或更新后一部分库变得无法运行的情况。安装过程中任何的报错，都可以通过卸 载重装来解决问题，这是最有效率的方式\n","date":"2022-10-29T16:31:12+08:00","permalink":"https://lyr-2000.github.io/code/post/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/","tags":["机器学习"],"title":"机器学习算法介绍"},{"categories":["机器学习"],"contents":"numpy 学习 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import numpy as np # 生成 对角线矩阵 a = np.eye(5) b = np.ones([5,5]) # 5 行5列的 矩阵 \u0026#34;\u0026#34;\u0026#34; [[1. 0. 0. 0. 0.] [0. 1. 0. 0. 0.] [0. 0. 1. 0. 0.] [0. 0. 0. 1. 0.] [0. 0. 0. 0. 1.]] \u0026lt;class \u0026#39;numpy.ndarray\u0026#39;\u0026gt; [[1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.]] \u0026#34;\u0026#34;\u0026#34; numpy 矩阵生成的函数\n方法 说明 eye ones 生成一个全都是1 的矩阵 查看np 数组的维度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import numpy as np b = np.ones([5,5]) print(b) # 查看维度，返回元组 print(b.shape) \u0026#34;\u0026#34;\u0026#34; [[1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.]] (5, 5) \u0026#34;\u0026#34;\u0026#34; pandas 使用方法 pandas 相当于 python 中 excel：它使用表（也就是 dataframe)，能在数据上做各种变换，但还有其他很多功能。\n参考博客 了解 pandas 里面的 DataFrame 数据结构\n参考文档 1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;col1\u0026#39;: [1, 2], \u0026#39;col2\u0026#39;: [3, 4]} \u0026gt;\u0026gt;\u0026gt; df = pd.DataFrame(data=d) \u0026gt;\u0026gt;\u0026gt; df col1 col2 0 1 3 1 2 4 data.loc 这个方法会经常用到，需要了解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import pandas as pd # data = pd.read_csv(\u0026#39;data.csv\u0026#39;) # print(type(data)) d = {\u0026#39;col1\u0026#39;: [1, 2], \u0026#39;col2\u0026#39;: [3, 4]} data = pd.DataFrame(d) print(data) x = data.loc[:,\u0026#39;col1\u0026#39;] # 获取所有行，和 \u0026#39;x\u0026#39; 这一列的数据 print(x) \u0026#34;\u0026#34;\u0026#34; col1 col2 0 1 3 1 2 4 0 1 1 2 Name: col1, dtype: int64 \u0026#34;\u0026#34;\u0026#34; sklearn 使用方法 1 2 3 4 from sklearn import datasets iris = datasets.load_iris() iris.data matplotlib 写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import matplotlib as mpl import matplotlib.pyplot as plt import numpy as np x = np.linspace(0,10,100) y = sin(x) plt.plot(x,y) # 最终合并前面的指令，然后绘制出 sin函数的图像 plt.show() # 绘制2条曲线 siny = y.copy() plt.plot(x,siny) plt.plot(x,cosy,color=\u0026#39;red\u0026#39;) plt.show() 通用写法 获取矩阵的第0 列和第一列\n1 2 3 4 5 6 7 8 plt.scatter(X[:,0]) plt.scatter(X[:,1]) plt.scatter(X[y==0,0],X[y==0,1],color=\u0026#39;red\u0026#39;) # 获取 y==0 的第0列和y == 0 的第一列 ","date":"2022-10-29T14:28:30+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python%E8%AF%AD%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","tags":["机器学习"],"title":"机器学习"},{"categories":["贪心"],"contents":" 2136. 全部开花的最早一天 Description Difficulty: 困难\nRelated Topics: 贪心 , 数组 , 排序 你有 n 枚花的种子。每枚种子必须先种下，才能开始生长、开花。播种需要时间，种子的生长也是如此。给你两个下标从 0 开始的整数数组 plantTime 和 growTime ，每个数组的长度都是 n ：\nplantTime[i] 是 播种 第 i 枚种子所需的 完整天数 。每天，你只能为播种某一枚种子而劳作。无须 连续几天都在种同一枚种子，但是种子播种必须在你工作的天数达到 plantTime[i] 之后才算完成。 growTime[i] 是第 i 枚种子完全种下后生长所需的 完整天数 。在它生长的最后一天 之后 ，将会开花并且永远 绽放 。 从第 0 开始，你可以按 任意 顺序播种种子。\n返回所有种子都开花的 最早 一天是第几天。\n示例 1：\n1 2 3 4 5 6 7 8 输入：plantTime = [1,4,3], growTime = [2,3,1] 输出：9 解释：灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。 一种最优方案是： 第 0 天，播种第 0 枚种子，种子生长 2 整天。并在第 3 天开花。 第 1、2、3、4 天，播种第 1 枚种子。种子生长 3 整天，并在第 8 天开花。 第 5、6、7 天，播种第 2 枚种子。种子生长 1 整天，并在第 9 天开花。 因此，在第 9 天，所有种子都开花。 示例 2：\n1 2 3 4 5 6 7 8 9 输入：plantTime = [1,2,3,2], growTime = [2,1,2,1] 输出：9 解释：灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。 一种最优方案是： 第 1 天，播种第 0 枚种子，种子生长 2 整天。并在第 4 天开花。 第 0、3 天，播种第 1 枚种子。种子生长 1 整天，并在第 5 天开花。 第 2、4、5 天，播种第 2 枚种子。种子生长 2 整天，并在第 8 天开花。 第 6、7 天，播种第 3 枚种子。种子生长 1 整天，并在第 9 天开花。 因此，在第 9 天，所有种子都开花。 示例 3：\n1 2 3 4 输入：plantTime = [1], growTime = [1] 输出：2 解释：第 0 天，播种第 0 枚种子。种子需要生长 1 整天，然后在第 2 天开花。 因此，在第 2 天，所有种子都开花。 提示：\nn == plantTime.length == growTime.length 1 \u0026lt;= n \u0026lt;= 105 1 \u0026lt;= plantTime[i], growTime[i] \u0026lt;= 104 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int earliestFullBloom(vector\u0026lt;int\u0026gt;\u0026amp; plantTime, vector\u0026lt;int\u0026gt;\u0026amp; growTime) { int n = plantTime.size(); vector\u0026lt;int\u0026gt; id(n); for(int i=0;i\u0026lt;n;i++) id[i] = i; sort(id.begin(),id.end(),[\u0026amp;growTime](int i,int j) { return growTime[i] \u0026gt; growTime[j]; }); int res=0,day = 0; for(int i:id) { day += plantTime[i]; //播种天数累加和 res = max(res,day + growTime[i]); } return res; } }; ","date":"2022-10-23T22:11:37+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/%E8%B4%AA%E5%BF%83/lc.2136.%E5%85%A8%E9%83%A8%E5%BC%80%E8%8A%B1%E7%9A%84%E6%9C%80%E6%97%A9%E4%B8%80%E5%A4%A9/","tags":["贪心"],"title":"lc.2136.全部开花的最早一天"},{"categories":["树"],"contents":" 2096. 从二叉树一个节点到另一个节点每一步的方向 Description Difficulty: 中等\nRelated Topics: 树 , 深度优先搜索 , 字符串 , 二叉树 给你一棵 二叉树 的根节点 root ，这棵二叉树总共有 n 个节点。每个节点的值为 1 到 n 中的一个整数，且互不相同。给你一个整数 startValue ，表示起点节点 s 的值，和另一个不同的整数 destValue ，表示终点节点 t 的值。\n请找到从节点 s 到节点 t 的 最短路径 ，并以字符串的形式返回每一步的方向。每一步用 大写 字母 'L' ，'R' 和 'U' 分别表示一种方向：\n'L' 表示从一个节点前往它的 左孩子 节点。 'R' 表示从一个节点前往它的 右孩子 节点。 'U' 表示从一个节点前往它的 父 节点。 请你返回从 s 到 t 最短路径 每一步的方向。\n示例 1：\n1 2 3 输入：root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6 输出：\u0026#34;UURL\u0026#34; 解释：最短路径为：3 → 1 → 5 → 2 → 6 。 示例 2：\n1 2 3 输入：root = [2,1], startValue = 2, destValue = 1 输出：\u0026#34;L\u0026#34; 解释：最短路径为：2 → 1 。 提示：\n树中节点数目为 n 。 2 \u0026lt;= n \u0026lt;= 105 1 \u0026lt;= Node.val \u0026lt;= n 树中所有节点的值 互不相同 。 1 \u0026lt;= startValue, destValue \u0026lt;= n startValue != destValue Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: char buf[500000]; string getDirections(TreeNode* root, int startValue, int destValue) { string a,b; buf[0] = \u0026#39;\\0\u0026#39;; getPathString(root,startValue,destValue,a,b,buf,0); int n = a.size(),m = b.size(); int i=0; while(a[i] \u0026amp;\u0026amp; a[i] == b[i]) i++; a = a.substr(i,n); b = b.substr(i,m); for(i=0;i\u0026lt;a.size();i++) a[i] = \u0026#39;U\u0026#39;; return a + b; } // 获取最近公共祖先 void getPathString(TreeNode *root,int a,int b ,string \u0026amp;as,string \u0026amp;bs,char *buf,int k) { if(!root) return; buf[k] = \u0026#39;\\0\u0026#39;; if(root-\u0026gt;val == a) as = buf; if(root-\u0026gt;val == b) bs = buf; buf[k] = \u0026#39;L\u0026#39;; getPathString(root-\u0026gt;left,a,b,as,bs,buf,k+1); buf[k] = \u0026#39;R\u0026#39;; getPathString(root-\u0026gt;right,a,b,as,bs,buf,k+1); } }; ","date":"2022-10-23T21:54:18+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/lc.2096.%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/","tags":["树"],"title":"lc.2096.从二叉树一个节点到另一个节点"},{"categories":["链表"],"contents":" 2130. 链表最大孪生和 Description Difficulty: 中等\nRelated Topics: 栈 , 链表 , 双指针 在一个大小为 n 且 n 为 偶数 的链表中，对于 0 \u0026lt;= i \u0026lt;= (n / 2) - 1 的 i ，第 i 个节点（下标从 0 开始）的孪生节点为第 (n-1-i) 个节点 。\n比方说，n = 4 那么节点 0 是节点 3 的孪生节点，节点 1 是节点 2 的孪生节点。这是长度为 \u0026lt;span style=\u0026quot;\u0026quot;\u0026gt;n = 4\u0026lt;/span\u0026gt; 的链表中所有的孪生节点。 孪生和 定义为一个节点和它孪生节点两者值之和。\n给你一个长度为偶数的链表的头节点 head ，请你返回链表的 最大孪生和 。\n示例 1：\n1 2 3 4 5 6 输入：head = [5,4,2,1] 输出：6 解释： 节点 0 和节点 1 分别是节点 3 和 2 的孪生节点。孪生和都为 6 。 链表中没有其他孪生节点。 所以，链表的最大孪生和是 6 。 示例 2：\n1 2 3 4 5 6 7 输入：head = [4,2,2,3] 输出：7 解释： 链表中的孪生节点为： - 节点 0 是节点 3 的孪生节点，孪生和为 4 + 3 = 7 。 - 节点 1 是节点 2 的孪生节点，孪生和为 2 + 2 = 4 。 所以，最大孪生和为 max(7, 4) = 7 。 示例 3：\n1 2 3 4 输入：head = [1,100000] 输出：100001 解释： 链表中只有一对孪生节点，孪生和为 1 + 100000 = 100001 。 提示：\n链表的节点数目是 [2, 105] 中的 偶数 。 1 \u0026lt;= Node.val \u0026lt;= 105 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ #define Node ListNode #define Next(i) (i? i-\u0026gt;next: NULL) #define printList(i) while(i) printf(\u0026#34;%d \u0026#34;,i-\u0026gt;val),i=i-\u0026gt;next class Solution { public: int pairSum(ListNode* head) { Node *p = head, *q = head; while(p) { p = Next(p-\u0026gt;next); q = q-\u0026gt;next; } //p is null, q before not null Node *tmp = q; // printList(tmp); p = reverse(q); tmp = p; // printList(q); q = head; int maxValue = INT_MIN; while(p \u0026amp;\u0026amp; q) { maxValue = max(maxValue,p-\u0026gt;val + q-\u0026gt;val); p = p-\u0026gt;next; q = q-\u0026gt;next; } reverse(tmp); // printList(head); return maxValue; } Node *reverse(Node *head) { Node *p = head,*pre=NULL; while(p) { Node *ne = p-\u0026gt;next; p-\u0026gt;next = pre; pre = p; p = ne; } return pre; } }; ","date":"2022-10-23T21:28:19+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.2130.%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%AA%E7%94%9F%E5%92%8C/","tags":["链表"],"title":"lc.2130.链表的孪生和"},{"categories":["递推"],"contents":" 2140. 解决智力问题 Description Difficulty: 中等\nRelated Topics: 数组 , 动态规划 给你一个下标从 0 开始的二维整数数组 questions ，其中 questions[i] = [pointsi, brainpoweri] 。\n这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 0开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 i 将让你 获得 pointsi 的分数，但是你将 无法 解决接下来的 brainpoweri 个问题（即只能跳过接下来的 brainpoweri个问题）。如果你跳过问题 i ，你可以对下一个问题决定使用哪种操作。\n比方说，给你 questions = [[3, 2], [4, 3], [4, 4], [2, 5]] ： 如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。 如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。 请你返回这场考试里你能获得的 最高 分数。\n示例 1：\n1 2 3 4 5 6 7 输入：questions = [[3,2],[4,3],[4,4],[2,5]] 输出：5 解释：解决问题 0 和 3 得到最高分。 - 解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。 - 不能解决问题 1 和 2 - 解决问题 3 ：获得 2 分 总得分为：3 + 2 = 5 。没有别的办法获得 5 分或者多于 5 分。 示例 2：\n1 2 3 4 5 6 7 8 输入：questions = [[1,1],[2,2],[3,3],[4,4],[5,5]] 输出：7 解释：解决问题 1 和 4 得到最高分。 - 跳过问题 0 - 解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。 - 不能解决问题 2 和 3 - 解决问题 4 ：获得 5 分 总得分为：2 + 5 = 7 。没有别的办法获得 7 分或者多于 7 分。 提示：\n1 \u0026lt;= questions.length \u0026lt;= 105 questions[i].length == 2 1 \u0026lt;= pointsi, brainpoweri \u0026lt;= 105 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: #define LL long long long long mostPoints(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; questions) { // 选择第i件 和 影响后面 （i,j） 不能选择 //dp[i][1] += max(dp[j+1][1], dp[j+1][0] ) //dp[i][0] += max(dp[i+1][1],dp[i+1][0]) ??? // 定义 dp[i] 为 以i 开头， -- 类似最长上升子序列 // dp[i] = max(dp[i][1].dp[i][0]) int n = questions.size(); vector\u0026lt;LL\u0026gt; dp(n+1); dp[n] = 0; for(int i=n-1;i\u0026gt;=0;i--) { dp[i] = max(dp[i+1], f(questions,dp,i,n)); } return dp[0]; } LL f(vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;q, vector\u0026lt;LL\u0026gt; \u0026amp;dp,int i,int n) { return dp[min(q[i][1]+i + 1, n)] + q[i][0]; } }; ","date":"2022-10-23T16:12:02+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/lc.2140.%E8%A7%A3%E5%86%B3%E6%99%BA%E5%8A%9B%E9%97%AE%E9%A2%98/","tags":["递推"],"title":"lc.2140.解决智力问题"},{"categories":["递推"],"contents":" 2110. 股票平滑下跌阶段的数目 Description Difficulty: 中等\nRelated Topics: 数组 , 数学 , 动态规划 给你一个整数数组 prices ，表示一支股票的历史每日股价，其中 prices[i] 是这支股票第 i 天的价格。\n一个 平滑下降的阶段 定义为：对于 连续一天或者多天 ，每日股价都比 前一日股价恰好少 1 ，这个阶段第一天的股价没有限制。\n请你返回 平滑下降阶段 的数目。\n示例 1：\n1 2 3 4 5 输入：prices = [3,2,1,4] 输出：7 解释：总共有 7 个平滑下降阶段： [3], [2], [1], [4], [3,2], [2,1] 和 [3,2,1] 注意，仅一天按照定义也是平滑下降阶段。 示例 2：\n1 2 3 4 输入：prices = [8,6,7,7] 输出：4 解释：总共有 4 个连续平滑下降阶段：[8], [6], [7] 和 [7] 由于 8 - 6 ≠ 1 ，所以 [8,6] 不是平滑下降阶段。 示例 3：\n1 2 3 输入：prices = [1] 输出：1 解释：总共有 1 个平滑下降阶段：[1] 提示：\n1 \u0026lt;= prices.length \u0026lt;= 105 1 \u0026lt;= prices[i] \u0026lt;= 105 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: long long getDescentPeriods(vector\u0026lt;int\u0026gt;\u0026amp; prices) { // 考虑每个位置为结尾，平滑下降段的段数 // 3 2 1 4 // 1 1+1 (1+2) // dp[i] = f(i) + f(dp[i-1],prices[i],i) int n = prices.size(); vector\u0026lt;long long\u0026gt; dp(n); long long cnt=0; for(int i=0;i\u0026lt;n;i++) { dp[i] += f(i, prices,dp); cnt += dp[i]; } return cnt; // return dp[n]; } long long f(int i,vector\u0026lt;int\u0026gt; \u0026amp;prices,vector\u0026lt;long long\u0026gt; \u0026amp;dp) { if(i==0) return 1; if(prices[i]+1 == prices[i-1]) return 1 + dp[i-1]; return 1; } }; ","date":"2022-10-23T15:55:39+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/lc.2110%E8%82%A1%E7%A5%A8%E5%B9%B3%E6%BB%91%E4%B8%8B%E9%99%8D%E9%98%B6%E6%AE%B5%E6%95%B0%E7%9B%AE/","tags":["递推"],"title":"lc.2110股票平滑下降阶段数目"},{"categories":["字典树"],"contents":" 面试题 17.13. 恢复空格 Description Difficulty: 中等\nRelated Topics: 字典树 , 数组 , 哈希表 , 字符串 , 动态规划 , 哈希函数 , 滚动哈希 哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子\u0026quot;I reset the computer. It still didn’t boot!\u0026quot;已经变成了\u0026quot;iresetthecomputeritstilldidntboot\u0026quot;。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。\n**注意：**本题相对原题稍作改动，只需返回未识别的字符数\n示例：\n1 2 3 4 5 输入： dictionary = [\u0026#34;looked\u0026#34;,\u0026#34;just\u0026#34;,\u0026#34;like\u0026#34;,\u0026#34;her\u0026#34;,\u0026#34;brother\u0026#34;] sentence = \u0026#34;jesslookedjustliketimherbrother\u0026#34; 输出： 7 解释： 断句后为\u0026#34;jess looked just like tim her brother\u0026#34;，共7个未识别字符。 提示：\n0 \u0026lt;= len(sentence) \u0026lt;= 1000 dictionary中总字符数不超过 150000。 你可以认为dictionary和sentence中只包含小写字母。 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 struct Node { Node() { flag=false; for(int i=0;i\u0026lt;26;i++) next[i] = NULL; } bool flag; Node *next[26]; }; struct Trie { Trie() { root = new Node(); } Node *root; void insert(string \u0026amp;s) { Node *p = root; int n = s.size(); for(int i=0;i\u0026lt;n;i++) { int ind = s[i] - \u0026#39;a\u0026#39;; if(p-\u0026gt;next[ind] == NULL) p-\u0026gt;next[ind] = new Node(); p = p-\u0026gt;next[ind]; } p -\u0026gt;flag=true; } // bool query(string \u0026amp;p) { // Node *p = root; // int n = p.size(); // for(int i=0;i\u0026lt;n;i++) { // int ind = p[i] - \u0026#39;a\u0026#39;; // if(p-\u0026gt;next[ind] == NULL) // return false; // // p-\u0026gt;next[ind] = new Node(); // p = p-\u0026gt;next[ind]; // } // // p -\u0026gt;flag=true; // return p-\u0026gt;flag; // } void get_mark(string \u0026amp;s, int pos,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;mark) { int pre_pos = pos; // Node *p = root; for(int i=pos,n = s.size();i\u0026lt;n;i++) { int ind = s[i] - \u0026#39;a\u0026#39;; p = p-\u0026gt;next[ind]; if(!p) break; if(p-\u0026gt;flag) mark[i+1].push_back(pos); } } }; class Solution { public: int respace(vector\u0026lt;string\u0026gt;\u0026amp; dictionary, string sentence) { Trie tree; for(auto s:dictionary) tree.insert(s); int n = sentence.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; mark(n+1); //mark[i] ,i 作为结尾的 起始位置集合 vector\u0026lt;int\u0026gt; dp(n+1); for(int i=0;i\u0026lt;n;i++) { tree.get_mark(sentence,i,mark); } dp[0] = 0;// init -- for(int i=1;i\u0026lt;=n;i++) { dp[i] = dp[i-1] + 1; for(int j: mark[i]) { dp[i] = min(dp[i], dp[j]); } } return dp[n]; } }; ","date":"2022-10-23T15:44:38+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8%E6%A0%91/lc.17.13.%E6%81%A2%E5%A4%8D%E7%A9%BA%E6%A0%BC/","tags":["字典树"],"title":"lc.17.13.恢复空格"},{"categories":["二分"],"contents":" 1477. 找两个和为目标值且不重叠的子数组 Description Difficulty: 中等\nRelated Topics: 数组 , 哈希表 , 二分查找 , 动态规划 , 滑动窗口 给你一个整数数组 arr 和一个整数值 target 。\n请你在 arr 中找 两个互不重叠的子数组 且它们的和都等于 target 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。\n请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 -1 。\n示例 1：\n1 2 3 输入：arr = [3,2,2,4,3], target = 3 输出：2 解释：只有两个子数组和为 3 （[3] 和 [3]）。它们的长度和为 2 。 示例 2：\n1 2 3 输入：arr = [7,3,4,7], target = 7 输出：2 解释：尽管我们有 3 个互不重叠的子数组和为 7 （[7], [3,4] 和 [7]），但我们会选择第一个和第三个子数组，因为它们的长度和 2 是最小值。 示例 3：\n1 2 3 输入：arr = [4,3,2,6,2,3,4], target = 6 输出：-1 解释：我们只有一个和为 6 的子数组。 示例 4：\n1 2 3 输入：arr = [5,5,4,4,5], target = 3 输出：-1 解释：我们无法找到和为 3 的子数组。 示例 5：\n1 2 3 输入：arr = [3,1,1,1,5,1,2,1], target = 3 输出：3 解释：注意子数组 [1,2] 和 [2,1] 不能成为一个方案因为它们重叠了。 提示：\n1 \u0026lt;= arr.length \u0026lt;= 10^5 1 \u0026lt;= arr[i] \u0026lt;= 1000 1 \u0026lt;= target \u0026lt;= 10^8 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: int minSumOfLengths(vector\u0026lt;int\u0026gt;\u0026amp; arr, int target) { int n = arr.size() , l=0,r=-1,sum = 0; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; pir; for(r=0;r\u0026lt;n;r++) { sum += arr[r]; while(sum \u0026gt; target \u0026amp;\u0026amp; l\u0026lt;=r) { sum -= arr[l++]; } if(sum == target) pir.push_back({l,r}); } //当前区间前面最短区间的长度， int pre_min_ind=-1,preMin = n+1; int ans = -1; for(int i=0;i\u0026lt;pir.size();i++) { auto x = pir[i]; while(pir[pre_min_ind + 1].second \u0026lt;x.first) { pre_min_ind ++; preMin = min(preMin,pir[pre_min_ind].second - pir[pre_min_ind].first + 1); } if(pre_min_ind == -1) continue; if(ans == -1 || ans \u0026gt; preMin + x.second - x.first + 1) { ans = preMin + x.second - x.first + 1; } } return ans; } }; ","date":"2022-10-23T15:27:47+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/lc.1447.%E4%B8%A4%E4%B8%AA%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B8%8D%E9%87%8D%E5%8F%A0%E5%AD%90%E6%95%B0%E7%BB%84/","tags":["二分"],"title":"lc.1447.两个和为目标值不重叠子数组"},{"categories":["二分"],"contents":" 1723. 完成所有工作的最短时间 Description Difficulty: 困难\nRelated Topics: 位运算 , 数组 , 动态规划 , 回溯 , 状态压缩 给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。\n请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。\n返回分配方案中尽可能 最小 的 最大工作时间 。\n示例 1：\n1 2 3 输入：jobs = [3,2,3], k = 3 输出：3 解释：给每位工人分配一项工作，最大工作时间是 3 。 示例 2：\n1 2 3 4 5 6 输入：jobs = [1,2,4,7,8], k = 2 输出：11 解释：按下述方式分配工作： 1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11） 2 号工人：4、7（工作时间 = 4 + 7 = 11） 最大工作时间是 11 。 提示：\n1 \u0026lt;= k \u0026lt;= jobs.length \u0026lt;= 12 1 \u0026lt;= jobs[i] \u0026lt;= 107 Solution Language: C++\n二分法+ 回溯法 先用二分枚举最大值的范围，然后 再依次去用回溯法判断这个范围中数值的合法性，不合法就抛弃，合法就记录下来，继续枚举更优的答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Solution { public: int minimumTimeRequired(vector\u0026lt;int\u0026gt;\u0026amp; jobs, int k) { int l = jobs[0]; int r = jobs[0]; int tmp=0; for(int x:jobs) l = max(l,x),tmp+= x; r = max(tmp,r); // vector\u0026lt;int\u0026gt; worker(k); int m; while(l\u0026lt;r) { m = l + (r-l)/2; if(check(jobs,k,m)) { r = m; }else l = m+1; } return r; } bool check(vector\u0026lt;int\u0026gt; \u0026amp;jobs,int k,int limit) { vector\u0026lt;int\u0026gt; work(k,0); return dfs(jobs,work,limit,0); } bool dfs(vector\u0026lt;int\u0026gt; \u0026amp;jobs,vector\u0026lt;int\u0026gt; \u0026amp;work,int limit,int jobi) { if(jobi \u0026gt;= jobs.size()) { return true; } int curr = jobs[jobi]; if(curr \u0026gt; limit) return false; int n = work.size(); for(int i=0;i\u0026lt;n;i++) { // 工作量是相同的 if(curr + work[i] \u0026lt;= limit) { work[i] += curr; if(dfs(jobs,work,limit,jobi+1)) { return true; } work[i] -= curr; } //当前空闲都无法分配，那必然后续无法分配 if(work[i] == 0) return false; if(work[i] + curr == limit) return false; //当前刚好分配满，都无法 满足，那必然也无法分配 } return false; } }; 解法二 回溯法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: int minimumTimeRequired(vector\u0026lt;int\u0026gt;\u0026amp; jobs, int k) { ans = INT_MAX; vector\u0026lt;int\u0026gt; work(k); dfs(jobs,work,0,0); return ans; } int ans=0; bool dfs(vector\u0026lt;int\u0026gt; \u0026amp;jobs,vector\u0026lt;int\u0026gt; \u0026amp;work,int limit,int jobi) { if(jobi \u0026gt;= jobs.size()) { ans = limit; return true; } int curr = jobs[jobi]; int n = work.size(); for(int i=0;i\u0026lt;n;i++) { // 工作量是相同的 if(work[i] + curr \u0026gt; ans) continue; work[i] += curr; dfs(jobs,work,max(limit,work[i]) ,jobi+1); work[i] -= curr; //当前空闲都无法分配，那必然后续无法分配 if(work[i] == 0) return false; // if(work[i] + curr == limit) // return false; //当前刚好分配满，都无法 满足，那必然也无法分配 } return false; } }; ","date":"2022-10-23T14:53:58+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/lc.284.%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%9C%80%E7%9F%AD%E6%97%B6%E9%97%B4/","tags":["二分"],"title":"lc.284.完成所有工作的最短时间"},{"categories":["堆"],"contents":" 502. IPO Description Difficulty: 困难\nRelated Topics: 贪心 , 数组 , 排序 , 堆（优先队列） 假设 力扣（LeetCode）即将开始 IPO 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。\n给你 n 个项目。对于每个项目 i，它都有一个纯利润 profits[i] ，和启动该项目需要的最小资本 capital[i] 。\n最初，你的资本为 w 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。\n总而言之，从给定项目中选择 最多 k 个不同项目的列表，以 最大化最终资本 ，并输出最终可获得的最多资本。\n答案保证在 32 位有符号整数范围内。\n示例 1：\n1 2 3 4 5 6 7 8 输入：k = 2, w = 0, profits = [1,2,3], capital = [0,1,1] 输出：4 解释： 由于你的初始资本为 0，你仅可以从 0 号项目开始。 在完成后，你将获得 1 的利润，你的总资本将变为 1。 此时你可以选择开始 1 号或 2 号项目。 由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。 因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。 示例 2：\n1 2 输入：k = 3, w = 0, profits = [1,2,3], capital = [0,1,2] 输出：6 提示：\n1 \u0026lt;= k \u0026lt;= 105 0 \u0026lt;= w \u0026lt;= 109 n == profits.length n == capital.length 1 \u0026lt;= n \u0026lt;= 105 0 \u0026lt;= profits[i] \u0026lt;= 104 0 \u0026lt;= capital[i] \u0026lt;= 109 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int findMaximizedCapital(int k, int w, vector\u0026lt;int\u0026gt;\u0026amp; profits, vector\u0026lt;int\u0026gt;\u0026amp; capital) { int n = profits.size(); vector\u0026lt;int\u0026gt; ind(n); for(int i=0;i\u0026lt;n;i++) ind[i] = i; sort(ind.begin(),ind.end(), [\u0026amp;](int i,int j) -\u0026gt; bool { return capital[i] \u0026lt; capital[j];}) ; priority_queue\u0026lt;int\u0026gt; q; int i=0; while(k--) { while(i\u0026lt;n \u0026amp;\u0026amp; capital[ind[i]] \u0026lt;= w) q.push(profits[ind[i]]), i++; if(q.empty()) break; w += q.top(); q.pop(); } return w; } }; ","date":"2022-10-23T13:58:05+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/lc.501.ipo/","tags":["堆"],"title":"lc.501.IPO"},{"categories":["数学"],"contents":" LCP 02. 分式化简 Description Difficulty: 简单\nRelated Topics: 数组 , 数学 , 数论 , 模拟 有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？\n连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。\n输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。返回一个长度为2的数组[n, m]，使得连分数的值等于n / m，且n, m最大公约数为1。\n示例 1：\n1 2 3 输入：cont = [3, 2, 0, 2] 输出：[13, 4] 解释：原连分数等价于3 + (1 / (2 + (1 / (0 + 1 / 2))))。注意[26, 8], [-13, -4]都不是正确答案。 示例 2：\n1 2 3 输入：cont = [0, 0, 3] 输出：[3, 1] 解释：如果答案是整数，令分母为1即可。 限制：\ncont[i] \u0026gt;= 0 1 \u0026lt;= cont的长度 \u0026lt;= 10 cont最后一个元素不等于0 答案的n, m的取值都能被32位int整型存下（即不超过2 ^ 31 - 1）。 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: vector\u0026lt;int\u0026gt; fraction(vector\u0026lt;int\u0026gt;\u0026amp; cont) { int n = cont.size(); int up=1,down=0; for(int i=n-1;i\u0026gt;=0;i--) { swap(up,down); up = cont[i] * down+ up; // up = 1/(a2 + 1/(a3 + 0{up}/1{down})) } return {up,down}; } }; ","date":"2022-10-22T23:21:50+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/lcp.02.%E5%88%86%E5%BC%8F%E5%8C%96%E7%AE%80/","tags":["数学"],"title":"lcp.02.分式化简"},{"categories":["双指针"],"contents":" 142. 环形链表 II Description Difficulty: 中等\nRelated Topics: 哈希表 , 链表 , 双指针 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n不允许修改 链表。\n示例 1：\n1 2 3 输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：\n1 2 3 输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：\n1 2 3 输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。 提示：\n链表中节点的数目范围在范围 [0, 104] 内 -105 \u0026lt;= Node.val \u0026lt;= 105 pos 的值为 -1 或者链表中的一个有效索引 **进阶：**你是否可以使用 O(1) 空间解决此题？\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ #define Next(x) (x? x-\u0026gt;next:NULL) class Solution { public: #define Node ListNode ListNode *detectCycle(ListNode *head) { if(!head) return NULL; Node* x = head; Node*y = head; do { x = Next(x); y = Next(Next(y)); }while(x \u0026amp;\u0026amp; x!=y); if(!y) return NULL; x = head; while(x!=y){ x = Next(x); y = Next(y); }; return x; } }; ","date":"2022-10-22T22:42:35+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82/","tags":["双指针"],"title":"环形链表2"},{"categories":["双指针"],"contents":" 457. 环形数组是否存在循环 Description Difficulty: 中等\nRelated Topics: 数组 , 哈希表 , 双指针 存在一个不含 0 的 环形 数组 nums ，每个 nums[i] 都表示位于下标 i 的角色应该向前或向后移动的下标个数：\n如果 nums[i] 是正数，向前（下标递增方向）移动 |nums[i]| 步 如果 nums[i] 是负数，向后（下标递减方向）移动 |nums[i]| 步 因为数组是 环形 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。\n数组中的 循环 由长度为 k 的下标序列 seq 标识：\n遵循上述移动规则将导致一组重复下标序列 seq[0] -\u0026gt; seq[1] -\u0026gt; ... -\u0026gt; seq[k - 1] -\u0026gt; seq[0] -\u0026gt; ... 所有 nums[seq[j]] 应当不是 全正 就是 全负 k \u0026gt; 1 如果 nums 中存在循环，返回 true ；否则，返回false。\n示例 1：\n1 2 3 输入：nums = [2,-1,1,2,2] 输出：true 解释：存在循环，按下标 0 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 0 。循环长度为 3 。 示例 2：\n1 2 3 输入：nums = [-1,2] 输出：false 解释：按下标 1 -\u0026gt; 1 -\u0026gt; 1 ... 的运动无法构成循环，因为循环的长度为 1 。根据定义，循环的长度必须大于 1 。 示例 3:\n1 2 3 4 输入：nums = [-2,1,-1,-2,-2] 输出：false 解释：按下标 1 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; ... 的运动无法构成循环，因为 nums[1] 是正数，而 nums[2] 是负数。 所有 nums[seq[j]] 应当不是全正就是全负。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 5000 -1000 \u0026lt;= nums[i] \u0026lt;= 1000 nums[i] != 0 **进阶：**你能设计一个时间复杂度为 O(n) 且额外空间复杂度为 O(1) 的算法吗？\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public: int next(int p,vector\u0026lt;int\u0026gt; \u0026amp;nums) { int n = nums.size(); int add = n * 1000; int x = nums[p]; if(x \u0026lt; 0) add = -add; nums[p] += add; p = ((p+x) % n + n)%n; return p; } bool circularArrayLoop(vector\u0026lt;int\u0026gt;\u0026amp; nums) { //循环的定义，k\u0026gt;1 ,所有地点都是一个符号， 成环 int n = nums.size(); if(n\u0026lt;=1) return false; for(int i=0;i\u0026lt;n;i++) { if(abs(nums[i]) \u0026gt; 1000) continue; //前面已经走过了，就跳过 int p=i,q=i; do { p = next(p,nums); q = next(next(q,nums),nums); }while(p!=q); int a=0,b=0,k=0; do { if (nums[p] \u0026gt; 0) a++; else b++; k++; p = next(p,nums); }while(p!=q); if (k\u0026gt;1 \u0026amp;\u0026amp; (a==0 || b == 0)) return true; } return false; } }; ","date":"2022-10-22T22:34:38+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/lc.457.%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%BE%AA%E7%8E%AF/","tags":["双指针"],"title":"lc.457.环形数组是否存在循环"},{"categories":["数学"],"contents":" 2001. 可互换矩形的组数 Description Difficulty: 中等\nRelated Topics: 数组 , 哈希表 , 数学 , 计数 , 数论 用一个下标从 0 开始的二维整数数组 rectangles 来表示 n 个矩形，其中 rectangles[i] = [widthi, heighti] 表示第 i 个矩形的宽度和高度。\n如果两个矩形 i 和 j（i \u0026lt; j）的宽高比相同，则认为这两个矩形 可互换 。更规范的说法是，两个矩形满足 widthi/heighti == widthj/heightj（使用实数除法而非整数除法），则认为这两个矩形 可互换 。\n计算并返回 rectangles 中有多少对 可互换 矩形。\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：rectangles = [[4,8],[3,6],[10,20],[15,30]] 输出：6 解释：下面按下标（从 0 开始）列出可互换矩形的配对情况： - 矩形 0 和矩形 1 ：4/8 == 3/6 - 矩形 0 和矩形 2 ：4/8 == 10/20 - 矩形 0 和矩形 3 ：4/8 == 15/30 - 矩形 1 和矩形 2 ：3/6 == 10/20 - 矩形 1 和矩形 3 ：3/6 == 15/30 - 矩形 2 和矩形 3 ：10/20 == 15/30 示例 2：\n1 2 3 输入：rectangles = [[4,5],[7,8]] 输出：0 解释：不存在成对的可互换矩形。 提示：\nn == rectangles.length 1 \u0026lt;= n \u0026lt;= 105 rectangles[i].length == 2 1 \u0026lt;= widthi, heighti \u0026lt;= 105 Solution 解题思路，将 a/b 得到的答案 计算 出相同的数量 n，然后是一个组合数学的算法， 组数 = n*(n-1)/2\nLanguage: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: // int gcd(int a,int b) { // if(!b ) return a; // return gcd(b,a%b); // } struct Data { int a,b; Data(int a,int b):a(a),b(b) { int c = gcd(a,b); this-\u0026gt;a = a/c; this-\u0026gt;b = b/c; } bool operator \u0026lt; (const Data \u0026amp;h) const { if(a - h.a) return a \u0026lt; h.a; return b\u0026lt;h.b; } }; long long interchangeableRectangles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; rectangles) { //Data d(15,30); //cout \u0026lt;\u0026lt; d.a \u0026lt;\u0026lt; \u0026#34; \u0026#34;\u0026lt;\u0026lt;d.b \u0026lt;\u0026lt; \u0026#34;,gcd=\u0026#34;\u0026lt;\u0026lt; gcd(1,2)\u0026lt;\u0026lt;endl; map\u0026lt;Data,uint64_t\u0026gt; h; uint64_t ans=0; for(auto \u0026amp;vp: rectangles) { Data d(vp[0],vp[1]); ans += h[d]; h[d]++; } return ans; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: long long interchangeableRectangles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; rectangles) { long long res =0; unordered_map\u0026lt;double,long long\u0026gt; mp; // exit(0); for(auto item: rectangles) { double a = item[0],b = item[1]; mp[a/b]++; } for(auto [k,v]: mp) { res += calc(v); } return res; } long long calc(long long u) { return (u-1)*u /2; } }; ","date":"2022-10-22T22:00:35+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/lc.2001.%E5%8F%AF%E4%BA%92%E6%8D%A2%E7%9F%A9%E5%BD%A2%E7%9A%84%E7%BB%84%E6%95%B0/","tags":["数学"],"title":"lc.2001.可互换矩形的组数"},{"categories":["数学"],"contents":" 914. 卡牌分组 Description Difficulty: 简单\nRelated Topics: 数组 , 哈希表 , 数学 , 计数 , 数论 给定一副牌，每张牌上都写着一个整数。\n此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：\n每组都有 X 张牌。 组内所有的牌上都写着相同的整数。 仅当你可选的 X \u0026gt;= 2 时返回 true。\n示例 1：\n1 2 3 输入：deck = [1,2,3,4,4,3,2,1] 输出：true 解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4] 示例 2：\n1 2 3 输入：deck = [1,1,1,2,2,2,3,3] 输出：false 解释：没有满足要求的分组。 提示：\n1 \u0026lt;= deck.length \u0026lt;= 104 0 \u0026lt;= deck[i] \u0026lt; 104 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: bool hasGroupsSizeX(vector\u0026lt;int\u0026gt;\u0026amp; deck) { int n = deck.size(); unordered_map\u0026lt;int,int\u0026gt; mp; for(auto x:deck) mp[x]++; int res=0; for(auto [k,cnt]: mp) { res = gcd(res, cnt); if (res == 1) return false; } return res; } int gcd(int a,int b) { if(!b) return a; return gcd(b,a%b); } }; ","date":"2022-10-22T21:42:21+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/lc.914.%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84/","tags":["数学"],"title":"lc.914.卡牌分组"},{"categories":["双指针"],"contents":" 1004. 最大连续1的个数 III Description Difficulty: 中等\nRelated Topics: 数组 , 二分查找 , 前缀和 , 滑动窗口 给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。\n示例 1：\n1 2 3 4 输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2 输出：6 解释：[1,1,1,0,0,1,1,1,1,1,1] 粗体数字从 0 翻转到 1，最长的子数组长度为 6。 示例 2：\n1 2 3 4 输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3 输出：10 解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1] 粗体数字从 0 翻转到 1，最长的子数组长度为 10。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 nums[i] 不是 0 就是 1 0 \u0026lt;= k \u0026lt;= nums.length Solution 思路：\n双指针： 如果 窗口的0的水量小于等于k,就能继续扩容，否则就要丢弃前面得到的数，直到能放下0为止\nLanguage: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: int longestOnes(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int l=0,r= -1; int n = nums.size(); int cnt0=0; int res=0; while(true) { if(cnt0 \u0026lt;= k) { //还能翻转0 r+=1; if(r == n) { // ok break; } if (nums[r] == 0) { cnt0++; } }else { // 不能翻转0，只能出队 while(nums[l]!=0) l++; if(nums[l] == 0) l++,cnt0--; //出队，最长连续1的个数就在此处 } if (cnt0 \u0026lt;= k) res = max(res, r-l+1); } return res; } }; ","date":"2022-10-22T21:17:29+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/lc.1004.%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/","tags":["双指针"],"title":"lc.1004.最大连续1的个数"},{"categories":["数学"],"contents":" 926. 将字符串翻转到单调递增 Description Difficulty: 中等\nRelated Topics: 字符串 , 动态规划 如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。\n给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。\n返回使 s 单调递增的最小翻转次数。\n示例 1：\n1 2 3 输入：s = \u0026#34;00110\u0026#34; 输出：1 解释：翻转最后一位得到 00111. 示例 2：\n1 2 3 输入：s = \u0026#34;010110\u0026#34; 输出：2 解释：翻转得到 011111，或者是 000111。 示例 3：\n1 2 3 输入：s = \u0026#34;00011000\u0026#34; 输出：2 解释：翻转得到 00000000。 提示：\n1 \u0026lt;= s.length \u0026lt;= 105 s[i] 为 '0' 或 '1' Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int minFlipsMonoIncr(string s) { int n0=0,n1=0; for(auto x:s) if(x == \u0026#39;0\u0026#39;) n0++; int ans = n0; for(auto x:s) { //x开始，前面都是0，后面都是1 【后面0变成1，前面1变成0】 if(x == \u0026#39;0\u0026#39;) { n0--; }else { // 前面 1的数量 n1++; } ans = min(ans,n0 + n1); } return ans; } }; ","date":"2022-10-21T00:29:52+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/lc.926.%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BF%BB%E8%BD%AC%E5%88%B0%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E/","tags":["数学"],"title":"lc.926.将字符串翻转到单调递增"},{"categories":["数学"],"contents":" 1819. 序列中不同最大公约数的数目 Description Difficulty: 困难\nRelated Topics: 数组 , 数学 , 计数 , 数论 给你一个由正整数组成的数组 nums 。\n数字序列的 最大公约数 定义为序列中所有整数的共有约数中的最大整数。\n例如，序列 [4,6,16] 的最大公约数是 2 。 数组的一个 子序列 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。\n例如，[2,5,10] 是 [1,2,1,**2**,4,1,**5**,**10**] 的一个子序列。 计算并返回 nums 的所有 非空 子序列中 不同 最大公约数的 数目 。\n示例 1：\n1 2 3 4 输入：nums = [6,10,3] 输出：5 解释：上图显示了所有的非空子序列与各自的最大公约数。 不同的最大公约数为 6 、10 、3 、2 和 1 。 示例 2：\n1 2 输入：nums = [5,15,40,5,6] 输出：7 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= nums[i] \u0026lt;= 2 * 105 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: //求多少种最大公约数 int countDifferentSubsequenceGCDs(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int g[200005] = {0}; int maxn = 0; for (auto x:nums) { maxn = max(maxn,x); g[x] = x; } int cnt=0; for(int i=1;i\u0026lt;=maxn;i++) { int ans=-1; for(int j=i;j\u0026lt;=maxn;j+=i) { if(g[j] == 0) continue; if(ans == -1) ans = j; else ans = gcd(ans,j); if(ans == i) break; } if(ans == i) cnt++; } return cnt; } }; ","date":"2022-10-21T00:06:51+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/lc.1819.%E5%BA%8F%E5%88%97%E4%B8%AD%E4%B8%8D%E5%90%8C%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E6%95%B0%E9%87%8F/","tags":["数学"],"title":"lc.1819.序列中不同最大公约数数量"},{"categories":["数学"],"contents":" 229. 多数元素 II Description Difficulty: 中等\nRelated Topics: 数组 , 哈希表 , 计数 , 排序 给定一个大小为 _n_的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。\n示例 1：\n1 2 输入：nums = [3,2,3] 输出：[3] 示例 2：\n1 2 输入：nums = [1] 输出：[1] 示例 3：\n1 2 输入：nums = [1,2] 输出：[1,2] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 5 * 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 **进阶：**尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。\nSolution 解题思路，摩尔投票法\n摩尔投票法，解决的问题是如何在任意多的候选人中，选出票数超过一半的那个人。注意，是超出一半票数的那个人。\n假设投票是这样的，[A, C, A, A, B]，ABC 是指三个候选人。\n第一张票与第二张票进行对坑，如果票不同则互相抵消掉；\n接着第三票与第四票进行对坑，如果票相同，则增加这个候选人的可抵消票数；\n这个候选人拿着可抵消票数与第五张票对坑，如果票不同，则互相抵消掉，即候选人的可抵消票数 -1。\nLanguage: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: vector\u0026lt;int\u0026gt; majorityElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int a=0,b=0,ac=0,bc=0; for(auto num :nums) { if(a \u0026amp;\u0026amp; a == num)ac++; else if(b \u0026amp;\u0026amp; b == num) bc++; else if(!ac) a=num,ac=1; else if(!bc) b=num,bc=1; else { ac--; bc--; } // if(num == a || ac == 0) { // ac++; // a = num; // }else if(num == b || bc == 0 ) { // bc++; // b = num; // }else { // ac--; // bc--; // } } ac=0; bc = 0; for(auto n:nums) { if (n == a) ac++; if(n ==b) bc++; } vector\u0026lt;int\u0026gt; ret; if (ac *3\u0026gt; nums.size()) ret.push_back(a); if( a!=b \u0026amp;\u0026amp; bc*3\u0026gt;nums.size() ) ret.push_back(b); return ret; } }; ","date":"2022-10-20T00:22:02+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/lc.229.%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0ii/","tags":["数学"],"title":"lc.229.多数元素II"},{"categories":["数学"],"contents":" 1201. 丑数 III Description Difficulty: 中等\nRelated Topics: 数学 , 二分查找 , 数论 给你四个整数：n 、a 、b 、c ，请你设计一个算法来找出第 n 个丑数。\n丑数是可以被 a 或 b 或 c 整除的 正整数 。\n示例 1：\n1 2 3 输入：n = 3, a = 2, b = 3, c = 5 输出：4 解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。 示例 2：\n1 2 3 输入：n = 4, a = 2, b = 3, c = 4 输出：6 解释：丑数序列为 2, 3, 4, 6, 8, 9, 10, 12... 其中第 4 个是 6。 示例 3：\n1 2 3 输入：n = 5, a = 2, b = 11, c = 13 输出：10 解释：丑数序列为 2, 4, 6, 8, 10, 11, 12, 13... 其中第 5 个是 10。 示例 4：\n1 2 输入：n = 1000000000, a = 2, b = 217983653, c = 336916467 输出：1999999984 提示：\n1 \u0026lt;= n, a, b, c \u0026lt;= 10^9 1 \u0026lt;= a * b * c \u0026lt;= 10^18 本题结果在 [1, 2 * 10^9] 的范围内 Solution 解题思路：\n利用容斥原理可以计算出 丑数的数量，然后用二分法枚举答案\n需要知道的公式：\n$lcm(a,b) = a*b/gcd(a,b)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #define LL long long class Solution { public: int nthUglyNumber(int n, int a, int b, int c) { lab = lcm(a,b); lbc = lcm(b,c); lac = lcm(a,c); labc = lcm(lab,c); // 利用二分，二分出第 N个丑数的位置 LL l = 1, r = 1e18; while(l\u0026lt;r) { LL m = l + (r-l) /2; if(count(a,b,c,m) \u0026gt;= n) r = m; else l = m+1; } return r; } LL gcd(LL a,LL b) { if(!b) return a; return gcd(b,a%b); } LL lcm(LL a,LL b) { //ab 最小公倍数= a*b / ab最大公约数 return a*b/gcd(a,b); } LL lab; LL lbc; LL lac; LL labc; LL count(LL a,LL b,LL c,LL target) { //容斥原理 return target/a + target/b + target/c - target / lab - target / lbc - target/lac + target / labc; } }; 暴力解法 这里提供一个我一开始想到的暴力做法，超时了，但是也是一种思路\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: int nthUglyNumber(int n, int a, int b, int c) { set\u0026lt;int\u0026gt; s; int ai=1,bi=1,ci=1; for(int i=0;i\u0026lt;n;i++) { int target =0; while(true) { target = forward(a,b,c,ai,bi,ci); if(!s.count(target)) break; } s.insert(target); } auto back = s.end(); back--; return *back; } int forward(int a,int b,int c,int \u0026amp;ai,int \u0026amp;bi,int \u0026amp;ci) { a = a*ai; b = b*bi; c = c*ci; if(a\u0026lt; min(b,c)) { ai++; } else if(b\u0026lt;min(a,c)) { bi++; }else { ci++; } return min(a,min(b,c)); } }; ","date":"2022-10-19T23:46:57+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/lc.1201.%E4%B8%91%E6%95%B0/","tags":["数学"],"title":"lc.1201.丑数"},{"categories":["链表"],"contents":" 剑指 Offer II 029. 排序的循环链表 Description Difficulty: 中等\nRelated Topics: 链表 给定循环单调非递减列表中的一个点，写一个函数向这个列表中插入一个新元素 insertVal ，使这个列表仍然是循环升序的。\n给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。\n如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。\n如果列表为空（给定的节点是 null），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。\n示例 1：\n1 2 3 输入：head = [3,4,1], insertVal = 2 输出：[3,4,1,2] 解释：在上图中，有一个包含三个元素的循环有序列表，你获得值为 3 的节点的指针，我们需要向表中插入元素 2 。新插入的节点应该在 1 和 3 之间，插入之后，整个列表如上图所示，最后返回节点 3 。 示例 2：\n1 2 3 输入：head = [], insertVal = 1 输出：[1] 解释：列表为空（给定的节点是 null），创建一个循环有序列表并返回这个节点。 示例 3：\n1 2 输入：head = [1], insertVal = 0 输出：[1,0] 提示：\n0 \u0026lt;= Number of Nodes \u0026lt;= 5 * 10^4 \u0026lt;font face=\u0026quot;monospace\u0026quot;\u0026gt;-10^6 \u0026lt;= Node.val \u0026lt;= 10^6\u0026lt;/font\u0026gt; -10^6 \u0026lt;= insertVal \u0026lt;= 10^6 注意：本题与主站 708 题相同： https://leetcode-cn.com/problems/insert-into-a-sorted-circular-linked-list/ Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /* // Definition for a Node. class Node { public: int val; Node* next; Node() {} Node(int _val) { val = _val; next = NULL; } Node(int _val, Node* _next) { val = _val; next = _next; } }; */ class Solution { public: Node* insert(Node* head, int insertVal) { Node * max_node = head; Node *p = head; while(p) { if(p-\u0026gt;val \u0026gt; p-\u0026gt;next -\u0026gt;val) max_node = p; if(p-\u0026gt;val \u0026lt;= insertVal \u0026amp;\u0026amp; p-\u0026gt;next-\u0026gt;val \u0026gt;= insertVal) break; if(p-\u0026gt;next == head) { p = max_node; break; } p = p-\u0026gt;next; } if(head==NULL) { head = new Node(insertVal); head-\u0026gt;next = head; return head; } // if(p-\u0026gt;val == insertVal) return p; auto tmp = p-\u0026gt;next; p-\u0026gt;next = new Node(insertVal); p-\u0026gt;next -\u0026gt;next = tmp; return head; } }; ","date":"2022-10-19T21:58:35+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.029.%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/","tags":["链表"],"title":"lc.029.排序的循环链表"},{"categories":["回溯搜索"],"contents":"搜索算法的应用 1. 迭代加深 对于DFS 算法的优化：\n适用于搜索树深度很大，但是答案可能不是很深的情况，\n可以防止DFS 一开始选错了分支，但是在不包含答案的子树上浪费了很多时间\n","date":"2022-10-16T22:21:51+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E6%90%9C%E7%B4%A2/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8/","tags":["回溯搜索"],"title":"搜索算法的应用"},{"categories":["数学"],"contents":" 1447. 最简分数 Description Difficulty: 中等\nRelated Topics: 数学 , 字符串 , 数论 给你一个整数 n ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于 n 的 最简分数 。分数可以以 任意顺序返回。\n示例 1：\n1 2 3 输入：n = 2 输出：[\u0026#34;1/2\u0026#34;] 解释：\u0026#34;1/2\u0026#34; 是唯一一个分母小于等于 2 的最简分数。 示例 2：\n1 2 输入：n = 3 输出：[\u0026#34;1/2\u0026#34;,\u0026#34;1/3\u0026#34;,\u0026#34;2/3\u0026#34;] 示例 3：\n1 2 3 输入：n = 4 输出：[\u0026#34;1/2\u0026#34;,\u0026#34;1/3\u0026#34;,\u0026#34;1/4\u0026#34;,\u0026#34;2/3\u0026#34;,\u0026#34;3/4\u0026#34;] 解释：\u0026#34;2/4\u0026#34; 不是最简分数，因为它可以化简为 \u0026#34;1/2\u0026#34; 。 示例 4：\n1 2 输入：n = 1 输出：[] 提示：\n1 \u0026lt;= n \u0026lt;= 100 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: vector\u0026lt;string\u0026gt; simplifiedFractions(int n) { vector\u0026lt;string\u0026gt; ret; for(int i=2;i\u0026lt;=n;i++) { for(int j=1;j\u0026lt;i;j++) { if(gcd(i,j)==1) { ret.push_back(to_string(j)+\u0026#34;/\u0026#34;+to_string(i)); } } } return ret; } int gcd(int a,int b) { if(b) return gcd(b,a%b); return a; } }; ","date":"2022-10-16T15:31:51+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/lc.1447.%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/","tags":["数学"],"title":"lc.1447.最简分数"},{"categories":["数学"],"contents":" 1071. 字符串的最大公因子 Description Difficulty: 简单\nRelated Topics: 数学 , 字符串 对于字符串 s 和 t，只有在 s = t + ... + t（t 自身连接 1 次或多次）时，我们才认定 “t 能除尽 s”。\n给定两个字符串 str1 和 str2 。返回 最长字符串 x，要求满足 x 能除尽 str1 且 X 能除尽 str2 。\n示例 1：\n1 2 输入：str1 = \u0026#34;ABCABC\u0026#34;, str2 = \u0026#34;ABC\u0026#34; 输出：\u0026#34;ABC\u0026#34; 示例 2：\n1 2 输入：str1 = \u0026#34;ABABAB\u0026#34;, str2 = \u0026#34;ABAB\u0026#34; 输出：\u0026#34;AB\u0026#34; 示例 3：\n1 2 输入：str1 = \u0026#34;LEET\u0026#34;, str2 = \u0026#34;CODE\u0026#34; 输出：\u0026#34;\u0026#34; 提示：\n1 \u0026lt;= str1.length, str2.length \u0026lt;= 1000 str1 和 str2 由大写英文字母组成 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: string gcdOfStrings(string str1, string str2) { //a = k1 s //b = k2 s //a+ b = (k1+k2) s string a = str1 + str2; string b = str2 + str1; if(a!=b) return \u0026#34;\u0026#34;; return str1.substr(0,gcd(str1.size(),str2.size())); } int gcd(int a,int b) { if(b) return gcd(b,a%b); return a; } }; ","date":"2022-10-16T15:09:56+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/lc.1071.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/","tags":["数学"],"title":"lc.1071.字符串的最大公因子"},{"categories":["数学"],"contents":"欧几里得算法 辗转相除法的意义：\n把 一个大规模的问题转化为一个小规模的问题。\n辗转相除法用来求解 整数 a,b 的最大公约数, 表示 gcd(a,b), gcd(a,b) = gcd(b,a%b)\n证明1：\nb 和 a%b 的最大公约数，是a和b的公约数\nb 和 a%b 的最大公约数，也是 a和b的最大公约数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int gcd(int a,int b) { if(b) return gcd(b,a%b); return a; } void printGcd(int a,int b) { printf(\u0026#34;gcd(%d,%d) = %d\\n\u0026#34;,a,b,gcd(a,b)); } int main() { vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; a = { {2,4}, {4,6}, {4,2}, {2,0}, }; for (auto \u0026amp;v : a) { printGcd(v[0],v[1]); } int n; } /* gcd(2,4) = 2 gcd(4,6) = 2 gcd(4,2) = 2 gcd(2,0) = 2 */ 证明 1. b 和 a%b 的最大公约数，是a和b的公约数 设 b, a%b 的最大公约数是 c, 所以\n$b = k_1 *c$\n$a%b = k_2* c$\n$a=k_2 c + kb = k_2c + kk_1*c$\n所以 b 和 a%b 的最大公约数 也是 a和 b的最大公约数\nb 和 a%b 的最大公约数，是a和b的最大公约数 $a=(k2 + k_1*k)*c$\n$b = k_1 * c$\n反证法：\n假设c不是 a和 b的最大公约数， $gcd(k2+k_1*k,k_1) = d\n\\ d!=1$\n贝祖等式 $ax+by = gcd(a,b) = c$\n贝祖等式能保证式子一定有解\n莫比乌斯反演 给定 n,m ,求 1\u0026lt;=x \u0026lt;=n, 1\u0026lt;=y\u0026lt;=m, 且 gcd(x,y) 为质数的(x,y) 有多少对\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 int gcd(int a, int b) { if (b) return gcd(b, a % b); return a; } int is_prime(int x) { if(x\u0026lt;=1) return false; for (int i = 2; i * i \u0026lt;= x; i++) { if (x % i == 0) return 0; } return 1; } int main() { int n, m, ans = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (!is_prime(gcd(i, j))) continue; ans++; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; endl; } } cout \u0026lt;\u0026lt; \u0026#34;total=\u0026#34; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } ","date":"2022-10-16T10:06:44+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/","tags":["数学"],"title":"欧几里得算法"},{"categories":["树状数组"],"contents":" 1409. 查询带键的排列 Description Difficulty: 中等\nRelated Topics: 树状数组 , 数组 , 模拟 给你一个待查数组 queries ，数组中的元素为 1 到 m 之间的正整数。 请你根据以下规则处理所有待查项 queries[i]（从 i=0 到 i=queries.length-1）：\n一开始，排列 P=[1,2,3,...,m]。 对于当前的 i ，请你找出待查项 queries[i] 在排列 P 中的位置（下标从 0 开始），然后将其从原位置移动到排列 P 的起始位置（即下标为 0 处）。注意， queries[i] 在 P 中的位置就是 queries[i] 的查询结果。 请你以数组形式返回待查数组 queries 的查询结果。\n示例 1：\n1 2 3 4 5 6 7 8 输入：queries = [3,1,2,1], m = 5 输出：[2,1,2,1] 解释：待查数组 queries 处理如下： 对于 i=0: queries[i]=3, P=[1,2,3,4,5], 3 在 P 中的位置是 2，接着我们把 3 移动到 P 的起始位置，得到 P=[3,1,2,4,5] 。 对于 i=1: queries[i]=1, P=[3,1,2,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P=[1,3,2,4,5] 。 对于 i=2: queries[i]=2, P=[1,3,2,4,5], 2 在 P 中的位置是 2，接着我们把 2 移动到 P 的起始位置，得到 P=[2,1,3,4,5] 。 对于 i=3: queries[i]=1, P=[2,1,3,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P=[1,2,3,4,5] 。 因此，返回的结果数组为 [2,1,2,1] 。 示例 2：\n1 2 输入：queries = [4,1,2,2], m = 4 输出：[3,1,2,0] 示例 3：\n1 2 输入：queries = [7,5,5,8,3], m = 8 输出：[6,5,0,7,5] 提示：\n1 \u0026lt;= m \u0026lt;= 10^3 1 \u0026lt;= queries.length \u0026lt;= m 1 \u0026lt;= queries[i] \u0026lt;= m Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #define lowbit(i) (i \u0026amp; (-i)) // lowbit 用来求二进制的最后1位1 // 负数= 补码= 反码+1 // 计算机中没有减法，所以用补码表示法可以将减法转化为加法，所以能够成功 class FenwickTree { public: FenwickTree(int k) : n(k), c(k + 1) {} void add(int i, int x) { //原数组的 第 i位 加上某个值x while (i \u0026lt;= n) { c[i] += x; i += lowbit(i); } } int query(int x) { int sum = 0; while (x) { sum += c[x]; x -= lowbit(x); } return sum; } void output() { for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; c[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return; } private: int n; vector\u0026lt;int\u0026gt; c; }; class Solution { public: vector\u0026lt;int\u0026gt; processQueries(vector\u0026lt;int\u0026gt;\u0026amp; queries, int m) { // 数组划分 [n ] ... [m] int n = queries.size(); int bucket_len = n + m; FenwickTree tree(bucket_len); vector\u0026lt;int\u0026gt; value_pos(m+1); for (int i=1;i\u0026lt;=m;i++) { tree.add(n + i,1); value_pos[i] = n+i; } // handle query vector\u0026lt;int\u0026gt; ret(n); for (int i=0;i\u0026lt;n;i++) { int num = queries[i]; int rangeind = value_pos[num]; // 计数数组的位置 ret[i] = tree.query(rangeind) -1; // 找到 queryies[i] 所在的 数组的下标 //移除元素 tree.add(rangeind,-1); int new_pos = n-i; value_pos[num] = new_pos; tree.add(new_pos,1); } return ret; } }; ","date":"2022-10-16T10:03:12+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/lc.1409.%E6%9F%A5%E5%B8%A6%E9%94%AE%E5%80%BC%E7%9A%84%E6%8E%92%E5%88%97/","tags":["树状数组"],"title":"lc.1409.查带键值的排列"},{"categories":["树状数组"],"contents":" 1310. 子数组异或查询 Description Difficulty: 中等\nRelated Topics: 位运算 , 数组 , 前缀和 有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。\n对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor \u0026hellip; xor arr[Ri]）作为本次查询的结果。\n并返回一个包含给定查询 queries 所有结果的数组。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]] 输出：[2,7,14,8] 解释： 数组中元素的二进制表示形式是： 1 = 0001 3 = 0011 4 = 0100 8 = 1000 查询的 XOR 值为： [0,1] = 1 xor 3 = 2 [1,2] = 3 xor 4 = 7 [0,3] = 1 xor 3 xor 4 xor 8 = 14 [3,3] = 8 示例 2：\n1 2 输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]] 输出：[8,0,4,4] 提示：\n1 \u0026lt;= arr.length \u0026lt;= 3 * 10^4 1 \u0026lt;= arr[i] \u0026lt;= 10^9 1 \u0026lt;= queries.length \u0026lt;= 3 * 10^4 queries[i].length == 2 0 \u0026lt;= queries[i][0] \u0026lt;= queries[i][1] \u0026lt; arr.length Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: vector\u0026lt;int\u0026gt; xorQueries(vector\u0026lt;int\u0026gt;\u0026amp; arr, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { int n = arr.size(); if(n\u0026lt;=0) return {}; vector\u0026lt;int\u0026gt; sum(n); sum[0] = arr[0]; for(int i=1;i\u0026lt;n;i++) { sum[i] = arr[i] ^ sum[i-1]; } vector\u0026lt;int\u0026gt; ret; for(auto \u0026amp;pref: queries) { int l= pref[0],r = pref[1]; ret.push_back(sum[r] ^ (l ? sum[l-1] : 0)); } return ret; } }; ","date":"2022-10-16T00:24:12+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/lc.1310.%E5%AD%90%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%9F%A5%E8%AF%A2/","tags":["树状数组"],"title":"lc.1310.子数组异或查询"},{"categories":["树状数组"],"contents":" 面试题 10.10. 数字流的秩 Description Difficulty: 中等\nRelated Topics: 设计 , 树状数组 , 二分查找 , 数据流 假设你正在读取一串整数。每隔一段时间，你希望能找出数字 x 的秩(小于或等于 x 的值的个数)。请实现数据结构和算法来支持这些操作，也就是说：\n实现 track(int x) 方法，每读入一个数字都会调用该方法；\n实现 getRankOfNumber(int x) 方法，返回小于或等于 x 的值的个数。\n**注意：**本题相对原题稍作改动\n示例:\n1 2 3 4 5 输入: [\u0026#34;StreamRank\u0026#34;, \u0026#34;getRankOfNumber\u0026#34;, \u0026#34;track\u0026#34;, \u0026#34;getRankOfNumber\u0026#34;] [[], [1], [0], [0]] 输出: [null,0,null,1] 提示：\nx \u0026lt;= 50000 track 和 getRankOfNumber 方法的调用次数均不超过 2000 次 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #define lowbit(n) (n \u0026amp; (-n)) #define LL long long class FenwickTree { public: vector\u0026lt;int\u0026gt; c; int n; FenwickTree(int k):n(k),c(k+1) {} void add(int u,int x) { while(u\u0026lt;=n) { c[u] += x; u+= lowbit(u); } } int query(int x) { int ans=0; while(x) { ans += c[x] ; x -= lowbit(x); } return ans; } }; class StreamRank { public: FenwickTree tree; StreamRank():tree(50000+4) { } void track(int x) { tree.add(x+1,1); } int getRankOfNumber(int x) { return tree.query(x+1); } }; /** * Your StreamRank object will be instantiated and called as such: * StreamRank* obj = new StreamRank(); * obj-\u0026gt;track(x); * int param_2 = obj-\u0026gt;getRankOfNumber(x); */ ","date":"2022-10-15T23:54:28+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/lc.10.10%E6%95%B0%E5%AD%97%E6%B5%81%E7%9A%84%E7%A7%A9/","tags":["树状数组"],"title":"lc.10.10数字流的秩"},{"categories":["树状数组"],"contents":" 307. 区域和检索 - 数组可修改 Description Difficulty: 中等\nRelated Topics: 设计 , 树状数组 , 线段树 , 数组 给你一个数组 nums ，请你完成两类查询。\n其中一类查询要求 更新 数组 nums 下标对应的值 另一类查询要求返回数组 nums 中索引 left 和索引 right 之间（ 包含）的nums元素的 和 ，其中 left \u0026lt;= right 实现 NumArray 类：\nNumArray(int[] nums) 用整数数组 nums 初始化对象 void update(int index, int val) 将 nums[index] 的值 更新 为 val int sumRange(int left, int right) 返回数组 nums 中索引 left 和索引 right 之间（ 包含）的nums元素的 和 （即，nums[left] + nums[left + 1], ..., nums[right]） 示例 1：\n1 2 3 4 5 6 7 8 9 10 11 输入： [\u0026#34;NumArray\u0026#34;, \u0026#34;sumRange\u0026#34;, \u0026#34;update\u0026#34;, \u0026#34;sumRange\u0026#34;] [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]] 输出： [null, 9, null, 8] 解释： NumArray numArray = new NumArray([1, 3, 5]); numArray.sumRange(0, 2); // 返回 1 + 3 + 5 = 9 numArray.update(1, 2); // nums = [1,2,5] numArray.sumRange(0, 2); // 返回 1 + 2 + 5 = 8 提示：\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -100 \u0026lt;= nums[i] \u0026lt;= 100 0 \u0026lt;= index \u0026lt; nums.length -100 \u0026lt;= val \u0026lt;= 100 0 \u0026lt;= left \u0026lt;= right \u0026lt; nums.length 调用 update 和 sumRange 方法次数不大于 3 * 104 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #define lowbit(n) (n \u0026amp; (-n)) class FenwickTree { public: FenwickTree(int k): n(k),c(k+1) {} vector\u0026lt;int\u0026gt; c; int n; void add(int i,int x) { while(i\u0026lt;=n) { c[i] += x; i+= lowbit(i); } } int query(int i) { int ans=0; while (i) { ans += c[i]; i-= lowbit(i); } return ans; } }; class NumArray { public: FenwickTree tree; NumArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) : tree(nums.size()){ int n = nums.size(); for (int i=0;i\u0026lt;n;i++) tree.add(i+1,nums[i]); } int valueAt(int k) { return tree.query(k) - tree.query(k-1); } void update(int index, int val) { tree.add(index+1, val - valueAt(index+1)); } int sumRange(int left, int right) { return tree.query(right+1) - tree.query(left); } }; /** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * obj-\u0026gt;update(index,val); * int param_2 = obj-\u0026gt;sumRange(left,right); */ ","date":"2022-10-15T23:44:10+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/lc.307.%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9/","tags":["树状数组"],"title":"lc.307.区域和检索-数组可修改"},{"categories":["树状数组"],"contents":" 1109. 航班预订统计 Description Difficulty: 中等\nRelated Topics: 数组 , 前缀和 这里有 n 个航班，它们分别从 1 到 n 进行编号。\n有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。\n请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5 输出：[10,55,45,25,25] 解释： 航班编号 1 2 3 4 5 预订记录 1 ： 10 10 预订记录 2 ： 20 20 预订记录 3 ： 25 25 25 25 总座位数： 10 55 45 25 25 因此，answer = [10,55,45,25,25] 示例 2：\n1 2 3 4 5 6 7 8 输入：bookings = [[1,2,10],[2,2,15]], n = 2 输出：[10,25] 解释： 航班编号 1 2 预订记录 1 ： 10 10 预订记录 2 ： 15 总座位数： 10 25 因此，answer = [10,25] 提示：\n1 \u0026lt;= n \u0026lt;= 2 * 104 1 \u0026lt;= bookings.length \u0026lt;= 2 * 104 bookings[i].length == 3 1 \u0026lt;= firsti \u0026lt;= lasti \u0026lt;= n 1 \u0026lt;= seatsi \u0026lt;= 104 Solution 解法一 利用差分的定义,结合树状数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #define lowbit(n) (n \u0026amp; (-n)) class FenwickTree { public: FenwickTree(int k): n(k),c(k+1) {} vector\u0026lt;int\u0026gt; c; int n; void add(int i,int x) { while(i\u0026lt;=n) { c[i] += x; i+= lowbit(i); } } int query(int i) { int ans=0; while (i) { ans += c[i]; i-= lowbit(i); } return ans; } }; class Solution { public: vector\u0026lt;int\u0026gt; corpFlightBookings(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; bookings, int n) { FenwickTree tree(n); for(auto \u0026amp;varr: bookings) { int l = varr[0],r = varr[1], x = varr[2]; tree.add(l,x); tree.add(r+1,-x); } vector\u0026lt;int\u0026gt; ret(n); for (int i=1;i\u0026lt;=n;i++) { ret[i-1] = tree.query(i); } return ret; } }; 解法二 直接求出差分数组，然后再累加也可以\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: vector\u0026lt;int\u0026gt; corpFlightBookings(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; bookings, int n) { vector\u0026lt;int\u0026gt; d(n+2); for (auto \u0026amp;pref: bookings) { int l=pref[0],r = pref[1], x = pref[2]; d[l] += x; d[r+1] -=x; } //ret vector\u0026lt;int\u0026gt; ret(n); for(int i=1;i\u0026lt;=n;i++) { d[i] += d[i-1]; ret[i-1] = d[i]; } return ret; } }; ","date":"2022-10-15T23:18:12+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/lc.1109.%E8%88%AA%E7%8F%AD%E9%A2%84%E5%AE%9A%E7%BB%9F%E8%AE%A1/","tags":["树状数组"],"title":"lc.1109.航班预定统计"},{"categories":["树状数组"],"contents":"前缀和数组算法理解 lowbit 函数 lowbit(i): 代表i这个数字， 二进制表示的最后一位1的位权：\n$lowbit(8) = (1000)_2 = 8$\n$lowbit(x) = x\u0026amp;(-x)$\n改进前缀和数组 tree[i] 代表 C[i] 代表前lowbit(i) 项的和\n原来前缀和数组的定义是 [1,n] 项的 数组和，由于 sum[n] 与 {1,n} 项都有关系，就导致了单点修改的问题比较大， 所以前缀和数组改进的方式在于 让 sum[n] 只记录 前 lowbit(n) 项的和。\n如图所示\n$$\nlowbit(8) = 8\\\nlowbit(7)=1\\\nlowbit(6) = 2\\\n$$\n如图所示，用树状数组的话修改 nums[1] ,只需要修改 C[1],C[2],C[4],和 C[8] 的值，不需要 修改 C[1~n] 的所有值\n树状数组求和公式 $S[i] = S[i-lowbit(i)] + C[i]$\n例如\n$$\nsum[7] = sum[6] + nums[7] \\\nsum[6] = sum[4] + nums[6]\n$$\n树状数组单点修改 修改A[5],那么要更新 C[5],C[6],C[8] 的值\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #define lowbit(i) (i \u0026amp; (-i)) // lowbit 用来求二进制的最后1位1 // 负数= 补码= 反码+1 // 计算机中没有减法，所以用补码表示法可以将减法转化为加法，所以能够成功 class FenwickTree { public: FenwickTree(int n) : n(n), c(n + 1) {} void add(int i, int x) { //原数组的 第 i位 加上某个值x while (i \u0026lt;= n) { c[i] += x; i += lowbit(i); } } int query_sum(int x) { int sum = 0; while (x) { sum += c[x]; x -= lowbit(x); } return sum; } void output() { for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; c[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return; } private: int n; vector\u0026lt;int\u0026gt; c; }; int main() { int n; cin \u0026gt;\u0026gt; n; FenwickTree tree(n); for (int i = 1; i \u0026lt;= n; i++) { int k; cin \u0026gt;\u0026gt; k; tree.add(i, k); } tree.output(); } 差分原理和应用 原数组的区间操作，等价于 差分数组的单点操作\na[l~r] 区间都 +=x, 那么等价于 d[l] += x, d[r+1]-=x\n通过这个性质，我们可以把区间加和操作，转化为差分数组的2次单点修改操作\n模板代码 通常范围比较dp 可以用树状数组优化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 离散化映射数据 vector\u0026lt;int\u0026gt; remap(vector\u0026lt;int\u0026gt; \u0026amp;nums) { auto b = nums; int n = nums.size(); for (int i=0;i\u0026lt;n;i++) { b[i] -= i; } sort(b.begin(),b.end()); b.erase( unique(b.begin(),b.end()),b.end()); return b; } #define ll long long #define lowbit(x) x \u0026amp; (-x) vector\u0026lt;int\u0026gt; a; int N; int lowbit(int f) { return f \u0026amp; -f; } void update(int idx, int values) { // dp[idx] = max(dp[idx],values) for(;idx\u0026lt;N;idx+= lowbit(idx)) { a[idx] = max(a[idx],values); } } int query(int r) { // max{a[k] | 1\u0026lt;=k\u0026lt;=r } int res=0; for(;r\u0026gt;0; r -= lowbit(r)) { res = max(res,a[r]); } return res; } 相关例题参考 [[....\\dp\\树状数组优化\\lc.2008.出租车的最大盈利.md]]\n[[....\\dp\\树状数组优化\\lc.2830.销售利润最大化.md]]\n","date":"2022-10-15T21:27:14+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80/","tags":["树状数组"],"title":"树状数组基础"},{"categories":["字符串"],"contents":" 32. 最长有效括号 Description Difficulty: 困难\nRelated Topics: 栈 , 字符串 , 动态规划 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。\n示例 1：\n1 2 3 输入：s = \u0026#34;(()\u0026#34; 输出：2 解释：最长有效括号子串是 \u0026#34;()\u0026#34; 示例 2：\n1 2 3 输入：s = \u0026#34;)()())\u0026#34; 输出：4 解释：最长有效括号子串是 \u0026#34;()()\u0026#34; 示例 3：\n1 2 输入：s = \u0026#34;\u0026#34; 输出：0 提示：\n0 \u0026lt;= s.length \u0026lt;= 3 * 104 s[i] 为 '(' 或 ')' Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 //dp[i] = max(dp[j] +1 , dp[current]) class Solution { public: int longestValidParentheses(string s) { int n=s.size(); if(!n) return 0; // s[i] is ( ,dp[i] = 0; // s[i] is ), s[i-1] is (, dp[i] = if s[i-1] == \u0026#39;(\u0026#39; =\u0026gt; dp[i]= dp[i-2] + 2 // s[i] is ) , s[i-1] is ), dp[i-1] + if (s[i - dp[i-1] -1 ] is \u0026#39;(\u0026#39; ) int mem[n+5]; memset(mem,0,sizeof mem); int *dp = mem+2; dp[0] = 0; int ans=0; for (int i=1;i\u0026lt;n;i++) { dp[i] = 0; // ( if(s[i] == \u0026#39;(\u0026#39;) continue; // () if(s[i-1] ==\u0026#39;(\u0026#39;) dp[i] = dp[i-2] + 2; else { // )) int j = i - dp[i-1] -1; if(j\u0026lt;0 || s[j] == \u0026#39;)\u0026#39;) continue; dp[i] = dp[i-1] + 2 + dp[j-1]; } ans = max(ans,dp[i]); } // delete []mem; return ans; } }; ","date":"2022-10-15T18:58:31+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/","tags":["字符串"],"title":"lc.32.最长有效括号"},{"categories":["字符串"],"contents":" 面试题 17.17. 多次搜索 Description Difficulty: 中等\nRelated Topics: 字典树 , 数组 , 哈希表 , 字符串 , 字符串匹配 , 滑动窗口 给定一个较长字符串big和一个包含较短字符串的数组smalls，设计一个方法，根据smalls中的每一个较短字符串，对big进行搜索。输出smalls中的字符串在big里出现的所有位置positions，其中positions[i]为smalls[i]出现的所有位置。\n示例：\n1 2 3 4 输入： big = \u0026#34;mississippi\u0026#34; smalls = [\u0026#34;is\u0026#34;,\u0026#34;ppi\u0026#34;,\u0026#34;hi\u0026#34;,\u0026#34;sis\u0026#34;,\u0026#34;i\u0026#34;,\u0026#34;ssippi\u0026#34;] 输出： [[1,4],[8],[],[3],[1,4,7,10],[5]] 提示：\n0 \u0026lt;= len(big) \u0026lt;= 1000 0 \u0026lt;= len(smalls[i]) \u0026lt;= 1000 smalls的总字符数不会超过 100000。 你可以认为smalls中没有重复字符串。 所有出现的字符均为英文小写字母。 Solution Language: C++\nsunday 算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: vector\u0026lt;int\u0026gt; sunday(string \u0026amp;s,string \u0026amp;t) { if(t.size()==0) return {}; vector\u0026lt;int\u0026gt; ret; int last[128] = {0}; int m = t.size(),n=s.size(); for(int i=0;i\u0026lt;m;i++) last[t[i]] = i+1; int i=0; while(i+m \u0026lt;= n) { bool flag = true; for(int j=0;j\u0026lt;m;j++) { if(s[i+j] == t[j]) continue; flag = false; break; } if(flag) { ret.push_back(i); i++; }else { i += m - last[s[i+m]] +1; } } return ret; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; multiSearch(string big, vector\u0026lt;string\u0026gt;\u0026amp; smalls) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ret; for (auto \u0026amp;ss:smalls) { ret.push_back(sunday(big,ss)); } return ret; } }; KMP 算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; multiSearch(string big, vector\u0026lt;string\u0026gt;\u0026amp; smalls) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; for(auto \u0026amp;s: smalls) { res.push_back(kmp(big,s)); } return res; } vector\u0026lt;int\u0026gt; kmp(string \u0026amp;a,string \u0026amp;b) { if(b.size()==0) return {}; const int MAXN = 1000+10; static int next[MAXN]; int m = b.size() , n = a.size(); memset(next,-1,(m+1)\u0026lt;\u0026lt;2); for(int i=1,j=-1;i\u0026lt; m ;++i) { while(j!=-1 \u0026amp;\u0026amp; b[j+1]!=b[i]) j = next[j]; if(b[j+1] == b[i]) next[i] = ++j; } vector\u0026lt;int\u0026gt; res; //获得 next 前缀数组 for(int i=0,j=-1;i\u0026lt;n;++i) { while(j!=-1 \u0026amp;\u0026amp; b[j+1] !=a[i]) j = next[j]; if(a[i] == b[j+1]) { ++j; } if(j == m-1) { res.push_back(i - m+1); } } return res; } }; ","date":"2022-10-15T18:42:00+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.17.17%E5%A4%9A%E6%AC%A1%E6%90%9C%E7%B4%A2/","tags":["字符串"],"title":"lc.17.17多次搜索"},{"categories":["字典树"],"contents":" 676. 实现一个魔法字典 Description Difficulty: 中等\nRelated Topics: 设计 , 字典树 , 哈希表 , 字符串 设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。\n实现 MagicDictionary 类：\nMagicDictionary() 初始化对象 void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同 bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 输入 [\u0026#34;MagicDictionary\u0026#34;, \u0026#34;buildDict\u0026#34;, \u0026#34;search\u0026#34;, \u0026#34;search\u0026#34;, \u0026#34;search\u0026#34;, \u0026#34;search\u0026#34;] [[], [[\u0026#34;hello\u0026#34;, \u0026#34;leetcode\u0026#34;]], [\u0026#34;hello\u0026#34;], [\u0026#34;hhllo\u0026#34;], [\u0026#34;hell\u0026#34;], [\u0026#34;leetcoded\u0026#34;]] 输出 [null, null, false, true, false, false] 解释 MagicDictionary magicDictionary = new MagicDictionary(); magicDictionary.buildDict([\u0026#34;hello\u0026#34;, \u0026#34;leetcode\u0026#34;]); magicDictionary.search(\u0026#34;hello\u0026#34;); // 返回 False magicDictionary.search(\u0026#34;hhllo\u0026#34;); // 将第二个 \u0026#39;h\u0026#39; 替换为 \u0026#39;e\u0026#39; 可以匹配 \u0026#34;hello\u0026#34; ，所以返回 True magicDictionary.search(\u0026#34;hell\u0026#34;); // 返回 False magicDictionary.search(\u0026#34;leetcoded\u0026#34;); // 返回 False 提示：\n1 \u0026lt;= dictionary.length \u0026lt;= 100 1 \u0026lt;= dictionary[i].length \u0026lt;= 100 dictionary[i] 仅由小写英文字母组成 dictionary 中的所有字符串 互不相同 1 \u0026lt;= searchWord.length \u0026lt;= 100 searchWord 仅由小写英文字母组成 buildDict 仅在 search 之前调用一次 最多调用 100 次 search Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 struct Node { Node *next[26]; bool flag; }; class Trie { public: Node *root; Trie() { root = new Node(); } void insert(string word) { Node *p = root; for (char u:word) { int k = u - \u0026#39;a\u0026#39;; if(p-\u0026gt;next[k]==NULL) p-\u0026gt;next[k] = new Node(); p=p-\u0026gt;next[k]; } p-\u0026gt;flag=true; } bool query(string word,int i,int ndiff,Node *p) { if(p==NULL) return false; // Node *p = root/; int n = word.size(); if(i == n) return p-\u0026gt;flag \u0026amp;\u0026amp; ndiff==0; int k = word[i] - \u0026#39;a\u0026#39;; if (p-\u0026gt;next[k] \u0026amp;\u0026amp; query(word,i+1,ndiff,p-\u0026gt;next[k])) { return true; } if(ndiff\u0026gt;0) { for (int j=0;j\u0026lt;26;j++) { if(j==k || p-\u0026gt;next[j] ==NULL) continue; if (query(word,i+1,ndiff-1,p-\u0026gt;next[j])) return true; } } return false; } }; class MagicDictionary { public: Trie *t; MagicDictionary() { t = new Trie(); } void buildDict(vector\u0026lt;string\u0026gt; dictionary) { for(auto \u0026amp;s :dictionary) t -\u0026gt; insert(s); } bool search(string searchWord) { return t -\u0026gt; query(searchWord,0,1,t-\u0026gt;root); } }; /** * Your MagicDictionary object will be instantiated and called as such: * MagicDictionary* obj = new MagicDictionary(); * obj-\u0026gt;buildDict(dictionary); * bool param_2 = obj-\u0026gt;search(searchWord); */ ","date":"2022-10-15T18:23:56+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8%E6%A0%91/lc.676.%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%AD%94%E6%B3%95%E5%AD%97%E5%85%B8/","tags":["字典树"],"title":"lc.676.实现一个魔法字典"},{"categories":["字典树"],"contents":" 987. 二叉树的垂序遍历 Description Difficulty: 困难\nRelated Topics: 树 , 深度优先搜索 , 广度优先搜索 , 哈希表 , 二叉树 给你二叉树的根结点 root ，请你设计算法计算二叉树的垂序遍历 序列。\n对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。\n二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。\n返回二叉树的 垂序遍历 序列。\n示例 1：\n1 2 3 4 5 6 7 输入：root = [3,9,20,null,null,15,7] 输出：[[9],[3,15],[20],[7]] 解释： 列 -1 ：只有结点 9 在此列中。 列 0 ：只有结点 3 和 15 在此列中，按从上到下顺序。 列 1 ：只有结点 20 在此列中。 列 2 ：只有结点 7 在此列中。 示例 2：\n1 2 3 4 5 6 7 8 9 10 输入：root = [1,2,3,4,5,6,7] 输出：[[4],[2],[1,5,6],[3],[7]] 解释： 列 -2 ：只有结点 4 在此列中。 列 -1 ：只有结点 2 在此列中。 列 0 ：结点 1 、5 和 6 都在此列中。 1 在上面，所以它出现在前面。 5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。 列 1 ：只有结点 3 在此列中。 列 2 ：只有结点 7 在此列中。 示例 3：\n1 2 3 4 5 输入：root = [1,2,3,4,6,5,7] 输出：[[4],[2],[1,5,6],[3],[7]] 解释： 这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。 因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。 提示：\n树中结点数目总数在范围 [1, 1000] 内 0 \u0026lt;= Node.val \u0026lt;= 1000 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: #define PII pair\u0026lt;int,int\u0026gt; #define Node TreeNode map\u0026lt;int,vector\u0026lt;PII\u0026gt;\u0026gt; mp; void dfs(TreeNode *root,int i,int j) { if(!root) return; mp[j].push_back(PII{i,root-\u0026gt;val}); dfs(root-\u0026gt;left,i+1,j-1); dfs(root-\u0026gt;right,i+1,j+1); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; verticalTraversal(TreeNode* root) { mp.clear(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ret; dfs(root,0,0); for(auto item:mp) { vector\u0026lt;PII\u0026gt; \u0026amp;arr = item.second; sort(arr.begin(),arr.end()); vector\u0026lt;int\u0026gt;tmp; for (auto x:arr) tmp.push_back(x.second); ret.push_back(tmp); } return ret; } }; ","date":"2022-10-15T14:59:15+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8%E6%A0%91/lc.987.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9E%82%E5%BA%8F%E9%81%8D%E5%8E%86/","tags":["字典树"],"title":"lc.987.二叉树垂序遍历"},{"categories":["字典树"],"contents":" 133. 克隆图 Description Difficulty: 中等\nRelated Topics: 深度优先搜索 , 广度优先搜索 , 图 , 哈希表 给你无向 ** 连通 **图中一个节点的引用，请你返回该图的 深拷贝 （克隆）。\n图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。\n1 2 3 4 class Node { public int val; public List \u0026lt;node\u0026gt;neighbors; }\u0026lt;/node\u0026gt; 测试用例格式：\n简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。\n邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。\n给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝作为对克隆图的引用返回。\n示例 1：\n1 2 3 4 5 6 7 8 输入：adjList = [[2,4],[1,3],[2,4],[1,3]] 输出：[[2,4],[1,3],[2,4],[1,3]] 解释： 图中有 4 个节点。 节点 1 的值是 1，它有两个邻居：节点 2 和 4 。 节点 2 的值是 2，它有两个邻居：节点 1 和 3 。 节点 3 的值是 3，它有两个邻居：节点 2 和 4 。 节点 4 的值是 4，它有两个邻居：节点 1 和 3 。 示例 2：\n1 2 3 输入：adjList = [[]] 输出：[[]] 解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。 示例 3：\n1 2 3 输入：adjList = [] 输出：[] 解释：这个图是空的，它不含任何节点。 示例 4：\n1 2 输入：adjList = [[2],[1]] 输出：[[2],[1]] 提示：\n节点数不超过 100 。 每个节点值 Node.val 都是唯一的，1 \u0026lt;= Node.val \u0026lt;= 100。 无向图是一个 简单图 ，这意味着图中没有重复的边，也没有自环。 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。 图是连通图，你可以从给定节点访问到所有节点。 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* // Definition for a Node. class Node { public: int val; vector\u0026lt;Node*\u0026gt; neighbors; Node() { val = 0; neighbors = vector\u0026lt;Node*\u0026gt;(); } Node(int _val) { val = _val; neighbors = vector\u0026lt;Node*\u0026gt;(); } Node(int _val, vector\u0026lt;Node*\u0026gt; _neighbors) { val = _val; neighbors = _neighbors; } }; */ class Solution { public: unordered_map\u0026lt;Node*,Node*\u0026gt; h; Node* cloneGraph(Node* node) { h.clear(); return handle(node); } Node *handle(Node *node) { if(node == NULL) return NULL; if (h[node]) return h[node]; Node *tmp = new Node(node-\u0026gt;val); h[node] = tmp; for (auto \u0026amp;nextRef: node-\u0026gt;neighbors) { tmp-\u0026gt;neighbors.push_back( handle(nextRef)) ; } return tmp; } }; ","date":"2022-10-15T14:36:26+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8%E6%A0%91/lc.133.%E5%85%8B%E9%9A%86%E5%9B%BE/","tags":["字典树"],"title":"lc.133.克隆图"},{"categories":["字典树"],"contents":" 241. 为运算表达式设计优先级 Description Difficulty: 中等\nRelated Topics: 递归 , 记忆化搜索 , 数学 , 字符串 , 动态规划 给你一个由数字和运算符组成的字符串 expression ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 按任意顺序 返回答案。\n生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 104 。\n示例 1：\n1 2 3 4 5 输入：expression = \u0026#34;2-1-1\u0026#34; 输出：[0,2] 解释： ((2-1)-1) = 0 (2-(1-1)) = 2 示例 2：\n1 2 3 4 5 6 7 8 输入：expression = \u0026#34;2*3-4*5\u0026#34; 输出：[-34,-14,-10,-10,10] 解释： (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10 提示：\n1 \u0026lt;= expression.length \u0026lt;= 20 expression 由数字和算符 '+'、'-' 和 '*' 组成。 输入表达式中的所有整数值在范围 [0, 99] Solution Language: C++\n解题思路 把一个表达式看成是一颗表达式语法树，枚举树的不同形状可能会生成的不同结果就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public: int handle(int a,char x,int b) { switch (x) { case \u0026#39;+\u0026#39;: return a+b; case \u0026#39;-\u0026#39;: return a-b; case \u0026#39;*\u0026#39;: return a*b; case \u0026#39;/\u0026#39;:return a/b; default: return 0; } } vector\u0026lt;int\u0026gt; diffWaysToCompute(string expression) { int n = expression.size(); vector\u0026lt;int\u0026gt; ret; for (int i=0;i\u0026lt;n;i++) { char tmp = expression[i]; if (tmp!=\u0026#39;+\u0026#39; \u0026amp;\u0026amp; tmp != \u0026#39;-\u0026#39; \u0026amp;\u0026amp; tmp != \u0026#39;*\u0026#39; \u0026amp;\u0026amp; tmp!=\u0026#39;/\u0026#39;) continue; string a = expression.substr(0,i); string b = expression.substr(i+1,n); vector\u0026lt;int\u0026gt; left = diffWaysToCompute(a); vector\u0026lt;int\u0026gt; right = diffWaysToCompute(b); for (auto \u0026amp;i:left) { for(auto \u0026amp;j: right) { ret.push_back(handle(i,tmp,j)); } } // cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b\u0026lt;\u0026lt;endl; } if (ret.size()==0) { int k=0; for(char f: expression) { k = k*10 + (f-\u0026#39;0\u0026#39;); } ret.push_back(k); } return ret; } }; ","date":"2022-10-15T14:27:29+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8%E6%A0%91/lc.241.%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/","tags":["字典树"],"title":"lc.241.为运算表达式设计优先级"},{"categories":["字典树"],"contents":" 剑指 Offer II 067. 最大的异或 Description Difficulty: 中等\nRelated Topics: 位运算 , 字典树 , 数组 , 哈希表 给你一个整数数组 nums ，返回nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j \u0026lt; n 。\n示例 1：\n1 2 3 输入：nums = [3,10,5,25,2,8] 输出：28 解释：最大运算结果是 5 XOR 25 = 28. 示例 2：\n1 2 输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70] 输出：127 提示：\n1 \u0026lt;= nums.length \u0026lt;= 2 * 105 0 \u0026lt;= nums[i] \u0026lt;= 231 - 1 注意：本题与主站 421 题相同： https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/ Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 struct Node { // bool flag= true; Node* next[2]; // int8 value; }; class Trie { public: Node *root; Trie() { root = new Node(); } void insert(int val) { Node *p = root; for (int i=30;i\u0026gt;=0;i--) { int k = !!(val \u0026amp; (1\u0026lt;\u0026lt;i)); if (p-\u0026gt;next[k] ==NULL) p-\u0026gt;next[k] = new Node(); p=p-\u0026gt;next[k]; } // p-\u0026gt;flag=true; } int search(int val) { Node *p = root; int ans=0; for (int i=30;i\u0026gt;=0;i--) { int k = !!(val \u0026amp; (1\u0026lt;\u0026lt;i)); //x[i] 是0 还是 1 if (p-\u0026gt;next[!k]) { ans |= (1\u0026lt;\u0026lt;i); p = p-\u0026gt;next[!k]; }else { p = p-\u0026gt;next[k]; } } return ans; } }; class Solution { public: int findMaximumXOR(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 相同为0，不同为1，奇数个1位1，偶数个1位0 int ans=0; Trie tree; for(int \u0026amp;u:nums) tree.insert(u); // int ans=0; for(int \u0026amp;u:nums) { ans = max(ans, tree.search(u)); } return ans; } }; ","date":"2022-10-15T12:16:24+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8%E6%A0%91/lc.67.%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C/","tags":["字典树"],"title":"lc.67.最大异或和"},{"categories":["字典树"],"contents":" 1268. 搜索推荐系统 Description Difficulty: 中等\nRelated Topics: 字典树 , 数组 , 字符串 给你一个产品数组 products 和一个字符串 searchWord ，products 数组中每个产品都是一个字符串。\n请你设计一个推荐系统，在依次输入单词 searchWord 的每一个字母后，推荐 products 数组中前缀与 searchWord 相同的最多三个产品。如果前缀相同的可推荐产品超过三个，请按字典序返回最小的三个。\n请你以二维列表的形式，返回在输入 searchWord 每个字母后相应的推荐产品的列表。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 输入：products = [\u0026#34;mobile\u0026#34;,\u0026#34;mouse\u0026#34;,\u0026#34;moneypot\u0026#34;,\u0026#34;monitor\u0026#34;,\u0026#34;mousepad\u0026#34;], searchWord = \u0026#34;mouse\u0026#34; 输出：[ [\u0026#34;mobile\u0026#34;,\u0026#34;moneypot\u0026#34;,\u0026#34;monitor\u0026#34;], [\u0026#34;mobile\u0026#34;,\u0026#34;moneypot\u0026#34;,\u0026#34;monitor\u0026#34;], [\u0026#34;mouse\u0026#34;,\u0026#34;mousepad\u0026#34;], [\u0026#34;mouse\u0026#34;,\u0026#34;mousepad\u0026#34;], [\u0026#34;mouse\u0026#34;,\u0026#34;mousepad\u0026#34;] ] 解释：按字典序排序后的产品列表是 [\u0026#34;mobile\u0026#34;,\u0026#34;moneypot\u0026#34;,\u0026#34;monitor\u0026#34;,\u0026#34;mouse\u0026#34;,\u0026#34;mousepad\u0026#34;] 输入 m 和 mo，由于所有产品的前缀都相同，所以系统返回字典序最小的三个产品 [\u0026#34;mobile\u0026#34;,\u0026#34;moneypot\u0026#34;,\u0026#34;monitor\u0026#34;] 输入 mou， mous 和 mouse 后系统都返回 [\u0026#34;mouse\u0026#34;,\u0026#34;mousepad\u0026#34;] 示例 2：\n1 2 输入：products = [\u0026#34;havana\u0026#34;], searchWord = \u0026#34;havana\u0026#34; 输出：[[\u0026#34;havana\u0026#34;],[\u0026#34;havana\u0026#34;],[\u0026#34;havana\u0026#34;],[\u0026#34;havana\u0026#34;],[\u0026#34;havana\u0026#34;],[\u0026#34;havana\u0026#34;]] 示例 3：\n1 2 输入：products = [\u0026#34;bags\u0026#34;,\u0026#34;baggage\u0026#34;,\u0026#34;banner\u0026#34;,\u0026#34;box\u0026#34;,\u0026#34;cloths\u0026#34;], searchWord = \u0026#34;bags\u0026#34; 输出：[[\u0026#34;baggage\u0026#34;,\u0026#34;bags\u0026#34;,\u0026#34;banner\u0026#34;],[\u0026#34;baggage\u0026#34;,\u0026#34;bags\u0026#34;,\u0026#34;banner\u0026#34;],[\u0026#34;baggage\u0026#34;,\u0026#34;bags\u0026#34;],[\u0026#34;bags\u0026#34;]] 示例 4：\n1 2 输入：products = [\u0026#34;havana\u0026#34;], searchWord = \u0026#34;tatiana\u0026#34; 输出：[[],[],[],[],[],[],[]] 提示：\n1 \u0026lt;= products.length \u0026lt;= 1000 1 \u0026lt;= Σ products[i].length \u0026lt;= 2 * 10^4 products[i] 中所有的字符都是小写英文字母。 1 \u0026lt;= searchWord.length \u0026lt;= 1000 searchWord 中所有字符都是小写英文字母。 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 struct Node{ Node *next[26]; bool flag; Node() { flag = false; for(int i=0;i\u0026lt;26;i++) next[i] = NULL; } ~Node() {} set\u0026lt;string\u0026gt; s; }; class Trie { public: Trie() { root = new Node(); } Node *root; void insert(string word) { Node *p = root; for (auto x: word) { int ind = x-\u0026#39;a\u0026#39;; if(p-\u0026gt;next[ind] == NULL) p-\u0026gt;next[ind] = new Node(); p = p-\u0026gt;next[ind]; p -\u0026gt; s.insert(word); if(p -\u0026gt; s.size() \u0026gt; 3) { auto iter = p-\u0026gt;s.end(); iter--; p -\u0026gt; s.erase(iter); } } p-\u0026gt;flag= true; return; } vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; search(string word) { vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; ret; Node *p = root; for (auto x: word) { int ind = x-\u0026#39;a\u0026#39;; if(p == NULL) { ret.push_back(vector\u0026lt;string\u0026gt;()); continue; } p = p-\u0026gt;next[ind]; vector\u0026lt;string\u0026gt; tmp; if (p) { for(auto s: p-\u0026gt;s) { tmp.push_back(s); } } ret.push_back(tmp); } return ret; } bool startsWith(string prefix) { Node *p = root; for (auto x: prefix) { int ind = x-\u0026#39;a\u0026#39;; if(p-\u0026gt;next[ind] == NULL) return false; // p-\u0026gt;next[ind] = new Node(); p = p-\u0026gt;next[ind]; } return p!=NULL; } }; class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; suggestedProducts(vector\u0026lt;string\u0026gt;\u0026amp; products, string searchWord) { Trie tree; for(auto \u0026amp;s: products) { tree.insert(s); } return tree.search(searchWord); } }; ","date":"2022-10-14T23:54:49+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8%E6%A0%91/lc.1288.%E6%90%9C%E7%B4%A2%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/","tags":["字典树"],"title":"lc.1288.搜索推荐系统"},{"categories":["字典树"],"contents":" 208. 实现 Trie (前缀树) Description Difficulty: 中等\nRelated Topics: 设计 , 字典树 , 哈希表 , 字符串 Trie （发音类似 \u0026ldquo;try\u0026rdquo;）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。\n请你实现 Trie 类：\nTrie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 输入 [\u0026#34;Trie\u0026#34;, \u0026#34;insert\u0026#34;, \u0026#34;search\u0026#34;, \u0026#34;search\u0026#34;, \u0026#34;startsWith\u0026#34;, \u0026#34;insert\u0026#34;, \u0026#34;search\u0026#34;] [[], [\u0026#34;apple\u0026#34;], [\u0026#34;apple\u0026#34;], [\u0026#34;app\u0026#34;], [\u0026#34;app\u0026#34;], [\u0026#34;app\u0026#34;], [\u0026#34;app\u0026#34;]] 输出 [null, null, true, false, true, null, true] 解释 Trie trie = new Trie(); trie.insert(\u0026#34;apple\u0026#34;); trie.search(\u0026#34;apple\u0026#34;); // 返回 True trie.search(\u0026#34;app\u0026#34;); // 返回 False trie.startsWith(\u0026#34;app\u0026#34;); // 返回 True trie.insert(\u0026#34;app\u0026#34;); trie.search(\u0026#34;app\u0026#34;); // 返回 True 提示：\n1 \u0026lt;= word.length, prefix.length \u0026lt;= 2000 word 和 prefix 仅由小写英文字母组成 insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 struct Node{ Node *next[26]; bool flag; }; class Trie { public: Trie() { root = new Node(); } Node *root; void insert(string word) { Node *p = root; for (auto x: word) { int ind = x-\u0026#39;a\u0026#39;; if(p-\u0026gt;next[ind] == NULL) p-\u0026gt;next[ind] = new Node(); p = p-\u0026gt;next[ind]; } p-\u0026gt;flag= true; return; } bool search(string word) { Node *p = root; for (auto x: word) { int ind = x-\u0026#39;a\u0026#39;; if(p-\u0026gt;next[ind] == NULL) return false; // p-\u0026gt;next[ind] = new Node(); p = p-\u0026gt;next[ind]; } return p-\u0026gt;flag; } bool startsWith(string prefix) { Node *p = root; for (auto x: prefix) { int ind = x-\u0026#39;a\u0026#39;; if(p-\u0026gt;next[ind] == NULL) return false; // p-\u0026gt;next[ind] = new Node(); p = p-\u0026gt;next[ind]; } return p!=NULL; } }; /** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj-\u0026gt;insert(word); * bool param_2 = obj-\u0026gt;search(word); * bool param_3 = obj-\u0026gt;startsWith(prefix); */ ","date":"2022-10-14T23:05:31+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8%E6%A0%91/lc.208.%E5%AD%97%E5%85%B8%E6%A0%91/","tags":["字典树"],"title":"lc.208.字典树"},{"categories":["字典树"],"contents":"双数组字典树 Trie树本质是一个确定的有限状态自动机(DFA)，核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。但由于Trie树的稀疏现象严重，空间利用率较低为了让Trie树实现占用较少的空间，同时还要保证查询的效率，最后提出了用2个线性数组来进行Trie树的表示，即双数组Trie(Double Array Trie).\n双数组Trie树\n在Trie数实现过程中，我们发现了每个节点均需要 一个数组来存储next节点，非常占用存储空间，空间复杂度大，双数组Trie树正是解决这个问题的。双数组Trie树(DoubleArrayTrie)是一种空间复杂度低的Trie树，应用于字符区间大的语言（如中文、日文等）分词领域。\n双数组的原理是，将原来需要多个数组才能表示的Trie树，使用两个数据就可以存储下来，可以极大的减小空间复杂度。具体来说：\n使用两个数组base和check来维护Trie树，base负责记录状态，check负责检查各个字符串是否是从同一个状态转移而来，当check[i]为负值时，表示此状态为字符串的结束。\n上面的有点抽象，举个例子，假定两个单词ta,tb,base和check的值会满足下面的条件：\n1 2 3 4 5 root_index=1; base[1] =1; child_i = base[father] + i; check[child_i] = father; check[child_i] = -father; 当前节点的第 i条边 就是 i值，\n双数组不需要存储边的信息，知道父节点编号就能确定子节点编号。\ncheck 数组存储的是相应节点父节点编号\nbase 数组确定父节点到子节点编号确定关系，check 是用来确定 父子节点的关系。\n","date":"2022-10-12T22:51:08+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8%E6%A0%91/%E5%8F%8C%E6%95%B0%E7%BB%84%E5%AD%97%E5%85%B8%E6%A0%91/","tags":["字典树"],"title":"双数组字典树"},{"categories":["字符串"],"contents":" 12. 整数转罗马数字 Description Difficulty: 中等\nRelated Topics: 哈希表 , 数学 , 字符串 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。\n1 2 3 4 5 6 7 8 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给你一个整数，将其转为罗马数字。\n示例 1:\n1 2 输入: num = 3 输出: \u0026#34;III\u0026#34; 示例 2:\n1 2 输入: num = 4 输出: \u0026#34;IV\u0026#34; 示例 3:\n1 2 输入: num = 9 输出: \u0026#34;IX\u0026#34; 示例 4:\n1 2 3 输入: num = 58 输出: \u0026#34;LVIII\u0026#34; 解释: L = 50, V = 5, III = 3. 示例 5:\n1 2 3 输入: num = 1994 输出: \u0026#34;MCMXCIV\u0026#34; 解释: M = 1000, CM = 900, XC = 90, IV = 4. 提示：\n1 \u0026lt;= num \u0026lt;= 3999 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Solution { public: /* 特殊情况 IV, IX 4 9 XL XC 40 , 90 CD CM 400, 900 */ string alias(int k) { switch(k) { case 1000:return \u0026#34;M\u0026#34;; case 500: return \u0026#34;D\u0026#34;; case 100: return \u0026#34;C\u0026#34;; case 50: return \u0026#34;L\u0026#34;; case 10: return \u0026#34;X\u0026#34;; case 5: return \u0026#34;V\u0026#34;; case 1: return \u0026#34;I\u0026#34;; case 4: return \u0026#34;IV\u0026#34;; case 9: return \u0026#34;IX\u0026#34;; case 40: return \u0026#34;XL\u0026#34;; case 90: return \u0026#34;XC\u0026#34;; case 400: return \u0026#34;CD\u0026#34;; case 900: return \u0026#34;CM\u0026#34;; } return \u0026#34;\u0026#34;; } string intToRoman(int num) { string ret = \u0026#34;\u0026#34;; vector\u0026lt;int\u0026gt; tmp = {1000,500,100,50,10,5,1,4,9,40,90,400,900}; sort(tmp.begin(),tmp.end()); int n = tmp.size(); while(num\u0026gt;0) { for(int i=n-1;i\u0026gt;=0;i--) { if(num-tmp[i]\u0026lt;0) { continue; } if(num-tmp[i] \u0026gt;= 0) { ret += alias(tmp[i]); num -= tmp[i]; // i++; break; } } } return ret; } }; ","date":"2022-10-12T21:31:59+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.12.%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/","tags":["字符串"],"title":"lc.12.整数转罗马数字"},{"categories":["字符串"],"contents":" 14. 最长公共前缀 Description Difficulty: 简单\nRelated Topics: 字符串 编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 \u0026quot;\u0026quot;。\n示例 1：\n1 2 输入：strs = [\u0026#34;flower\u0026#34;,\u0026#34;flow\u0026#34;,\u0026#34;flight\u0026#34;] 输出：\u0026#34;fl\u0026#34; 示例 2：\n1 2 3 输入：strs = [\u0026#34;dog\u0026#34;,\u0026#34;racecar\u0026#34;,\u0026#34;car\u0026#34;] 输出：\u0026#34;\u0026#34; 解释：输入不存在公共前缀。 提示：\n1 \u0026lt;= strs.length \u0026lt;= 200 0 \u0026lt;= strs[i].length \u0026lt;= 200 strs[i] 仅由小写英文字母组成 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: size_t compare(string \u0026amp;a,string \u0026amp;b,size_t k) { // int n = a.size(),m = b.size(); k = min(a.size(),min(k,b.size())); int res=0; for (int i=0;i\u0026lt;k;i++) { if(a[i]!=b[i]) return res; res++; } return k; } string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { int n = strs.size(); if(n==0) return \u0026#34;\u0026#34;; auto \u0026amp;first = strs[0]; size_t len = first.size(); for(int i=1;i\u0026lt;n;i++) { len = min(len,compare(first,strs[i],len)); if(len==0) break; } return first.substr(0,len); } }; ","date":"2022-10-12T20:43:36+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.14.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","tags":["字符串"],"title":"lc.14.最长公共前缀"},{"categories":["字符串"],"contents":" 3. 无重复字符的最长子串 Description Difficulty: 中等\nRelated Topics: 哈希表 , 字符串 , 滑动窗口 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度。\n示例 1:\n1 2 3 输入: s = \u0026#34;abcabcbb\u0026#34; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026#34;abc\u0026#34;，所以其长度为 3。 示例 2:\n1 2 3 输入: s = \u0026#34;bbbbb\u0026#34; 输出: 1 解释: 因为无重复字符的最长子串是 \u0026#34;b\u0026#34;，所以其长度为 1。 示例 3:\n1 2 3 4 输入: s = \u0026#34;pwwkew\u0026#34; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026#34;wke\u0026#34;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\u0026#34;pwke\u0026#34; 是一个子序列，不是子串。 提示：\n0 \u0026lt;= s.length \u0026lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 Solution Language: C++\n解法1： 二分法枚举长度，并且验证长度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: int lengthOfLongestSubstring(string s) { if(s==\u0026#34;\u0026#34;) return 0; int l=1,r = s.size(); while(l\u0026lt;r) { int m = (l+r+1)/2; if(check(m,s)) l=m; else r=m-1; } return l; } bool check(int m,string \u0026amp;s) { int cnt[256] = {0},k=0; int n=s.size(); int l=0,r=0; for(int i=0;i\u0026lt;n;i++) { if(cnt[s[i]] == 0) k++; cnt[s[i]] ++; if(i\u0026gt;=m) { cnt[s[i-m]]--; if(cnt[s[i-m]] == 0) k--; } if(k==m) return true; } return false; } }; 解法二， 双指针 ，滑动窗口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int lengthOfLongestSubstring(string s) { if(s==\u0026#34;\u0026#34;) return 0; int n = s.size(); int mp[256]={0}; int k=0; int j=0; for(int i=0;i\u0026lt;n;i++) { if(mp[s[i]]) { while(mp[s[i]]) { mp[s[j++]]--; } } mp[s[i]]++; k = max(k,i-j+1); } return k; } }; ","date":"2022-10-11T23:52:11+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","tags":["字符串"],"title":"lc.3.无重复字符的最长子串"},{"categories":["字符串"],"contents":" 28. 找出字符串中第一个匹配项的下标 Description Difficulty: 中等\nRelated Topics: 双指针 , 字符串 , 字符串匹配 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1。\n示例 1：\n1 2 3 4 输入：haystack = \u0026#34;sadbutsad\u0026#34;, needle = \u0026#34;sad\u0026#34; 输出：0 解释：\u0026#34;sad\u0026#34; 在下标 0 和 6 处匹配。 第一个匹配项的下标是 0 ，所以返回 0 。 示例 2：\n1 2 3 输入：haystack = \u0026#34;leetcode\u0026#34;, needle = \u0026#34;leeto\u0026#34; 输出：-1 解释：\u0026#34;leeto\u0026#34; 没有在 \u0026#34;leetcode\u0026#34; 中出现，所以返回 -1 。 提示：\n1 \u0026lt;= haystack.length, needle.length \u0026lt;= 104 haystack 和 needle 仅由小写英文字符组成 Solution Language: C++\nsunday 算法实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int strStr(string haystack, string needle) { int ind[128]; memset(ind,-1,sizeof(ind)); int n = needle.size(); for (int i=0;i\u0026lt;n;i++) ind[needle[i]] = i; int m = haystack.size(); bool matchAll; for(int i=0;i+n\u0026lt;=m;i+= (n-ind[haystack[i+n]])) { matchAll = true; for(int j=0;j\u0026lt;n;j++) { if(haystack[i+j] == needle[j]) { continue; } matchAll = false; break; } if(matchAll) return i; } return -1; } }; KMP 算法实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int getNextJ(vector\u0026lt;int\u0026gt; \u0026amp;next,string \u0026amp;a,string \u0026amp;b,int i,int j) { while(j!=-1 \u0026amp;\u0026amp; a[i] != b[j+1]) j=next[j]; if(a[i] == b[j+1]) j++; return j; } int strStr(string S, string T) { int n= S.size(),m = T.size(); if(m==0) return 0; vector\u0026lt;int\u0026gt; next(m); next[0] = -1; int j=-1; for(int i=1;i\u0026lt;m;i++) { j = getNextJ(next,T,T,i,j); next[i] =j; } j=-1; for(int i=0;i\u0026lt;n \u0026amp;\u0026amp; j\u0026lt;m;i++) { j = getNextJ(next,S,T,i,j); // printf(\u0026#34;%d,%d\\n\u0026#34;,i,j); if(j==m-1) return i-j; } return -1; } }; ","date":"2022-10-11T22:06:18+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.28.%E5%AE%9E%E7%8E%B0strstr/","tags":["字符串"],"title":"lc.28.实现strStr()"},{"categories":["字符串"],"contents":" 5. 最长回文子串 Description Difficulty: 中等\nRelated Topics: 字符串 , 动态规划 给你一个字符串 s，找到 s 中最长的回文子串。\n示例 1：\n1 2 3 输入：s = \u0026#34;babad\u0026#34; 输出：\u0026#34;bab\u0026#34; 解释：\u0026#34;aba\u0026#34; 同样是符合题意的答案。 示例 2：\n1 2 输入：s = \u0026#34;cbbd\u0026#34; 输出：\u0026#34;bb\u0026#34; 提示：\n1 \u0026lt;= s.length \u0026lt;= 1000 s 仅由数字和英文字母组成 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public: string newString(string \u0026amp;s) { string res=\u0026#34;#\u0026#34;; for(char x:s) { res += x; res += \u0026#39;#\u0026#39;; } return res; } string longestPalindrome(string s) { string tmp = newString(s); int n = tmp.size(); vector\u0026lt;int\u0026gt; d(n); int l=0,r=-1; for(int i=0;i\u0026lt;n;i++) { if(i\u0026gt;r) { //不在回文串中 d[i]=1; }else { d[i] = min(r-i,d[l+(r-i)]); } while(i-d[i] \u0026gt;=0 \u0026amp;\u0026amp; tmp[i-d[i]] == tmp[i+d[i]]) { d[i]++; } if(i+d[i] \u0026gt;r \u0026amp;\u0026amp; i-d[i]\u0026gt;0) { l = i-d[i]; r = i+d[i]; } } string ret; int k=-1; for(int i=0;i\u0026lt;n;i++ ) { if(k\u0026gt;=d[i]) continue; k=d[i]; ret=\u0026#34;\u0026#34;; for(int j=i-d[i]+1;j\u0026lt;i+d[i];j++) { if(tmp[j]==\u0026#39;#\u0026#39;) continue; ret += tmp[j]; } } return ret; } }; 动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: string longestPalindrome(string s) { int n = s.size(); vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(n+1,vector\u0026lt;bool\u0026gt;(n+1)); //dp[i][j] = dp[i+1][j-1] \u0026amp;\u0026amp; s[i] == s[j] // for(int i=0;i\u0026lt;n;++i) // dp[i][i] = true; int maxLen=1,i=0,j = 0; for(int l=n-1;l\u0026gt;=0;--l) { for(int r= l;r\u0026lt;n;++r) { if(l==r) dp[l][r] = true; else if (r==l+1) dp[l][r] = s[l]==s[r]; // if(l\u0026lt;r) { else dp[l][r] = dp[l+1][r-1] \u0026amp;\u0026amp; (s[l] == s[r]); // } if(dp[l][r] \u0026amp;\u0026amp; r-l+1\u0026gt;maxLen) { maxLen = r-l+1; i = l,j = r; } } } return s.substr(i,maxLen); // return dp[0][n-1]; } }; ","date":"2022-10-11T00:27:11+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/manacher%E7%AE%97%E6%B3%95/","tags":["字符串"],"title":"manacher算法"},{"categories":["字符串"],"contents":" 214. 最短回文串 Description Difficulty: 困难\nRelated Topics: 字符串 , 字符串匹配 , 哈希函数 , 滚动哈希 给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。\n示例 1：\n1 2 输入：s = \u0026#34;aacecaaa\u0026#34; 输出：\u0026#34;aaacecaaa\u0026#34; 示例 2：\n1 2 输入：s = \u0026#34;abcd\u0026#34; 输出：\u0026#34;dcbabcd\u0026#34; 提示：\n0 \u0026lt;= s.length \u0026lt;= 5 * 104 s 仅由小写英文字母组成 Solution Language: C++\n解题思路 求最长前缀回文\n例如：\naabcd ==\u0026gt; dcbaabcd ,\n由于中间的aa是回文, 就不需要重复\n举个例子 aab 翻转得到 baa, 拼接是 baaaab ，\n由于aa重复了， 最优结果应该是 baab, 也就是把重复的回文串去掉， 利用KMP算法 可以得到最长的前缀回文串，这样我们就可以\nreplace 掉最长的那个 前缀回文，再翻转这个新字符串并且和源字符串拼接 就得到答案了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: string shortestPalindrome(string s) { int n = s.size(); if(!n) return \u0026#34;\u0026#34;; string suffix = s; reverse(suffix.begin(),suffix.end()); string news = s +\u0026#39;@\u0026#39;+ suffix; int N = news.size(); vector\u0026lt;int\u0026gt; next(N); next[0] = -1; int j=-1; for (int i=1;i\u0026lt;N;i++) { j = getNextJ(news,next,i,j); next[i] = j; } int maxPrefix = next[N-1]+1; // cout \u0026lt;\u0026lt; news \u0026lt;\u0026lt;endl; // cout \u0026lt;\u0026lt; maxPrefix \u0026lt;\u0026lt;endl; suffix = s.substr(maxPrefix); reverse(suffix.begin(),suffix.end()); // string ret = suffix + s.substr(maxPrefix-1); return suffix+s; } int getNextJ(string \u0026amp;s,vector\u0026lt;int\u0026gt; \u0026amp;next,int i,int j) { while(j!=-1 \u0026amp;\u0026amp; s[j+1] != s[i]) j=next[j]; if(s[j+1] == s[i]) j++; return j; } }; ","date":"2022-10-10T22:38:17+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.214.%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2/","tags":["字符串"],"title":"lc.214.最短回文串"},{"categories":["字符串"],"contents":" 1392. 最长快乐前缀 Description Difficulty: 困难\nRelated Topics: 字符串 , 字符串匹配 , 哈希函数 , 滚动哈希 「快乐前缀」 是在原字符串中既是 非空 前缀也是后缀（不包括原字符串自身）的字符串。\n给你一个字符串 s，请你返回它的 最长快乐前缀。如果不存在满足题意的前缀，则返回一个空字符串 \u0026quot;\u0026quot; 。\n示例 1：\n1 2 3 输入：s = \u0026#34;level\u0026#34; 输出：\u0026#34;l\u0026#34; 解释：不包括 s 自己，一共有 4 个前缀（\u0026#34;l\u0026#34;, \u0026#34;le\u0026#34;, \u0026#34;lev\u0026#34;, \u0026#34;leve\u0026#34;）和 4 个后缀（\u0026#34;l\u0026#34;, \u0026#34;el\u0026#34;, \u0026#34;vel\u0026#34;, \u0026#34;evel\u0026#34;）。最长的既是前缀也是后缀的字符串是 \u0026#34;l\u0026#34; 。 示例 2：\n1 2 3 输入：s = \u0026#34;ababab\u0026#34; 输出：\u0026#34;abab\u0026#34; 解释：\u0026#34;abab\u0026#34; 是最长的既是前缀也是后缀的字符串。题目允许前后缀在原字符串中重叠。 提示：\n1 \u0026lt;= s.length \u0026lt;= 105 s 只含有小写英文字母 解题思路 按照 KMP算法 next数组定义 ，next 数组就是 对每个 位置 i到 0 位置对比的最长前缀和后缀匹配的长度。\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: string longestPrefix(string s) { int n = s.size(); vector\u0026lt;int\u0026gt; next(n); next[0] = -1; int j=-1; for (int i=1;i\u0026lt;n;i++) { while(j!=-1 \u0026amp;\u0026amp; s[j+1] != s[i]) j=next[j]; if (s[j+1] == s[i]) j++; next[i] = j; } int suffixLen = next[n-1] + 1; return s.substr(0,suffixLen); } }; ","date":"2022-10-10T22:31:43+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.1392.%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%89%8D%E7%BC%80/","tags":["字符串"],"title":"lc.1392.最长快乐前缀"},{"categories":["字符串"],"contents":" 459. 重复的子字符串 Description Difficulty: 简单\nRelated Topics: 字符串 , 字符串匹配 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。\n示例 1:\n1 2 3 输入: s = \u0026#34;abab\u0026#34; 输出: true 解释: 可由子串 \u0026#34;ab\u0026#34; 重复两次构成。 示例 2:\n1 2 输入: s = \u0026#34;aba\u0026#34; 输出: false 示例 3:\n1 2 3 输入: s = \u0026#34;abcabcabcabc\u0026#34; 输出: true 解释: 可由子串 \u0026#34;abc\u0026#34; 重复四次构成。 (或子串 \u0026#34;abcabc\u0026#34; 重复两次构成。) 提示：\n1 \u0026lt;= s.length \u0026lt;= 104 s 由小写英文字母组成 Solution 思路解析 我们可以把字符串 s 写成\ns's's's's'\n1 2 3 4 5 6 class Solution { public: bool repeatedSubstringPattern(string s) { return (s + s).find(s, 1) != s.size(); } }; Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: bool repeatedSubstringPattern(string s) { int n = s.size(), j=-1; vector\u0026lt;int\u0026gt; next(n); next[0] = -1; for (int i=1;i\u0026lt;n;i++) { while(j!=-1 \u0026amp;\u0026amp; s[j+1] != s[i]) j=next[j]; if(s[j+1] == s[i]) ++j; next[i] = j; } return (next[n-1] != -1 ) \u0026amp;\u0026amp; ( n % (n-next[n-1] - 1) == 0); } }; ","date":"2022-10-10T22:18:02+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","tags":["字符串"],"title":"lc.459.重复的子字符串"},{"categories":["字符串"],"contents":"shift and 算法 Shift-And算法是一种基于前缀的单字符串匹配算法，采用位运算。其算法思想比KMP简单得多。\n在最简单的brute force算法中，在文本串的每个位置都要进行m(模式串长度)次比较，而SHIFT AND算法则是利用位运算提高这个过程。现在计算机的字长一般为32，64位也开始流行了。一次比较的值为true or false，只需要一位即可存储，所以计算机可以在一次运算里完成位长次的比较。通过此思路可以把brute force的速度提高位长倍。\nShift-And算法思想：设模式字符串为P，文本为text。它主要通过维护一个字符串集合D（D中记录了P中所有与当前已读text的某个后缀相匹配的前缀），集合D中的每个字符串既是模式串p的前缀，同时也是已读入文本的后缀，每当从text中读入一个新的字符，算法立即利用位并行机制来更新集合D。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int ShiftOrMatch(byte* pSrc, int nSrcSize, byte* pSubSrc, int nSubSrcSize) { long skip[256]; memset(skip, -1, sizeof(skip)); for (int i = 0; i \u0026lt; nSubSrcSize; i++) { skip[pSubSrc[i]] ^= (0x01 \u0026lt;\u0026lt; i); } long mask = ~(0x01 \u0026lt;\u0026lt; (nSubSrcSize - 1 )); long d = -1; int nPos = 0; while(nPos \u0026lt;= nSrcSize - nSubSrcSize) { d = (d\u0026lt;\u0026lt;0x01) | skip[pSrc[nPos]]; if (~(d|mask)) { break; } nPos++; } return nPos - (nSubSrcSize - 1); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int GetNextP(char ch ,int *code,int p ) { return (p\u0026lt;\u0026lt;1|1) \u0026amp; code[ch]; } int shift_and(const char *text, const char *pattern) { int code[256] = {0}; int n=0; for (n=0;pattern[n];++n) code[pattern[n]] |= (1\u0026lt;\u0026lt;n); int p=0; for (int i=0;text[i];i++) { //p 状态转移 p = GetNextP(text[i],code,p); //p 的第 n位是否为1 if(p \u0026amp; (1\u0026lt;\u0026lt;(n-1))) return i-n+1; } return -1; } shift-and 算法匹配原理 $$\nP = (P\u0026laquo;1 | 1) \u0026amp; d[s[i]]\n\\\nP \u0026amp; (1\u0026laquo; (n-1)) ?=1\n$$\n","date":"2022-10-10T20:59:33+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/shift-and%E7%AE%97%E6%B3%95/","tags":["字符串"],"title":"shift-and算法"},{"categories":["字符串"],"contents":"sunday算法 KMP算法是一个里程碑似的算法，它的出现宣告了人类是找到线性时间复杂度的字符串匹配算法的。在这之后，出现了许多的字符串匹配算法，比如BM算法和Sunday算法。\n现代文字处理器中，却很少使用KMP算法来做字符串匹配，因为还是太慢了。现在主流的算法是BM算法（Boyer-Moore算法），成功让平均时间复杂度降低到了O(m/n)，而Sunday算法，则是对BM算法的进一步小幅优化。\nSunday 算法是 Daniel M.Sunday 于 1990 年提出的字符串模式匹配。其效率在匹配随机的字符串时比其他匹配算法还要更快。Sunday 算法的实现可比 KMP，BM 的实现容易太多。\n平均性能的时间复杂度为 $O(n)$；\n最差情况的时间复杂度为 $O(n∗m)$。\n其实有很多算法可以来实现字符串查找，暴力的BF算法，经典的KMP算法，BM算法，Sunday算法等等，就效率和实现难度上来说，Sunday算法应该是性价比最高的，效率高，容易理解，实现也比较简单。\n参考博客 sunday 算法时间复杂度 最优秀情况下可以得到 $O(N/M)$\nSunday算法思想跟BM算法很相似，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。如果该字符没有在匹配串中出现则直接跳过，即移动步长= 匹配串长度+1；否则，同BM算法一样其移动步长=匹配串中最右端的该字符到末尾的距离+1。\nSunday算法实现\n视频教程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int sunday(const char*text, const char* pattern) { #define BASE 256 int last_pos[BASE]; int n= strlen(text), m = 0; for (int i=0;i\u0026lt;BASE;i++) { last_pos[i] = -1; } for (m=0;pattern[m];++m) { last_pos[pattern[m]] = m; } for (int i=0;i+m\u0026lt;=n; i +=(m - last_pos[i+m])) { int flag=1; for (int j=0;pattern[j];j++) { if (text[i+j] == pattern[j]) { continue; } flag=0; break; } if(flag) return i; } return -1; } ","date":"2022-10-10T00:25:57+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/sunday%E7%AE%97%E6%B3%95/","tags":["字符串"],"title":"sunday算法"},{"categories":["字符串"],"contents":"KMP 匹配算法 预处理过程：\npre_4 == last_4 pre_3 == last_3 pre_2 == last_2 如果不是最长的后缀，就可能错过答案的位置，要保证后缀和前缀最长。\n证明 两个串可以直接匹配：\n$$\nTA == TB\\\nSA == TA\\\nso:\\\nSA == TA\\\nTA == SB\\\n$$\nTa 可以和 SB直接对齐。\n直接 比较 sb后面黄色的那段就可以了，蓝色的那段不需要重复进行匹配。 黄色的那段位置是 i+j\n我们令 母串 S 的黄色位置是 i, 模式T当前匹配位置是 j,\n如果 i,j 不匹配，j就往前跳， i变，j下标变化，往模式串前面跳 $j=next[j]$。\n$Tb==Sb ==Ta$\n如果 Tb后面和Sb无法匹配，那么就从 Ta开始和 Sb匹配【模式串往前挪动,母串不变。】\n如果相等，就相当于 i,j增长一位，匹配下一位。\n如果不能匹配，Ta模式串里面还有更小的串可以进行匹配，我们叫做 小Ta。\n如果我们可以预处理出 Ta 和 Tb的信息的话，我们就可以提升字符串匹配的效率。\nKMP 预处理的过程 kmp预处理的是 j 跳到j' ,j' 跳到 j'' 的整个过程。 整个过程我们可以理解为是递归的。\n首先getNext 是模式串和模式串比较， 如果 模式串 i位置不等于 j位置，j就往前跳。\n如果匹配成功， 说明第 i位可以跳到 第 j+1 位置。\n1 2 3 4 5 6 7 8 9 10 void GetNext(const char*pattern,int *next) { next[0] = -1; for (int i=1,j=-1;pattern[i];i++) { while(j!=-1 \u0026amp;\u0026amp; pattern[j+1] != pattern[i]) j = next[j]; if(pattern[j+1] == patern[i]) j++; // 无法往前跳，或者 已经匹配完成 next[i] = j; } return; } KMP母串是不会往前回溯的，只会往后面跳，所以算法效率是非常高效的。\n伪代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 int match(const char*text,char * pattern) { GetNext(pattern); for (int i=0,j=-1;text[i];i++) { while(j!=-1 \u0026amp;\u0026amp; text[i] != pattern[j]) j= next[j]; if (text[i] == pattern[j+1]) j++; if (pattern[j+1] == \u0026#39;\\0\u0026#39;) return i-j; //match done } return -1; } KMP 算法模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int getNextJ(vector\u0026lt;int\u0026gt; \u0026amp;next,string \u0026amp;a,string \u0026amp;b,int i,int j) { while(j!=-1 \u0026amp;\u0026amp; a[i] != b[j+1]) j=next[j]; if(a[i] == b[j+1]) j++; return j; } int strStr(string S, string T) { int n= S.size(),m = T.size(); if(m==0) return 0; vector\u0026lt;int\u0026gt; next(m); next[0] = -1; int j=-1; for(int i=1;i\u0026lt;m;i++) { j = getNextJ(next,T,T,i,j); next[i] =j; } j=-1; for(int i=0;i\u0026lt;n \u0026amp;\u0026amp; j\u0026lt;m;i++) { j = getNextJ(next,S,T,i,j); // printf(\u0026#34;%d,%d\\n\u0026#34;,i,j); if(j==m-1) return i-j; } return -1; } }; 参考例题 https://leetcode.cn/problems/shortest-string-that-contains-three-strings/description/ ","date":"2022-10-09T21:35:28+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/kmp%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/","tags":["字符串"],"title":"kmp匹配算法"},{"categories":["贪心"],"contents":" 462. 最小操作次数使数组元素相等 II Description Difficulty: 中等\nRelated Topics: 数组 , 数学 , 排序 给你一个长度为 n 的整数数组 nums ，返回使所有数组元素相等需要的最小操作数。\n在一次操作中，你可以使数组中的一个元素加 1 或者减 1 。\n示例 1：\n1 2 3 4 5 输入：nums = [1,2,3] 输出：2 解释： 只需要两次操作（每次操作指南使一个元素加 1 或减 1）： [1,2,3] =\u0026gt; [2,2,3] =\u0026gt; [2,2,2] 示例 2：\n1 2 输入：nums = [1,10,2,9] 输出：16 提示：\nn == nums.length 1 \u0026lt;= nums.length \u0026lt;= 105 -109 \u0026lt;= nums[i] \u0026lt;= 109 Solution Language: C++\n解题思路 数学模型：\n$cost=Σ|p_i - p|$\n选址应该选择 pi序列的中位数\n解法 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int minMoves2(vector\u0026lt;int\u0026gt;\u0026amp; nums) { sort(nums.begin(),nums.end()); int n = nums.size(); int mid = nums[n/2]; int res=0; for(int x:nums) { res += abs(x - mid); } return res; } }; ","date":"2022-10-07T22:55:11+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/%E8%B4%AA%E5%BF%83/lc.462.%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/","tags":["贪心"],"title":"lc.462.最少移动次数使数组元素相等"},{"categories":["递推"],"contents":" 377. 组合总和 Ⅳ Description Difficulty: 中等\nRelated Topics: 数组 , 动态规划 给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。\n题目数据保证答案符合 32 位整数范围。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 输入：nums = [1,2,3], target = 4 输出：7 解释： 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。 示例 2：\n1 2 输入：nums = [9], target = 3 输出：0 提示：\n1 \u0026lt;= nums.length \u0026lt;= 200 1 \u0026lt;= nums[i] \u0026lt;= 1000 nums 中的所有元素 互不相同 1 \u0026lt;= target \u0026lt;= 1000 **进阶：**如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？\nSolution Language: C++\n解题思路 定义 dp[i][j], 由于 要求组合数是不忽略顺序的，比如 (1,1,2)和 (1,2,1) 顺序不一样，所以就是2种， 每个元素是有序的，\n我们之前的这种方式 $f[i][j]=f[i-1][j]+f[i][j-x]$ 是忽略数字出现的顺序的。\n所以 把i 和 j位置调换一下，写为 dp[j][i] 就可以很容易解决顺序问题。 dp[j][i] 的定义是 拼凑 j元钱使用前i种硬币拼凑的方法总数。\n递推方程为：\n$$\nf[j] = Σf(j-x_i)\ni∈ (1,n)\n$$\nf[j] 表示使用所有硬币拼凑j元钱的方法总数 , $x_i$ 表示每种硬币的面值\nf[j] 等于 所有 $f(j-x_i)$ 的方法总数求和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int combinationSum4(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n=nums.size(); vector\u0026lt;uint32_t\u0026gt; dp(target+1); dp[0] = 1; for(int i=1;i\u0026lt;=target;i++) { for (int j=0;j\u0026lt;n;j++) { int x = nums[j]; if(i\u0026gt;=x) { dp[i] += dp[i-x]; } } } return dp[target]; } }; ","date":"2022-10-07T22:42:42+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/lc.377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C5/","tags":["递推"],"title":"lc.377.组合总和5"},{"categories":["递推"],"contents":" 494. 目标和 Description Difficulty: 中等\nRelated Topics: 数组 , 动态规划 , 回溯 给你一个整数数组 nums 和一个整数 target 。\n向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：\n例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 \u0026quot;+2-1\u0026quot; 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。\n示例 1：\n1 2 3 4 5 6 7 8 输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3 示例 2：\n1 2 输入：nums = [1], target = 1 输出：1 提示：\n1 \u0026lt;= nums.length \u0026lt;= 20 0 \u0026lt;= nums[i] \u0026lt;= 1000 0 \u0026lt;= sum(nums[i]) \u0026lt;= 1000 -1000 \u0026lt;= target \u0026lt;= 1000 Solution Language: C++\n解题思路 滚动数组 + 偏移量 状态的更新方式是 我到哪里去，而不是我从哪里来！！\n经过推导，可以列出以下的 DP方程\n$$\ndp[next_ind][j+x] += f[ind][j]\ndp[next_ind][j-x] += f[ind][j]\n$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: int findTargetSumWays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); if(n\u0026lt;=0) return 0; // if(n==1) return nums[0] == target; int sum=0; for (auto x:nums) sum+=x; //dp[i][j] = f( dp[i-1][j -x ] , dp[i-1][j + x] ) int buff[2][2*sum + 5]; int *f[2] = {buff[0]+sum+2,buff[1] + sum + 2}; sum = 0; memset(buff,0,sizeof(buff)); f[0][0] = 1;//前0个值，拼出为0 是 1种方案 for (int i=1;i\u0026lt;=n;i++) { int x = nums[i-1]; int ind = i % 2; int pre = !ind; memset(buff[ind],0,sizeof(buff[ind])); for (int j=-sum;j\u0026lt;=sum;j++) { f[ind][j+x] += f[pre][j]; f[ind][j-x] += f[pre][j]; } sum+=x; } return f[n%2][target]; } }; ","date":"2022-10-07T22:21:31+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/lc.494.%E7%9B%AE%E6%A0%87%E5%92%8C/","tags":["递推"],"title":"lc.494.目标和"},{"categories":["递推"],"contents":" 474. 一和零 Description Difficulty: 中等\nRelated Topics: 数组 , 字符串 , 动态规划 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。\n请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。\n如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。\n示例 1：\n1 2 3 4 输入：strs = [\u0026#34;10\u0026#34;, \u0026#34;0001\u0026#34;, \u0026#34;111001\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;0\u0026#34;], m = 5, n = 3 输出：4 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {\u0026#34;10\u0026#34;,\u0026#34;0001\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;} ，因此答案是 4 。 其他满足题意但较小的子集包括 {\u0026#34;0001\u0026#34;,\u0026#34;1\u0026#34;} 和 {\u0026#34;10\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;} 。{\u0026#34;111001\u0026#34;} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。 示例 2：\n1 2 3 输入：strs = [\u0026#34;10\u0026#34;, \u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;], m = 1, n = 1 输出：2 解释：最大的子集是 {\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;} ，所以答案是 2 。 提示：\n1 \u0026lt;= strs.length \u0026lt;= 600 1 \u0026lt;= strs[i].length \u0026lt;= 100 strs[i] 仅由 '0' 和 '1' 组成 1 \u0026lt;= m, n \u0026lt;= 100 解题思路Fenix 这道题的模型是01 背包问题\n我们把容量看成是两个，最大m个0 和最大 n个 1，m和 n都是容量\n$$\ndp[i][j][k] = max(dp[i-1][j][k],dp[i-1][j-count0_x][k-count1_x] + 1)\n$$\ndp[i][j][k] 为最大子集的长度， 也就是说价值就是集合的元素个数\n每个元素都可以选择或者不选， 每个元素都是有自己的容量，满足不超过现有规定的容量下，求出子集的最大价值\n下面代码优化和压缩了 i变量，所以 j 和 k 容量要倒着变量【复用上一层的变量】\nLanguage: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int findMaxForm(vector\u0026lt;string\u0026gt;\u0026amp; strs, int m, int n) { int sn = strs.size(); vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;dp(m+1,vector\u0026lt;int\u0026gt;(n+1)); // dp[0][0] = 1; //0 ,1 for (auto \u0026amp;s :strs) { int cnt0 = value0(s); int cnt1 = s.size() - cnt0; for (int i=m;i\u0026gt;=cnt0;i--) { for (int j=n;j\u0026gt;=cnt1;j--) { dp[i][j] = max(dp[i][j],dp[i-cnt0][j-cnt1] + 1); } } } return dp[m][n]; } int value0(string \u0026amp;s) { int cnt=0; for (auto c:s) { if (c==\u0026#39;0\u0026#39;) cnt++; } return cnt; } }; ","date":"2022-10-07T21:18:14+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/lc.474.%E4%B8%80%E5%92%8C%E9%9B%B6/","tags":["递推"],"title":"lc.474.一和零"},{"categories":["递推"],"contents":" 416. 分割等和子集 Description Difficulty: 中等\nRelated Topics: 数组 , 动态规划 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n示例 1：\n1 2 3 输入：nums = [1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。 示例 2：\n1 2 3 输入：nums = [1,2,3,5] 输出：false 解释：数组不能分割成两个元素和相等的子集。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 200 1 \u0026lt;= nums[i] \u0026lt;= 100 Solution Language: C++\n思路 这个题是一个求解可达数组的问题\n设 $f[i][j]$ 为 前i个数字 是否能拼出 j\n经过数学归纳法可以证明一下公式\n$$\nf[i][j] = f[i-1][j] | f[i-1][j-nums_i]\\\nj∈(0,sum(nums))\n$$\n最终优化代码 由于$f[i][j]$ 依赖于 $f[i-1][j]$ 和 $f[i-1][j-nums_i]$ ,因为以为数组只是依赖于前一行状态，可以压缩掉i这个变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: bool canPartition(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if(n\u0026lt;=0) return false; int sum=0; for(auto x:nums) sum+=x; int target = sum/2; // int target = n/2; if(target*2 != sum) return false; vector\u0026lt;bool\u0026gt; dp(target+1); dp[0] = true; for (int i=0;i\u0026lt;n;i++) { auto x = nums[i]; for (int j=target;j \u0026gt;=x;j--) { dp[j] = dp[j] | dp[j-x]; } } return dp[target]; } }; 相似题目 leetcode 494目标和\n这道题 只能往上加数字，leetcode494的条件是既能加又能减\n","date":"2022-10-07T20:21:24+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/lc.416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/","tags":["递推"],"title":"lc.416.分割等和子集"},{"categories":["递推"],"contents":" 213. 打家劫舍 II Description Difficulty: 中等\nRelated Topics: 数组 , 动态规划 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。\n示例 1：\n1 2 3 输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2：\n1 2 3 4 输入：nums = [1,2,3,1] 输出：4 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 3：\n1 2 输入：nums = [1,2,3] 输出：3 提示：\n1 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 1000 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if (n==0) return 0; if(n==1) return nums[0]; int dp[n][2]; dp[0][0] = 0; dp[0][1] = nums[0];//投第一间 for (int i=1;i\u0026lt;n;i++) { dp[i][0] = max(dp[i-1][1],dp[i-1][0]); dp[i][1] = dp[i-1][0] + nums[i]; } int res = dp[n-1][0]; //不偷 dp[0][0] = dp[0][1] = 0; for (int i=1;i\u0026lt;n;i++) { dp[i][0] = max(dp[i-1][1],dp[i-1][0]); dp[i][1] = dp[i-1][0] + nums[i]; } res = max(res,dp[n-1][1]); return res; } }; ","date":"2022-10-07T20:07:36+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/lc.213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D2/","tags":["递推"],"title":"lc.213.打家劫舍2"},{"categories":["递推"],"contents":" 714. 买卖股票的最佳时机含手续费 Description Difficulty: 中等\nRelated Topics: 贪心 , 数组 , 动态规划 给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。\n你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。\n返回获得利润的最大值。\n**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。\n示例 1：\n1 2 3 4 5 6 7 8 输入：prices = [1, 3, 2, 8, 4, 9], fee = 2 输出：8 解释：能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8 示例 2：\n1 2 输入：prices = [1,3,7,5,10,3], fee = 3 输出：6 提示：\n1 \u0026lt;= prices.length \u0026lt;= 5 * 104 1 \u0026lt;= prices[i] \u0026lt; 5 * 104 0 \u0026lt;= fee \u0026lt; 5 * 104 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices, int fee) { int n = prices.size(); if(n\u0026lt;=1) return 0; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; dp(n,vector\u0026lt;int\u0026gt; (2)); //dp[i][0] = dp[i-1][1] 卖 dp[i-1][0] x //dp[1][1] = dp[i-1][1] x dp[i-1][0] 买 dp[0][0] = 0; dp[0][1] = -prices[0]; for (int i=1;i\u0026lt;n;i++) { //买入 或者 之前就有 dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i]); //卖出 dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i] - fee); } return dp[n-1][0]; } }; ","date":"2022-10-07T18:48:53+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/lc.714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/","tags":["递推"],"title":"lc.714.买卖股票的最佳时机含手续费"},{"categories":["dp"],"contents":"01 背包问题 有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。\n第 i 件物品的体积是 vi，价值是 wi。\n求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n输出最大价值。\n输入格式\n第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。\n接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。\n输出格式\n输出一个整数，表示最大价值。\n解题代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAXN = 1000+10; int v[MAXN],w[MAXN],dp[MAXN][MAXN]; int N,V; int main(void) { cin\u0026gt;\u0026gt;N\u0026gt;\u0026gt;V;//数量 和 背包容量 // vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(N+1,vector\u0026lt;int\u0026gt;(V+1)); for (int i=1;i\u0026lt;=N;i++) { // int u,v; cin\u0026gt;\u0026gt;v[i]\u0026gt;\u0026gt;w[i]; // 体积和价值 } for (int i=1;i\u0026lt;=N;i++) { for (int j=0;j\u0026lt;=V;j++) { dp[i][j] = dp[i-1][j];// 当前不选择, 01背包中的0 if (j\u0026gt;=v[i]) {//有条件转下 ， 01背包中的 1 dp[i][j] = max(dp[i][j],dp[i-1][j-v[i]] + w[i]); } } } cout \u0026lt;\u0026lt;dp[N][V]\u0026lt;\u0026lt;endl; return 0; } 代码优化 由于 网上的很多版本 对 01背包的代码做了很多的优化，如果记住优化后的代码，对于原来动态规划的性质反而不容易理解。 01背包的动规方程的性质是当前状态依赖于前一个 状态，也就是\ndp[i][j] 依赖于 dp[i-1][j] 这个状态\n滚动数组优化比较通用，这里建议记录滚动数组优化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAXN = 1000+10; int v[MAXN],w[MAXN]; int dp[2][MAXN]; int N,V; int main(void) { cin\u0026gt;\u0026gt;N\u0026gt;\u0026gt;V;//数量 和 背包容量 // vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(N+1,vector\u0026lt;int\u0026gt;(V+1)); for (int i=1;i\u0026lt;=N;i++) { // int u,v; cin\u0026gt;\u0026gt;v[i]\u0026gt;\u0026gt;w[i]; // 体积和价值 } for (int i=1;i\u0026lt;=N;i++) { int ind = i % 2; int preind = !ind; for (int j=0;j\u0026lt;=V;j++) { dp[ind][j] = dp[preind][j]; if (j\u0026gt;=v[i]) dp[ind][j] = max(dp[ind][j],dp[preind][j-v[i]] + w[i]); } } cout \u0026lt;\u0026lt;dp[N%2][V]\u0026lt;\u0026lt;endl; return 0; } ","date":"2022-10-07T18:22:13+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","tags":["dp"],"title":"01背包问题"},{"categories":["递推"],"contents":" 剑指 Offer II 094. 最少回文分割 Description Difficulty: 困难\nRelated Topics: 字符串 , 动态规划 给定一个字符串 s，请将 s 分割成一些子串，使每个子串都是回文串。\n返回符合要求的 最少分割次数 。\n示例 1：\n1 2 3 输入：s = \u0026#34;aab\u0026#34; 输出：1 解释：只需一次分割就可将 s 分割成 [\u0026#34;aa\u0026#34;,\u0026#34;b\u0026#34;] 这样两个回文子串。 示例 2：\n1 2 输入：s = \u0026#34;a\u0026#34; 输出：0 示例 3：\n1 2 输入：s = \u0026#34;ab\u0026#34; 输出：1 提示：\n1 \u0026lt;= s.length \u0026lt;= 2000 s 仅由小写英文字母组成 注意：本题与主站 132 题相同： https://leetcode-cn.com/problems/palindrome-partitioning-ii/ Solution 解题思路与分析 整个思路参考最长上升子序列的解法 定义dp[j] 为 从 0 到 j 为止，最少的回文分割的数量\n假设 (0,k) (k,j) 之中切一刀 使得两边都是回文串，并且 从 k 切出的回文串最短的话，\n那么 dp[j] 就会得到最小值。 所以这里是一个递推问题，\n我们要通过 for 循环 一个个的 去找 k 的值，看 k取什么值能让 dp[j] 最小，那么就可以求出dp[j], 同样的道理， k也可以按照这个步骤求，求到尽头就是答案。\nLanguage: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int minCut(string s) { int n = s.size(); // dp[0] = 0; vector\u0026lt;int\u0026gt; dp(n+1); for (int i=1;i\u0026lt;=n;i++) { dp[i] = i;// i个字符，i个回文串 for (int j=0;j\u0026lt;i;j++) { if (is_pali(s,j,i-1)) { //(j,i-1) 是否为回文串 dp[i] = min(dp[j]+1,dp[i]); } } } return dp[n]-1; } bool is_pali(string \u0026amp;s,int l,int r) { if (l==r) return true; if(l\u0026gt;r) return false; // l \u0026lt; r while(l\u0026lt;=r) { if(s[l++] - s[r--]) return false; } return true; } }; 优化版本 预处理字符串回文记录时间复杂度 为 $o(N^2)$, 整体 计算的时间复杂度为 $o(N^2)$ ,上面的那种做法时间复杂度为 $o(N^3)$\ndp公式为：\n$$\ndp[i] = min(dp[i],dp[j] + isPali(j,i))\\\n\\j∈(0,i)\n$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public: int minCut(string s) { int n = s.size(); vector\u0026lt;vector\u0026lt;bool\u0026gt; \u0026gt; pali(n,vector\u0026lt;bool\u0026gt;(n)); for(int i=0;i\u0026lt;n;i++) { pali[i][i] = true; if(i+1\u0026lt;n \u0026amp;\u0026amp; s[i] == s[i+1]) pali[i][i+1] = true; } for (int i=n-2;i\u0026gt;=0;i--) { for (int j=i;j\u0026lt;n;j++) { if(j-1\u0026gt;=0 \u0026amp;\u0026amp; i +1\u0026lt;n) { if(s[i] == s[j]) { if(pali[i+1][j-1]) pali[i][j] = true; } } } } // dp[0] = 0; vector\u0026lt;int\u0026gt; dp(n+1); for (int i=1;i\u0026lt;=n;i++) { dp[i] = i;// i个字符，i个回文串 for (int j=0;j\u0026lt;i;j++) { // if (is_pali(s,j,i-1)) { if(pali[j][i-1]) { //(j,i-1) 是否为回文串 dp[i] = min(dp[j]+1,dp[i]); } } } return dp[n]-1; } bool is_pali(string \u0026amp;s,int l,int r) { if (l==r) return true; if(l\u0026gt;r) return false; // l \u0026lt; r while(l\u0026lt;=r) { if(s[l++] - s[r--]) return false; } return true; } }; ","date":"2022-10-07T16:40:00+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/lc.%E5%89%91%E6%8C%87offer.%E6%9C%80%E5%B0%91%E5%9B%9E%E6%96%87%E5%88%86%E5%89%B2/","tags":["递推"],"title":"lc.剑指offer.最少回文分割"},{"categories":["递推"],"contents":" 53. 最大子数组和 Description Difficulty: 中等\nRelated Topics: 数组 , 分治 , 动态规划 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n子数组 是数组中的一个连续部分。\n示例 1：\n1 2 3 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：\n1 2 输入：nums = [1] 输出：1 示例 3：\n1 2 输入：nums = [5,4,-1,7,8] 输出：23 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 -104 \u0026lt;= nums[i] \u0026lt;= 104 **进阶：**如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。\nSolution Language: C++\n解法1： 前缀和原理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n= nums.size(); // vector\u0026lt;int\u0026gt; sum(n); for (int i=1;i\u0026lt;n;i++) // sum[i] = sum[i-1] + nums[i-1]; nums[i] += nums[i-1]; int pre=0,ans = INT_MIN; for (auto x: nums) { ans = max(x - pre,ans); pre = min(pre,x); } return ans; } }; 解法2： 贪心 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n= nums.size(); int cur = nums[0],ans = cur; // vector\u0026lt;int\u0026gt; sum(n); for (int i=1;i\u0026lt;n;i++) { // sum[i] = sum[i-1] + nums[i-1]; // nums[i] += nums[i-1]; if (cur \u0026lt; 0 ) cur = 0; cur += nums[i]; ans = max(ans,cur); } return ans; } }; ","date":"2022-10-07T14:04:15+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/lc.53.%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/","tags":["递推"],"title":"lc.53.最大子数组和"},{"categories":["递推"],"contents":" 322. 零钱兑换 Description Difficulty: 中等\nRelated Topics: 广度优先搜索 , 数组 , 动态规划 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。\n计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。\n你可以认为每种硬币的数量是无限的。\n示例 1：\n1 2 3 输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 示例 2：\n1 2 输入：coins = [2], amount = 3 输出：-1 示例 3：\n1 2 输入：coins = [1], amount = 0 输出：0 提示：\n1 \u0026lt;= coins.length \u0026lt;= 12 1 \u0026lt;= coins[i] \u0026lt;= 231 - 1 0 \u0026lt;= amount \u0026lt;= 104 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int coinChange(vector\u0026lt;int\u0026gt;\u0026amp; coins, int amount) { int n = coins.size(); vector\u0026lt;int\u0026gt; dp(amount+1,-1); dp[0] = 0; for (int i=1;i\u0026lt;=amount;i++) { for (auto c: coins) { if (i \u0026lt; c) continue; if(dp[i-c] == -1) continue; //可达 if(dp[i] == -1 || dp[i] \u0026gt; dp[i-c] + 1) dp[i] = dp[i-c]+1; } } return dp[amount]; } }; ","date":"2022-10-07T13:54:50+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/lc.332.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/","tags":["递推"],"title":"lc.332.零钱兑换"},{"categories":["递推"],"contents":" 152. 乘积最大子数组 Description Difficulty: 中等\nRelated Topics: 数组 , 动态规划 给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。\n测试用例的答案是一个 32-位 整数。\n子数组 是数组的连续子序列。\n示例 1:\n1 2 3 输入: nums = [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。 示例 2:\n1 2 3 输入: nums = [-2,0,-1] 输出: 0 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 提示:\n1 \u0026lt;= nums.length \u0026lt;= 2 * 104 -10 \u0026lt;= nums[i] \u0026lt;= 10 nums 的任何前缀或后缀的乘积都 保证 是一个 32-位 整数 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int maxProduct(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int ans = INT_MIN,max_num=1,min_num=1; int n = nums.size(); for (int i=0;i\u0026lt;n;i++) { if (nums[i] \u0026lt; 0) swap(max_num,min_num); max_num = max(nums[i] * max_num,nums[i]); min_num = min(nums[i] * min_num,nums[i]); //连续or 重新开始？ ans = max(max_num,ans); } return ans; } }; ","date":"2022-10-07T13:45:09+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/lc.152.%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/","tags":["递推"],"title":"lc.152.乘积最大子数组"},{"categories":["递推"],"contents":" 119. 杨辉三角 II Description Difficulty: 简单\nRelated Topics: 数组 , 动态规划 给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex行。\n在「杨辉三角」中，每个数是它左上方和右上方的数的和。\n示例 1:\n1 2 输入: rowIndex = 3 输出: [1,3,3,1] 示例 2:\n1 2 输入: rowIndex = 0 输出: [1] 示例 3:\n1 2 输入: rowIndex = 1 输出: [1,1] 提示:\n0 \u0026lt;= rowIndex \u0026lt;= 33 进阶：\n你可以优化你的算法到 _O_(_rowIndex_) 空间复杂度吗？\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;int\u0026gt; getRow(int rowIndex) { int n = rowIndex+1; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(2,vector\u0026lt;int\u0026gt;(n)); for (int i=0;i\u0026lt;n;i++) { int ind = i%2; int preind = !ind; f[ind][0] = 1; for (int j=1;j\u0026lt;=i;j++) { f[ind][j] = f[preind][j] + f[preind][j-1]; } } return f[(n-1)%2]; } }; ","date":"2022-10-07T12:51:02+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/lc.1193%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/","tags":["递推"],"title":"lc.1193杨辉三角"},{"categories":["递推"],"contents":" 120. 三角形最小路径和 Description Difficulty: 中等\nRelated Topics: 数组 , 动态规划 给定一个三角形 triangle ，找出自顶向下的最小路径和。\n每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。\n示例 1：\n1 2 3 4 5 6 7 8 输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]] 输出：11 解释：如下面简图所示： 2 3 4 6 5 7 4 1 8 3 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 示例 2：\n1 2 输入：triangle = [[-10]] 输出：-10 提示：\n1 \u0026lt;= triangle.length \u0026lt;= 200 triangle[0].length == 1 triangle[i].length == triangle[i - 1].length + 1 -104 \u0026lt;= triangle[i][j] \u0026lt;= 104 进阶：\n你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？ Solution Language: C++\n解题代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int minimumTotal(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; triangle) { int n = triangle.size(); // vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n+1,vector\u0026lt;int\u0026gt;(n)); vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; dp(2,vector\u0026lt;int\u0026gt; (n)); for (int i=0;i\u0026lt;n;i++) dp[(n-1) % 2][i] = triangle[n-1][i]; for (int i=n-2;i\u0026gt;=0;i--) { int ind = i%2; int next_ind = !ind; for (int j=0;j\u0026lt;=i;j++) { dp[ind][j] = min(dp[next_ind][j],dp[next_ind][j+1]) + triangle[i][j]; } } return dp[0][0]; } }; ","date":"2022-10-07T11:49:15+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/lc.120.%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","tags":["递推"],"title":"lc.120.三角形最小路径和"},{"categories":["递推"],"contents":"lc 256粉刷房子 假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。\n当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。\n例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int minCost(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; costs) { int n = costs.size(), house, color; if(n==0) return 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n,vector\u0026lt;int\u0026gt;(3,INT_MAX)); dp[0] = costs[0]; for(house = 1; house \u0026lt; n; house++) { for(color = 0; color \u0026lt; 3; ++color) { dp[house][color] = min(dp[house][color], costs[house][color]+min(dp[house-1][(color+1)%3], dp[house-1][(color+2)%3])); } } return min(dp[n-1][0], min(dp[n-1][1], dp[n-1][2])); } }; 由于这个是会员题，没法做，只能看别人的题解写笔记\n解题思路和分析 ","date":"2022-10-07T00:53:15+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/lc.256.%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/","tags":["递推"],"title":"lc.256.粉刷房子"},{"categories":["递推"],"contents":" 746. 使用最小花费爬楼梯 Description Difficulty: 简单\nRelated Topics: 数组 , 动态规划 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\n你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。\n请你计算并返回达到楼梯顶部的最低花费。\n示例 1：\n1 2 3 4 5 输入：cost = [10,15,20] 输出：15 解释：你将从下标为 1 的台阶开始。 - 支付 15 ，向上爬两个台阶，到达楼梯顶部。 总花费为 15 。 示例 2：\n1 2 3 4 5 6 7 8 9 10 输入：cost = [1,100,1,1,1,100,1,1,100,1] 输出：6 解释：你将从下标为 0 的台阶开始。 - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。 - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。 - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。 - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。 - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。 - 支付 1 ，向上爬一个台阶，到达楼梯顶部。 总花费为 6 。 提示：\n2 \u0026lt;= cost.length \u0026lt;= 1000 0 \u0026lt;= cost[i] \u0026lt;= 999 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int minCostClimbingStairs(vector\u0026lt;int\u0026gt;\u0026amp; cost) { int n = cost.size(); if(n\u0026lt;=0) return 0; if(n==1) return cost[0]; if(n==2) return min(cost[0],cost[1]); //if n == 2 ?? vector\u0026lt;int\u0026gt; dp(n+1); dp[0] = cost[0]; dp[1] = cost[1]; for (int i=2;i\u0026lt;n;i++) { dp[i] = min(dp[i-1],dp[i-2]) + cost[i]; } return min(dp[n-1],dp[n-2]); // return dp[n]; } }; ","date":"2022-10-07T00:43:34+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/lc.746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/","tags":["递推"],"title":"lc.746.使用最小花费爬楼梯"},{"categories":["递推"],"contents":"环形墙壁涂色问题 环形墙壁涂色问题：在一面环形墙上分成了n块，现在共有3种颜料，要给这个墙涂色，要求相邻不能是同一个颜色，问有多少种方案。\n方法1 f[n][i][j] 代表第 n块墙壁，在不考虑头尾成环的前提下，第一涂i,最后一块图j 的种类是多少？\nf(n,i,j) = Σf(n,i,j) (i!=j )\n把所有的 f(n,i,j), i!=j 的情况下累加起来，就是结果了。\n方法2 定义 f(n,j), j 为最后一块墙的颜色\nf(n,j) ,第1块涂 第0种颜色，最后一块涂第z种\n$f(n,j) = Σf(n-1,k) (k!=j)$\n的情况。\n$result = 3*(f[n][1] + f[n][2])$\n方法3 $f[n] = f[n-1] + 2*f[n-2]$\n我们可以这样理解，第 i块能涂什么颜色取决于前面 i-1 位能涂什么颜色，依这个逻辑 继续递推\n解题思路\n设dp[i]为长度为i的方案数，然后找出 dp[n] 与 dp[n - 1] 和 dp[n - 2] 的关系。\n考虑第 1 块和 n-1块颜色不一样的情况，现在第 n 块要和第 n-1和 1 都不一样，但是只有 3 种颜色，所以 n 只有一种颜色选择，这种情况方案数正好是 dp[n-1]。\n考虑第 1 块和 n-1 块颜色一样的情况，第 n-2 块必然要和第 n-1 块不同，同时也就和第 1 块不同，前面 n-2 块方案数是 dp[n-2]，第 n 块要和第 1 块和第 n-1块不同，有 2 种选择，所以这种情况方案数是 2∗dp[n−2]。\n上面 2 种情况加起来就是总方案数。\n参考 参考文章 ","date":"2022-10-06T22:09:25+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8/%E5%A2%99%E5%A3%81%E6%B6%82%E8%89%B2%E9%97%AE%E9%A2%98/","tags":["递推"],"title":"墙壁涂色问题"},{"categories":["树"],"contents":" 528. 按权重随机选择 Description Difficulty: 中等\nRelated Topics: 数学 , 二分查找 , 前缀和 , 随机化 给你一个 下标从 0 开始 的正整数数组 w ，其中 w[i] 代表第 i 个下标的权重。\n请你实现一个函数 pickIndex ，它可以 随机地 从范围 [0, w.length - 1] 内（含 0 和 w.length - 1）选出并返回一个下标。选取下标 i 的 概率 为 w[i] / sum(w) 。\n例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。 示例 1：\n1 2 3 4 5 6 7 8 输入： [\u0026#34;Solution\u0026#34;,\u0026#34;pickIndex\u0026#34;] [[[1]],[]] 输出： [null,0] 解释： Solution solution = new Solution([1]); solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。 示例 2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 输入： [\u0026#34;Solution\u0026#34;,\u0026#34;pickIndex\u0026#34;,\u0026#34;pickIndex\u0026#34;,\u0026#34;pickIndex\u0026#34;,\u0026#34;pickIndex\u0026#34;,\u0026#34;pickIndex\u0026#34;] [[[1,3]],[],[],[],[],[]] 输出： [null,1,1,1,1,0] 解释： Solution solution = new Solution([1, 3]); solution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。 solution.pickIndex(); // 返回 1 solution.pickIndex(); // 返回 1 solution.pickIndex(); // 返回 1 solution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。 由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的: [null,1,1,1,1,0] [null,1,1,1,1,1] [null,1,1,1,0,0] [null,1,1,1,0,1] [null,1,0,1,0,0] ...... 诸若此类。 提示：\n1 \u0026lt;= w.length \u0026lt;= 104 1 \u0026lt;= w[i] \u0026lt;= 105 pickIndex 将被调用不超过 104 次 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: vector\u0026lt;int\u0026gt; sum; int all; Solution(vector\u0026lt;int\u0026gt;\u0026amp; w):sum(w) { int n = w.size(); for (int i=1;i\u0026lt;n;i++) sum[i] += sum[i-1]; all = sum[n-1]; } int pickIndex() { int x = rand() % all; int head=0,tail = sum.size()-1; while(head \u0026lt; tail) { int mid = (head + tail)/2; if (sum[mid] \u0026lt;= x) head = mid+1; else tail = mid; } return head; } }; /** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(w); * int param_1 = obj-\u0026gt;pickIndex(); */ ","date":"2022-10-05T00:02:40+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/lc.528.%E6%8C%89%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9/","tags":["树"],"title":"lc.528.按权重随机选择"},{"categories":["树"],"contents":" 41. 缺失的第一个正数 Description Difficulty: 困难\nRelated Topics: 数组 , 哈希表 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。\n请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。\n示例 1：\n1 2 输入：nums = [1,2,0] 输出：3 示例 2：\n1 2 输入：nums = [3,4,-1,1] 输出：2 示例 3：\n1 2 输入：nums = [7,8,9,11,12] 输出：1 提示：\n1 \u0026lt;= nums.length \u0026lt;= 5 * 105 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int firstMissingPositive(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); for(int i=0;i\u0026lt;n;i++) { while(nums[i] != i+1) { if(nums[i] \u0026lt;= 0 || nums[i] \u0026gt; n) break; int nextInd = nums[i]-1; if(nums[i] == nums[nextInd]) break; swap(nums[nextInd],nums[i]); } } int ind=0; while(ind \u0026lt; n \u0026amp;\u0026amp; nums[ind] == ind+1) ++ind; return ind+1; } }; ","date":"2022-10-04T21:41:53+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/lc.41.%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/","tags":["树"],"title":"lc.41.缺失的第一个正数"},{"categories":["树"],"contents":" 220. 存在重复元素 III Description Difficulty: 困难\nRelated Topics: 数组 , 桶排序 , 有序集合 , 排序 , 滑动窗口 给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) \u0026lt;= t ，同时又满足 abs(i - j) \u0026lt;= k。\n如果存在则返回 true，不存在返回 false。\n示例 1：\n1 2 输入：nums = [1,2,3,1], k = 3, t = 0 输出：true 示例 2：\n1 2 输入：nums = [1,0,1,1], k = 1, t = 2 输出：true 示例 3：\n1 2 输入：nums = [1,5,9,1,5,9], k = 2, t = 3 输出：false 提示：\n0 \u0026lt;= nums.length \u0026lt;= 2 * 104 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 0 \u0026lt;= k \u0026lt;= 104 0 \u0026lt;= t \u0026lt;= 231 - 1 Solution Language: C++\n利用红黑树维持序列的顺序 解题技巧：\n在查找的时候，给 map 插入 左右两个范围节点，查找完成 再删除掉 范围节点，这样就不用判断各种边界情况了。\n解题原理 对于序列中每一个元素 x 左侧的至多 k 个元素，如果这 k 个元素中存在一个元素落在区间 [x - t, x + t] 中，我们就找到了一对符合条件的元素。注意到对于两个相邻的元素，它们各自的左侧的 k 个元素中有 k - 1 个是重合的。于是我们可以使用滑动窗口的思路，维护一个大小为 k 的滑动窗口，每次遍历到元素 x 时，滑动窗口中包含元素 x 前面的最多 k 个元素，我们检查窗口中是否存在元素落在区间 [x - t, x + t] 中即可。\n复杂度分析\n时间复杂度：O(n)，其中 n 是给定数组的长度。每个元素至多被插入哈希表和从哈希表中删除一次，每次操作的时间复杂度均为 O(1)。\n空间复杂度：O(min(n, k))，其中 n 是给定数组的长度。哈希表中至多包含 min(n,k+1) 个元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public: void delNums(map\u0026lt;long long,int\u0026gt; \u0026amp;h,int x) { h[x] -=1; if(h[x] == 0) { h.erase(h.find(x)); } } bool containsNearbyAlmostDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, int t) { int n = nums.size(); if(n\u0026lt;2) return false; map\u0026lt;long long,int\u0026gt; h; for (int i=0;i\u0026lt;n;i++) { if (i\u0026gt;k) { delNums(h,nums[i-k-1]); } //判断 [ x-t , x+t] 内是否存在值 h[nums[i] - t - 1] +=1; h[nums[i] + t + 1] +=1; auto iter = h.find(nums[i] - t -1); iter ++; if (iter-\u0026gt;first != nums[i] + t + 1) { return true; } delNums(h,nums[i] - t -1); delNums(h,nums[i] + t +1); h[nums[i]] +=1; } return false; } }; ","date":"2022-10-04T21:26:36+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/lc.220.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0iii/","tags":["树"],"title":"lc.220.存在重复元素III"},{"categories":["树"],"contents":" 78. 子集 Description Difficulty: 中等\nRelated Topics: 位运算 , 数组 , 回溯 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\n解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n示例 1：\n1 2 输入：nums = [1,2,3] 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 示例 2：\n1 2 输入：nums = [0] 输出：[[],[0]] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10 -10 \u0026lt;= nums[i] \u0026lt;= 10 nums 中的所有元素 互不相同 Solution Language: C++\n前置知识 得到最后1位1 的公式 $f(x)=x \u0026amp; (-x)$\n这里用二进制的 x表示\n比如\n$f(111) = 1$\n$f(110) = 10$\n$f(100) = 100$\n得到1的个数 $f(x) = (x-1) \u0026amp; x$\n方法1， 通过打表方式得到结果 1 2 3 4 5 6 7 [1, 2 , 3 ] 1 0 0 1 1 0 1 1 1 0 0 0 最大的二进制数 是 111, 也就是 $2^3=8$\n同理，所有可能的状态是 $2^N$, 如果是一个长度为$N$的数组的话。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: int number1(int x) { int res=0; while(x) { x = (x-1) \u0026amp; x; res++; } return res; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n= nums.size();//maxN = 10; int all = 1\u0026lt;\u0026lt;n; //1 ==\u0026gt; 1\u0026lt;\u0026lt;1 ==\u0026gt; 2 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; unordered_map\u0026lt;int,int\u0026gt; mark; for (int i=0,j=1;i\u0026lt;10;i++,j\u0026lt;\u0026lt;=1) mark[j] = i; for (int i=0;i\u0026lt;all;i++) { int k= number1(i); vector\u0026lt;int\u0026gt; tmp(k); int j=0; // 快速取1 算法 int val = i; while(val) { //x \u0026amp; -x tmp[j++] = nums[mark[val \u0026amp; (-val)]]; val \u0026amp;= (val-1); } res.emplace_back(tmp); } return res; } }; 方法1, 普通版，遍历所有长度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: int number1(int x) { int res=0; while(x) { x = (x-1) \u0026amp; x; res++; } return res; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n= nums.size();//maxN = 10; if(n\u0026lt;=0) return {}; int all = 1\u0026lt;\u0026lt;n; //1 ==\u0026gt; 1\u0026lt;\u0026lt;1 ==\u0026gt; 2 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; unordered_map\u0026lt;int,int\u0026gt; mark; for (int i=0,j=1;i\u0026lt;10;i++,j\u0026lt;\u0026lt;=1) mark[j] = i; for (int i=0;i\u0026lt;all;i++) { vector\u0026lt;int\u0026gt; tmp; for (int j=0;j\u0026lt;n;j++) { if ((i \u0026gt;\u0026gt; j) \u0026amp;1 ) { tmp.emplace_back(nums[j]); } } res.emplace_back(tmp); } return res; } }; ","date":"2022-10-04T20:28:16+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/lc.78.%E5%AD%90%E9%9B%86/","tags":["树"],"title":"lc.78.子集"},{"categories":["树"],"contents":" 449. 序列化和反序列化二叉搜索树 Description Difficulty: 中等\nRelated Topics: 树 , 深度优先搜索 , 广度优先搜索 , 设计 , 二叉搜索树 , 字符串 , 二叉树 序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。\n设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。\n编码的字符串应尽可能紧凑。\n示例 1：\n1 2 输入：root = [2,1,3] 输出：[2,1,3] 示例 2：\n1 2 输入：root = [] 输出：[] 提示：\n树中节点数范围是 [0, 104] 0 \u0026lt;= Node.val \u0026lt;= 104 题目数据 保证 输入的树是一棵二叉搜索树。 Solution Language: C++\n广义表的定义和解析方法 （1）A=（）——A是一个空表，其长度为零。\n（2）B=（e）——表B只有一个原子e，B的长度为1。\n（3）C=（a,(b,c,d))——表C的长度为2，两个元素分别为原子a和子表(b,c,d)。\n（4）D=（A，B，C）——表D的长度为3，三个元素都是广义表。显然，将子表的值代入后，则有D=(( ),(e),(a,(b,c,d)))。\n（5）E=（E）——这是一个递归的表，它的长度为2，E相当于一个无限的广义表E=(a,(a,(a,(a,…)))).\n广义表是线性表的推广，广义表中每个元素可以是原子，也可以是子表，原子即单个元素，而子表是广义表。我们可以发现，其实python中的数组就是一个广义表，其内元素可以是单个的元素，也可以是一个数组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Codec { public: // Encodes a tree to a single string. string serialize(TreeNode* root) { if(!root) return \u0026#34;\u0026#34;; string ret; stringstream ss; ss \u0026lt;\u0026lt; root-\u0026gt;val; ss \u0026gt;\u0026gt; ret; if (root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL) { return ret; } ret += \u0026#34;(\u0026#34;; ret += serialize(root-\u0026gt;left); if (root-\u0026gt;right) { ret += \u0026#34;,\u0026#34;; ret += serialize(root-\u0026gt;right); } ret += \u0026#34;)\u0026#34;; // 2(1,3?); return ret; } int num(string \u0026amp;buf,int \u0026amp;i) { int n = buf.size(); int res=0; while(i\u0026lt; n \u0026amp;\u0026amp; buf[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; buf[i] \u0026lt;= \u0026#39;9\u0026#39;) res = res*10 + (buf[i++] - \u0026#39;0\u0026#39;); return res; } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { //后序遍历构造 二叉树，通过压栈实现 int state = 0; int i=0, n = data.size(); stack \u0026lt;TreeNode* \u0026gt; s; TreeNode* pre = NULL,*root = NULL; int k = 0; //k==1 ,left ,k==2 right while (i \u0026lt; n) { switch (state) { case 0: { if (data[i] \u0026lt;= \u0026#39;9\u0026#39; \u0026amp;\u0026amp; data[i] \u0026gt;= \u0026#39;0\u0026#39;) { state = 1; } if (data[i] == \u0026#39;(\u0026#39;) { state = 2;// push stack } if (data[i] == \u0026#39;,\u0026#39;) { state = 3; //right child } if (data[i] == \u0026#39;)\u0026#39;) { state = 4;//pop stack } } break; case 1: { int x = num(data,i); pre = new TreeNode(x); if(root == NULL) root = pre; if (k==1) s.top()-\u0026gt;left = pre; else if (k==2) s.top()-\u0026gt;right = pre; state = 0; } break; case 2: { s.push(pre); i++; k=1;// left child parse state = 0; } break; case 3: { //, i++; k=2; state = 0; } break; case 4: { s.pop(); i++; state = 0; } break; } } return root; } }; // Your Codec object will be instantiated and called as such: // Codec* ser = new Codec(); // Codec* deser = new Codec(); // string tree = ser-\u0026gt;serialize(root); // TreeNode* ans = deser-\u0026gt;deserialize(tree); // return ans; ","date":"2022-10-04T20:00:36+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/lc.449.%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","tags":["树"],"title":"lc.449.序列化和反序列化二叉搜索树"},{"categories":["树"],"contents":" 117. 填充每个节点的下一个右侧节点指针 II Description Difficulty: 中等\nRelated Topics: 树 , 深度优先搜索 , 广度优先搜索 , 链表 , 二叉树 给定一个二叉树\n1 2 3 4 5 6 struct Node { int val; Node *left; Node *right; Node *next; } 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。\n初始状态下，所有 next 指针都被设置为 NULL。\n进阶：\n你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 示例：\n1 2 3 输入：root = [1,2,3,4,5,null,7] 输出：[1,#,2,3,#,4,5,7,#] 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），\u0026#39;#\u0026#39; 表示每层的末尾。 提示：\n树中的节点数小于 6000 -100 \u0026lt;= node.val \u0026lt;= 100 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public: Node* connect(Node* root) { if(!root) return NULL; Node *head = root; while(head = layer_connect(head)) ; return root; } Node *layer_connect(Node *head) { Node *p = head,*pre = NULL, *new_head = NULL; while(p) { if(p-\u0026gt;left) { if(pre) pre-\u0026gt;next = p-\u0026gt;left; pre = p-\u0026gt;left; } if(new_head==NULL) new_head = pre; if (p-\u0026gt;right) { if(pre) pre -\u0026gt;next = p-\u0026gt;right; pre = p-\u0026gt;right; } if(new_head==NULL) new_head = pre; p = p-\u0026gt;next; } return new_head; } }; ","date":"2022-10-04T18:44:00+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/lc.117.%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9/","tags":["树"],"title":"lc.117.填充每个节点的下一个右侧节点"},{"categories":["树"],"contents":" 971. 翻转二叉树以匹配先序遍历 Description Difficulty: 中等\nRelated Topics: 树 , 深度优先搜索 , 二叉树 给你一棵二叉树的根节点 root ，树中有 n 个节点，每个节点都有一个不同于其他节点且处于 1 到 n 之间的值。\n另给你一个由 n 个值组成的行程序列 voyage ，表示 预期 的二叉树 先序遍历 结果。\n通过交换节点的左右子树，可以 翻转 该二叉树中的任意节点。例，翻转节点 1 的效果如下：\n请翻转 最少 的树中节点，使二叉树的 先序遍历 与预期的遍历行程 voyage 相匹配 。\n如果可以，则返回 翻转的 所有节点的值的列表。你可以按任何顺序返回答案。如果不能，则返回列表 [-1]。\n示例 1：\n1 2 3 输入：root = [1,2], voyage = [2,1] 输出：[-1] 解释：翻转节点无法令先序遍历匹配预期行程。 示例 2：\n1 2 3 输入：root = [1,2,3], voyage = [1,3,2] 输出：[1] 解释：交换节点 2 和 3 来翻转节点 1 ，先序遍历可以匹配预期行程。 示例 3：\n1 2 3 输入：root = [1,2,3], voyage = [1,2,3] 输出：[] 解释：先序遍历已经匹配预期行程，所以不需要翻转节点。 提示：\n树中的节点数目为 n n == voyage.length 1 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= Node.val, voyage[i] \u0026lt;= n 树中的所有值 互不相同 voyage 中的所有值 互不相同 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int ind=0; vector\u0026lt;int\u0026gt; flipMatchVoyage(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; voyage) { vector\u0026lt;int\u0026gt; ret; if (!dfs(root,voyage,ret)) { return {-1}; } return ret; } bool dfs(TreeNode *root,vector\u0026lt;int\u0026gt; \u0026amp;voyage,vector\u0026lt;int\u0026gt; \u0026amp;ret) { if(!root) return true; if(voyage[ind] != root-\u0026gt;val) { // need flip ret.clear(); return false; } ind++; if (ind +1== voyage.size()) return true; // 不满足 if (root-\u0026gt;left \u0026amp;\u0026amp; voyage[ind] != root-\u0026gt;left-\u0026gt;val ) { //翻转 swap(root-\u0026gt;left,root-\u0026gt;right); ret.push_back(root-\u0026gt;val); } if(!dfs(root-\u0026gt;left,voyage,ret)) { return false; } if(!dfs(root-\u0026gt;right,voyage,ret)) { return false; } return true; } }; ","date":"2022-10-04T18:02:46+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/lc.971.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%A5%E5%8C%B9%E9%85%8D%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/","tags":["树"],"title":"lc.971.翻转二叉树以匹配先序遍历"},{"categories":["树"],"contents":" 981. 基于时间的键值存储 Description Difficulty: 中等\nRelated Topics: 设计 , 哈希表 , 字符串 , 二分查找 设计一个基于时间的键值数据结构，该结构可以在不同时间戳存储对应同一个键的多个值，并针对特定时间戳检索键对应的值。\n实现 TimeMap 类：\nTimeMap() 初始化数据结构对象 void set(String key, String value, int timestamp) 存储键 key、值 value，以及给定的时间戳 timestamp。 String get(String key, int timestamp) 返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev \u0026lt;= timestamp 。 如果有多个这样的值，则返回对应最大的 timestamp_prev 的那个值。 如果没有值，则返回空字符串（\u0026quot;\u0026quot;）。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 输入： [\u0026#34;TimeMap\u0026#34;, \u0026#34;set\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;set\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;get\u0026#34;] [[], [\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, 1], [\u0026#34;foo\u0026#34;, 1], [\u0026#34;foo\u0026#34;, 3], [\u0026#34;foo\u0026#34;, \u0026#34;bar2\u0026#34;, 4], [\u0026#34;foo\u0026#34;, 4], [\u0026#34;foo\u0026#34;, 5]] 输出： [null, null, \u0026#34;bar\u0026#34;, \u0026#34;bar\u0026#34;, null, \u0026#34;bar2\u0026#34;, \u0026#34;bar2\u0026#34;] 解释： TimeMap timeMap = new TimeMap(); timeMap.set(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, 1); // 存储键 \u0026#34;foo\u0026#34; 和值 \u0026#34;bar\u0026#34; ，时间戳 timestamp = 1 timeMap.get(\u0026#34;foo\u0026#34;, 1); // 返回 \u0026#34;bar\u0026#34; timeMap.get(\u0026#34;foo\u0026#34;, 3); // 返回 \u0026#34;bar\u0026#34;, 因为在时间戳 3 和时间戳 2 处没有对应 \u0026#34;foo\u0026#34; 的值，所以唯一的值位于时间戳 1 处（即 \u0026#34;bar\u0026#34;） 。 timeMap.set(\u0026#34;foo\u0026#34;, \u0026#34;bar2\u0026#34;, 4); // 存储键 \u0026#34;foo\u0026#34; 和值 \u0026#34;bar2\u0026#34; ，时间戳 timestamp = 4 timeMap.get(\u0026#34;foo\u0026#34;, 4); // 返回 \u0026#34;bar2\u0026#34; timeMap.get(\u0026#34;foo\u0026#34;, 5); // 返回 \u0026#34;bar2\u0026#34; 提示：\n1 \u0026lt;= key.length, value.length \u0026lt;= 100 key 和 value 由小写英文字母和数字组成 1 \u0026lt;= timestamp \u0026lt;= 107 set 操作中的时间戳 timestamp 都是严格递增的 最多调用 set 和 get 操作 2 * 105 次 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class TimeMap { public: TimeMap() { } struct Pair { int time; string value; }; unordered_map\u0026lt;string,vector\u0026lt;Pair\u0026gt;\u0026gt; mp; void set(string key, string value, int timestamp) { mp[key].push_back({timestamp,value}); } string get(string key, int timestamp) { if (mp.find(key) == mp.end()) return \u0026#34;\u0026#34;; auto \u0026amp; arr= mp[key]; if(arr.size()==0) return \u0026#34;\u0026#34;; int l=0,r = arr.size()-1; if (arr[0].time \u0026gt; timestamp) return \u0026#34;\u0026#34;; while(l\u0026lt;r) { int mid = (l+r+1)/2; auto \u0026amp;p = arr[mid]; if (p.time \u0026lt;= timestamp) l=mid; else r = mid-1; } return arr[l].value; } }; /** * Your TimeMap object will be instantiated and called as such: * TimeMap* obj = new TimeMap(); * obj-\u0026gt;set(key,value,timestamp); * string param_2 = obj-\u0026gt;get(key,timestamp); */ 方法2思路 map 是由红黑树实现的，会自动按照key来排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class TimeMap { public: TimeMap() { } unordered_map\u0026lt;string,map\u0026lt;int,string\u0026gt;\u0026gt; h; void set(string key, string value, int timestamp) { h[key][timestamp] = value; } string get(string key, int timestamp) { if(h.find(key) == h.end()) return \u0026#34;\u0026#34;; if(h[key].find(timestamp) != h[key].end()) return h[key][timestamp]; auto fake = pair\u0026lt;int,string\u0026gt; (timestamp,\u0026#34;\u0026#34;); h[key].insert(fake); auto iter = h[key].find(timestamp); auto pos = iter; auto \u0026amp;ret = (--pos) -\u0026gt; second; h[key].erase(iter); // 返回迭代器 return ret; } }; /** * Your TimeMap object will be instantiated and called as such: * TimeMap* obj = new TimeMap(); * obj-\u0026gt;set(key,value,timestamp); * string param_2 = obj-\u0026gt;get(key,timestamp); */ ","date":"2022-10-04T17:01:26+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/lc.981.%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8/","tags":["树"],"title":"lc.981.基于时间的键值存储"},{"categories":["树"],"contents":" 1339. 分裂二叉树的最大乘积 Description Difficulty: 中等\nRelated Topics: 树 , 深度优先搜索 , 二叉树 给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。\n由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。\n示例 1：\n1 2 3 输入：root = [1,2,3,4,5,6] 输出：110 解释：删除红色的边，得到 2 棵子树，和分别为 11 和 10 。它们的乘积是 110 （11*10） 示例 2：\n1 2 3 输入：root = [1,null,2,3,4,null,null,5,6] 输出：90 解释：移除红色的边，得到 2 棵子树，和分别是 15 和 6 。它们的乘积为 90 （15*6） 示例 3：\n1 2 输入：root = [2,3,9,10,7,8,6,5,4,11,1] 输出：1025 示例 4：\n1 2 输入：root = [1,1] 输出：1 提示：\n每棵树最多有 50000 个节点，且至少有 2 个节点。 每个节点的值在 [1, 10000] 之间。 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #define MOD (long long)(1e9+7) class Solution { public: int avg,total, ans; int maxProduct(TreeNode* root) { total = tree_sum(root); ans = total; avg = total/2; tree_sum(root); return (long long)(ans) * (total - ans) % MOD; } int tree_sum(TreeNode *root) { if(!root) return 0; // int val = root-\u0026gt;val; int left = tree_sum(root-\u0026gt;left); int right = tree_sum(root-\u0026gt;right); // ans = max(ans,sum * (sum - val)); if( abs(left+ right+ root-\u0026gt;val - avg) \u0026lt; abs(ans - avg )) { ans = left + right + root-\u0026gt;val; } return root-\u0026gt;val + left + right; } }; ","date":"2022-10-04T10:16:57+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/lc.1329.%E5%88%86%E8%A3%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/","tags":["树"],"title":"lc.1329.分裂二叉树的最大乘积"},{"categories":["树"],"contents":"红黑树 红黑树插入调整发生场景 新插入的节点是红色的！ 因为插入黑色一定引发失去平衡，插入红色不一定失去平衡。 红色节点和红色节点不能相见，所以红红相见会失衡，红黑相见不失衡\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; // Node *NIL = new Node(key,1); #define red 0 #define black 1 struct Node { Node(int key = 0, int color = red, Node *lchild = NULL, Node *rchild = NULL) : key(key), color(color), lchild(lchild), rchild(rchild) { } int key; int color; // 0 is red,1 is black, 2 is double Node *lchild; Node *rchild; // static Node __NIL; }; Node __NIL(0, black); // nil 是黑色节点 #define NIL (\u0026amp;__NIL) Node *newNode(int key) { return new Node(key, red, NIL, NIL); } void clear(Node *root) { if (root == NIL || root == NULL) return; clear(root-\u0026gt;lchild); clear(root-\u0026gt;rchild); } bool has_red_child(Node *root) { return root-\u0026gt;lchild -\u0026gt;color == red || root-\u0026gt;rchild-\u0026gt;color == red; } Node *left_rotate(Node *root) { Node *temp = root-\u0026gt;rchild; root-\u0026gt;rchild = temp -\u0026gt; lchild; temp -\u0026gt;lchild = root; return temp; } Node *right_rotate(Node *root) { Node *temp = root-\u0026gt;lchild; root-\u0026gt;lchild = temp -\u0026gt; rchild; temp -\u0026gt;rchild = root; return temp; } //构造空节点,高度为0 Node *insert_maintain(Node *root) { int flag = 0; if (root-\u0026gt;lchild-\u0026gt;color == red \u0026amp;\u0026amp; has_red_child(root-\u0026gt;lchild)) //左红红 flag = 1; if (root-\u0026gt;rchild-\u0026gt;color == red \u0026amp;\u0026amp; has_red_child(root-\u0026gt;rchild)) //右红红 flag = 2; if (flag == 0) return root; if(root-\u0026gt;lchild-\u0026gt;color == red \u0026amp;\u0026amp; root-\u0026gt;rchild-\u0026gt;color==red) {//flip colors root-\u0026gt;color = red; root -\u0026gt;lchild -\u0026gt;color = root-\u0026gt;rchild-\u0026gt;color = black; return root; } if (flag==1) { //left child fix if(root-\u0026gt;lchild-\u0026gt;rchild-\u0026gt;color == red) { root-\u0026gt;lchild = left_rotate(root-\u0026gt;lchild); } root = right_rotate(root);//上升 }else { //right child fix if(root-\u0026gt;rchild-\u0026gt;lchild-\u0026gt;color == red) { root-\u0026gt;rchild = right_rotate(root-\u0026gt;rchild); } root = left_rotate(root);//上升 } root-\u0026gt;color = red; root-\u0026gt; lchild -\u0026gt;color = root-\u0026gt;rchild-\u0026gt;color = black; return root; } Node *__insert(Node *root, int key) { if (root == NIL || root == NULL) return newNode(key); if (key == root-\u0026gt;key) return root; if (key \u0026lt; root-\u0026gt;key) { root-\u0026gt;lchild = __insert(root-\u0026gt;lchild, key); } else { root-\u0026gt;rchild = __insert(root-\u0026gt;rchild, key); } return insert_maintain(root); } // 这种编码技巧写出来的比较简单 Node *insert(Node *root, int key) { root = __insert(root,key); root -\u0026gt;color = black; return root; } Node *before(Node *root) { if (root == NIL || !root) return NIL; root = root-\u0026gt;lchild; while (root-\u0026gt;rchild != NIL) root = root-\u0026gt;rchild; return root; } const char *color(int t) { if (t==0) return \u0026#34;red\u0026#34;; return \u0026#34;black\u0026#34;; } void output(Node *root) { if (root == NIL) return; printf(\u0026#34;(%d,%d,%d) (%s)\\n\u0026#34;,root-\u0026gt;key, root-\u0026gt;lchild-\u0026gt;key,root-\u0026gt;rchild-\u0026gt;key,color(root-\u0026gt;color)); output(root-\u0026gt;lchild); // cout \u0026lt;\u0026lt; root-\u0026gt;key \u0026lt;\u0026lt; endl; output(root-\u0026gt;rchild); } int main(void) { Node *top = NIL; top = insert(top, 9999); output(top); printf(\u0026#34;---\\n\u0026#34;); top = insert(top, 18); top = insert(top, 19); top = insert(top, 1); top = insert(top, 2); top = insert(top, 10); top = insert(top, 14); top = insert(top, 16); top = insert(top, 20); output(top); return 0; } 红黑树删除调整 插入调整站在祖父节点看\n删除调整站在父节点看， 插入和删除情况处理一共五种。\n代码写不下去了，这里直接复制别人的代码。。\n参考文章 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define NIL (\u0026amp;__NIL) typedef struct Node { struct Node *lchild, *rchild; int color, val; } Node; Node __NIL; __attribute__((constructor)) void init_NIL() { NIL-\u0026gt;lchild = NIL-\u0026gt;rchild = NIL; NIL-\u0026gt;color = 1, NIL-\u0026gt;val = -1; return; } Node *getNewNode(int a) { Node *p = (Node *)malloc(sizeof(Node)); p-\u0026gt;color = 0, p-\u0026gt;val = a; p-\u0026gt;lchild = p-\u0026gt;rchild = NIL; return p; } void clear(Node *p) { if (p == NIL) return; clear(p-\u0026gt;lchild); clear(p-\u0026gt;rchild); free(p); return; } int has_red_child(Node *root) { return !root-\u0026gt;lchild-\u0026gt;color || !root-\u0026gt;rchild-\u0026gt;color; } Node *left_rotate(Node *root) { printf(\u0026#34;left%d\\n\u0026#34;, root-\u0026gt;val); Node *temp = root-\u0026gt;rchild; root-\u0026gt;rchild = temp-\u0026gt;lchild; temp-\u0026gt;lchild = root; return temp; } Node *right_rotate(Node *root) { printf(\u0026#34;right%d\\n\u0026#34;, root-\u0026gt;val); Node *temp = root-\u0026gt;lchild; root-\u0026gt;lchild = temp-\u0026gt;rchild; temp-\u0026gt;rchild = root; return temp; } Node *erase_maintain(Node *root) { if (root-\u0026gt;lchild-\u0026gt;color != 2 \u0026amp;\u0026amp; root-\u0026gt;rchild-\u0026gt;color != 2) return root; if (has_red_child(root)) { root-\u0026gt;color = 0; root-\u0026gt;lchild-\u0026gt;color \u0026amp;\u0026amp; (root = left_rotate(root), root-\u0026gt;color = 1, root-\u0026gt;lchild = erase_maintain(root-\u0026gt;lchild)) || (root = right_rotate(root), root-\u0026gt;color = 1, root-\u0026gt;rchild = erase_maintain(root-\u0026gt;rchild)); return root; } else { if ((root-\u0026gt;lchild-\u0026gt;color == 2 \u0026amp;\u0026amp; !has_red_child(root-\u0026gt;rchild)) || (root-\u0026gt;rchild-\u0026gt;color == 2 \u0026amp;\u0026amp; !has_red_child(root-\u0026gt;lchild))) root-\u0026gt;color++, root-\u0026gt;lchild-\u0026gt;color--, root-\u0026gt;rchild-\u0026gt;color--; else { if (root-\u0026gt;lchild-\u0026gt;color == 2) { root-\u0026gt;lchild-\u0026gt;color = 1; root-\u0026gt;rchild-\u0026gt;lchild-\u0026gt;color || (root-\u0026gt;rchild-\u0026gt;color = 0, root-\u0026gt;rchild = right_rotate(root-\u0026gt;rchild), root-\u0026gt;rchild-\u0026gt;color = 1); root-\u0026gt;rchild-\u0026gt;color = root-\u0026gt;color; root = left_rotate(root); root-\u0026gt;lchild-\u0026gt;color = root-\u0026gt;rchild-\u0026gt;color = 1; } else { root-\u0026gt;rchild-\u0026gt;color = 1; root-\u0026gt;lchild-\u0026gt;rchild-\u0026gt;color || (root-\u0026gt;lchild-\u0026gt;color = 0, root-\u0026gt;lchild = left_rotate(root-\u0026gt;lchild), root-\u0026gt;lchild-\u0026gt;color = 1); root-\u0026gt;lchild-\u0026gt;color = root-\u0026gt;color; root = right_rotate(root); root-\u0026gt;rchild-\u0026gt;color = root-\u0026gt;lchild-\u0026gt;color = 1; } } } return root; } Node *predecessor(Node *root) { root = root-\u0026gt;lchild; while (root-\u0026gt;rchild != NIL) root = root-\u0026gt;rchild; return root; } Node *__erase(Node *root, int key) { if (root == NIL) return NIL; root-\u0026gt;val \u0026gt; key \u0026amp;\u0026amp; (root-\u0026gt;lchild = __erase(root-\u0026gt;lchild, key)); root-\u0026gt;val \u0026lt; key \u0026amp;\u0026amp; (root-\u0026gt;rchild = __erase(root-\u0026gt;rchild, key)); if (root-\u0026gt;val == key) { if (root-\u0026gt;rchild == NIL || root-\u0026gt;lchild == NIL) { Node *temp = root-\u0026gt;rchild == NIL ? root-\u0026gt;lchild : root-\u0026gt;rchild; temp-\u0026gt;color += root-\u0026gt;color; free(root); return (temp); } Node *temp = predecessor(root); root-\u0026gt;val = temp-\u0026gt;val; root-\u0026gt;lchild = __erase(root-\u0026gt;lchild, root-\u0026gt;val); } return erase_maintain(root); } Node *erase(Node *root, int key) { if (root == NIL) return root; printf(\u0026#34;\\nerase: %d\\n\u0026#34;, key); root = __erase(root, key); root-\u0026gt;color = 1; return root; } Node *insert_maintain(Node *root) { if (root == NIL || !has_red_child(root)) return root; int a; if (root-\u0026gt;lchild-\u0026gt;color == 0 \u0026amp;\u0026amp; root-\u0026gt;rchild-\u0026gt;color == 0) { if (!has_red_child(root-\u0026gt;lchild) \u0026amp;\u0026amp; !has_red_child(root-\u0026gt;rchild)) return root; if (has_red_child(root-\u0026gt;lchild) || has_red_child(root-\u0026gt;rchild)) { root-\u0026gt;lchild-\u0026gt;color = root-\u0026gt;rchild-\u0026gt;color = 1; root-\u0026gt;color = 0; } return root; } if (!root-\u0026gt;lchild-\u0026gt;color) { if (!has_red_child(root-\u0026gt;lchild)) return root; !root-\u0026gt;lchild-\u0026gt;rchild-\u0026gt;color \u0026amp;\u0026amp; (root-\u0026gt;lchild = left_rotate(root-\u0026gt;lchild)); root = right_rotate(root); } if (!root-\u0026gt;rchild-\u0026gt;color) { if (!has_red_child(root-\u0026gt;rchild)) return root; !root-\u0026gt;rchild-\u0026gt;lchild-\u0026gt;color \u0026amp;\u0026amp; (root-\u0026gt;rchild = right_rotate(root-\u0026gt;rchild)); root = left_rotate(root); } root-\u0026gt;color = 0, root-\u0026gt;lchild-\u0026gt;color = root-\u0026gt;rchild-\u0026gt;color = 1; return root; } Node *__insert(Node *root, int a) { if (root == NIL) return getNewNode(a); if (root-\u0026gt;val == a) return root; root-\u0026gt;val \u0026lt; a \u0026amp;\u0026amp; (root-\u0026gt;rchild = __insert(root-\u0026gt;rchild, a)); a \u0026lt; root-\u0026gt;val \u0026amp;\u0026amp; (root-\u0026gt;lchild = __insert(root-\u0026gt;lchild, a)); return insert_maintain(root); } Node *insert(Node *root, int a) { printf(\u0026#34;insert: %d\\n\u0026#34;); if (!root) return getNewNode(a); root = __insert(root, a); root-\u0026gt;color = 1; return root; } void output(Node *root) { if (root == NIL) return; printf(\u0026#34;%d, color = %d | (%d, %d)\\n\u0026#34;, root-\u0026gt;val, root-\u0026gt;color, root-\u0026gt;lchild-\u0026gt;val, root-\u0026gt;rchild-\u0026gt;val); output(root-\u0026gt;lchild); output(root-\u0026gt;rchild); return; } int main() { int a; srand(time(0)); scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); Node *root = NIL; for (int i = 0; i \u0026lt; a; i++) root = insert(root, rand() % 100); output(root); while (~scanf(\u0026#34;%d\u0026#34;, \u0026amp;a)) root = erase(root, a), output(root); return 0; } ","date":"2022-10-03T21:28:16+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/3.%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0/","tags":["树"],"title":"3.红黑树实现"},{"categories":["树"],"contents":" 面试题 04.09. 二叉搜索树序列 Description Difficulty: 困难\nRelated Topics: 树 , 二叉搜索树 , 回溯 , 二叉树 从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。\n给定一个由不同节点组成的二叉搜索树 root，输出所有可能生成此树的数组。\n示例 1:\n1 2 3 4 5 6 输入: root = [2,1,3] 输出: [[2,1,3],[2,3,1]] 解释: 数组 [2,1,3]、[2,3,1] 均可以通过从左向右遍历元素插入树中形成以下二叉搜索树 2 / \\ 1 3 示例** 2:**\n1 2 输入: root = [4,1,null,null,3,2] 输出: [[4,1,3,2]] 提示：\n二叉搜索树中的节点数在 [0, 1000] 的范围内 1 \u0026lt;= 节点值 \u0026lt;= 10^6 用例保证符合要求的数组数量不超过 5000 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; BSTSequences(TreeNode* root) { return generate(root); // return ret; } void merge(vector\u0026lt;int\u0026gt; \u0026amp;left, vector\u0026lt;int\u0026gt; \u0026amp;right,vector\u0026lt;int\u0026gt;\u0026amp;buf,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;ret,int i,int j) { int n = left.size(), m = right.size(); if (i == n \u0026amp;\u0026amp; j == m) { ret.push_back(buf); return; } if (i\u0026lt; n) { buf.push_back(left[i]); merge(left,right,buf,ret,i+1,j); buf.pop_back(); } if (j\u0026lt; m) { buf.push_back(right[j]); merge(left,right,buf,ret,i,j+1); buf.pop_back(); } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; generate(TreeNode *root) { if (!root) { return {{}}; } if (root-\u0026gt;left==NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL) { return {{ root-\u0026gt;val }}; } auto left = generate(root-\u0026gt;left); auto right = generate(root-\u0026gt;right); vector\u0026lt;int\u0026gt; buf; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ret; buf.push_back(root-\u0026gt;val); for (auto l: left) { for (auto r: right) { merge(l,r,buf,ret,0,0); } } return ret; } }; ","date":"2022-10-03T18:01:56+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/lc.04.09.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E5%BA%8F%E5%88%97/","tags":["树"],"title":"lc.04.09.二叉搜索序列"},{"categories":["树"],"contents":" 450. 删除二叉搜索树中的节点 Description Difficulty: 中等\nRelated Topics: 树 , 二叉搜索树 , 二叉树 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 **key **对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n一般来说，删除节点可分为两个步骤：\n首先找到需要删除的节点； 如果找到了，删除它。 示例 1:\n1 2 3 4 5 输入：root = [5,3,6,2,4,null,7], key = 3 输出：[5,4,6,2,null,null,7] 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。 一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。 另一个正确答案是 [5,2,6,null,4,null,7]。 示例 2:\n1 2 3 输入: root = [5,3,6,2,4,null,7], key = 0 输出: [5,3,6,2,4,null,7] 解释: 二叉树不包含值为 0 的节点 示例 3:\n1 2 输入: root = [], key = 0 输出: [] 提示:\n节点数的范围 [0, 104]. -105 \u0026lt;= Node.val \u0026lt;= 105 节点值唯一 root 是合法的二叉搜索树 -105 \u0026lt;= key \u0026lt;= 105 进阶： 要求算法时间复杂度为 O(h)，h 为树的高度。\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode * before(TreeNode * x) { if(!x) return NULL; x = x-\u0026gt;left; while(x \u0026amp;\u0026amp; x-\u0026gt;right) x = x-\u0026gt;right; return x; } TreeNode* deleteNode(TreeNode* root, int key) { if(root==NULL) return root; if (key \u0026lt; root-\u0026gt;val) { root -\u0026gt; left = deleteNode(root-\u0026gt;left,key); }else if (key \u0026gt; root-\u0026gt;val) { root -\u0026gt;right = deleteNode(root-\u0026gt;right,key); }else { if (root-\u0026gt;left == NULL || root-\u0026gt;right == NULL) { TreeNode * tmp = (root-\u0026gt;left ? root-\u0026gt;left:root-\u0026gt;right); delete root; return tmp; } else { TreeNode * tmp = before(root); root-\u0026gt;val = tmp-\u0026gt;val; root-\u0026gt;left = deleteNode(root-\u0026gt;left,tmp-\u0026gt;val); } } return root; } }; ","date":"2022-10-03T17:15:15+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/lc.450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9/","tags":["树"],"title":"lc.450.删除二叉树的节点"},{"categories":["树"],"contents":"avl树实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; // Node *NIL = new Node(key,1); struct Node { Node(int key = 0, int h = 0, Node *left = NULL, Node *right = NULL) : key(key), left(left), right(right), h(h) {} int key, h; Node *left, *right; // static Node __NIL; }; // #define NIL (\u0026amp;Node::__NIL) Node *NIL = new Node(0,0); Node *newNode(int key) { return new Node(key, 1,NIL,NIL); } //构造空节点,高度为0 void update_height(Node *root) { // 由于更新高度特别复杂，这里可以用一个 nil 哨兵节点，简化代码实现 root-\u0026gt;h = max(root-\u0026gt;left-\u0026gt;h,root-\u0026gt;right-\u0026gt;h)+1; return; } Node * left_rotate(Node *root) { Node *new_root = root -\u0026gt;right; root-\u0026gt;right = new_root-\u0026gt;left; new_root-\u0026gt;left = root; update_height(root); update_height(new_root); return new_root; } Node * right_rotate(Node *root) { Node *new_root = root-\u0026gt;left; root-\u0026gt;left = new_root-\u0026gt;right; new_root-\u0026gt;right = root; update_height(root); update_height(new_root); return new_root; } Node * maintain(Node *root) { if(!root) return root; auto left = root-\u0026gt;left,right = root-\u0026gt;right; if(abs(left-\u0026gt;h - right -\u0026gt;h ) \u0026lt; 2) return root; if (left-\u0026gt;h \u0026gt; right -\u0026gt; h) { // L? if (left-\u0026gt;right -\u0026gt; h \u0026gt; root-\u0026gt;left -\u0026gt; h) { //LR root-\u0026gt;left = left_rotate(root-\u0026gt;left); }//LL root = right_rotate(root); }else {//R if (right-\u0026gt;left-\u0026gt;h \u0026gt; right-\u0026gt;right-\u0026gt;h) { //RL root -\u0026gt;right = right_rotate(root-\u0026gt;right); } root = left_rotate(root); } return root; } // 这种编码技巧写出来的比较简单 Node *insert(Node *root, int key) { if (root == NIL) return newNode(key); if (root-\u0026gt;key == key) return root; if (key \u0026lt; root-\u0026gt;key) root-\u0026gt;left = insert(root-\u0026gt;left, key); else root-\u0026gt;right = insert(root-\u0026gt;right, key); update_height(root); return maintain(root); } void clear(Node *root) { if (root == NIL) return; clear(root-\u0026gt;left); clear(root-\u0026gt;right); delete root; } Node *before(Node *root) { if (root==NIL || !root) return NIL; root = root-\u0026gt;left; while (root-\u0026gt;right != NIL) root = root-\u0026gt;right; return root; } Node *erase(Node *root, int key) { if (root == NIL) return root; if (key \u0026lt; root-\u0026gt;key) { root-\u0026gt;left = erase(root-\u0026gt;left, key); } else if (key \u0026gt; root-\u0026gt;key) { root-\u0026gt;right = erase(root-\u0026gt;right, key); } else { if (root-\u0026gt;left == NIL || root-\u0026gt;right == NIL) { Node *temp = (root-\u0026gt;left == NIL ? root-\u0026gt;right: root-\u0026gt;left); delete root; return temp; }else { Node *temp = before(root); root-\u0026gt;key = temp-\u0026gt;key; root-\u0026gt;left = erase(root-\u0026gt;left,temp-\u0026gt;key); } } update_height(root); return maintain(root); } Node *find(Node *root, int key) { if (!root) return NIL; if (root-\u0026gt;key == key) return root; if (root-\u0026gt;key \u0026gt; key) return find(root-\u0026gt;left, key); else return find(root-\u0026gt;right, key); return NIL; } void output(Node *root) { if (root == NIL) return; output(root-\u0026gt;left); cout \u0026lt;\u0026lt; root-\u0026gt;key \u0026lt;\u0026lt; endl; output(root-\u0026gt;right); } int main(void) { Node *top = newNode(10); insert(top, 19); insert(top, 1); insert(top, 2); insert(top, 10); insert(top, 14); output(top); return 0; } ","date":"2022-10-03T15:18:48+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/2.avl%E6%A0%91%E5%AE%9E%E7%8E%B0/","tags":["树"],"title":"2.AVL树实现"},{"categories":["树"],"contents":"二叉排序树实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct Node { Node(int key=0,Node* left=NULL, Node *right = NULL) :key(key),left(left),right(right){} int key; Node *left, *right; }; Node * newNode(int key) { return new Node(key); } // 这种编码技巧写出来的比较简单 Node *insert(Node *root,int key) { if (root == NULL) return newNode(key); if (root-\u0026gt;key == key) return root; if (key \u0026lt; root-\u0026gt;key) root-\u0026gt;left = insert(root-\u0026gt;left,key); else root-\u0026gt;right = insert(root-\u0026gt;right,key); return root; } void clear(Node *root) { if (root == NULL) return; clear(root-\u0026gt;left); clear(root-\u0026gt;right); delete root; } Node *before(Node *root) { if(!root) return NULL; while(root-\u0026gt;left) root = root-\u0026gt;left; return root; } Node *after(Node *root) { if(!root) return NULL; while(root-\u0026gt;right) root = root-\u0026gt;right; return root; } Node *erase(Node *root,int key) { if (root == NULL) return root; if(key \u0026lt; root-\u0026gt;key) { root-\u0026gt;left = erase(root-\u0026gt;left,key); }else if (key \u0026gt; root-\u0026gt;key) { root-\u0026gt;right = erase(root-\u0026gt;right,key); }else { if (root -\u0026gt;left ==NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL) { delete root; return NULL; }else if (root-\u0026gt;left == NULL || root-\u0026gt;right == NULL) { Node *temp = root-\u0026gt;left ? root-\u0026gt;left : root-\u0026gt;right; delete root; return temp; }else { Node *temp = before(root); //前驱节点 root-\u0026gt;key = temp-\u0026gt;key; // root-\u0026gt;left = erase(root-\u0026gt;left,temp-\u0026gt;key); } } return root; } Node * find(Node *root,int key) { if(!root) return NULL; if (root-\u0026gt;key == key) return root; if (root-\u0026gt;key \u0026gt; key) return find(root-\u0026gt;left,key); else return find(root-\u0026gt;right,key); return NULL; } void output(Node *root) { if(root==NULL) return; output(root-\u0026gt;left); cout \u0026lt;\u0026lt; root -\u0026gt;key \u0026lt;\u0026lt;endl; output(root-\u0026gt;right); } int main(void) { Node *top = newNode(10); insert(top,19); insert(top,1); insert(top,2); insert(top,10); insert(top,14); output(top); return 0; } ","date":"2022-10-03T15:15:57+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/1.%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%AE%9E%E7%8E%B0/","tags":["树"],"title":"二叉排序树实现"},{"categories":["dp"],"contents":" 300. 最长递增子序列 Description Difficulty: 中等\nRelated Topics: 数组 , 二分查找 , 动态规划 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n示例 1：\n1 2 3 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2：\n1 2 输入：nums = [0,1,0,3,2,3] 输出：4 示例 3：\n1 2 输入：nums = [7,7,7,7,7,7,7] 输出：1 提示：\n1 \u0026lt;= nums.length \u0026lt;= 2500 -104 \u0026lt;= nums[i] \u0026lt;= 104 进阶：\n你能将算法的时间复杂度降低到 O(n log(n)) 吗? Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if (n\u0026lt;=1) return n; vector\u0026lt;int\u0026gt; len(n,1); // 最短是它本身 for (int i=0;i\u0026lt;n;i++) { for (int j=0;j\u0026lt;i;j++) { if(nums[i] \u0026gt; nums[j]) { len[i] = max(len[i],len[j]+1); } } } //求出 每一个 i 结尾的 最长序列长度，寻找到最长的序列长度就是答案 int res = 0; for (int i=0;i\u0026lt;n;i++) res = max(res,len[i]); return res; } }; [[序列边界\\最长上升子序列等问题详解.md]]\n","date":"2022-10-02T23:09:27+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/lc.300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/","tags":["dp"],"title":"lc.300.最长上升子序列"},{"categories":["shell"],"contents":"帮住命令 man命令，manual缩写， man ls , man 7 man , 通过 man 命令获得man 的帮主 help ， 命令解释器自带的叫做内部命令，其他为外部命令 info 命令， info 比 help 更详细，作为 help的补充 内部命令使用 help 帮助 help cd, 内部命令这样用 ls --help , 外部命令使用 --help 这么多linux的命令不能死记硬背，必须要用上面3种来学习和推导 其他命令的使用方法\n1 2 3 4 5 6 7 8 man man type cd # cd 是 内嵌命令 help cd type ls # 显示是外部命令 ls --help flock 命令介绍 1 flock -xn \u0026#34;/tmp/f.lock\u0026#34; -c \u0026#34;/root/a.sh\u0026#34; ","date":"2022-10-02T16:09:35+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/shell%E5%9F%BA%E6%9C%AC/","tags":["shell"],"title":"shell基础"},{"categories":["git操作杂记"],"contents":"git 操作杂记 git config git config 的三个作用域\n1 2 3 4 5 6 7 8 9 git config --local # 某个仓库 git config --global # 当前用户所有仓库 git config --system # 是对系统所有登录用户 git config --list --global 删除不需要的分支 1 2 3 4 5 6 7 8 9 10 git branch -av gitk --all # 查看各种分支的关联 git branch -d fix-readme # 删除 fix-readme分支 git branch -D fix-readme # 确认强行删除 fix-readme 分支 commit tree 和blob 区别 一次commit 对应一颗树(视图)，当前本项目所有的文件快照，这个时间点所有时间段文件的记录都记录在tree里面\nblob是指的是具体某个文件\ncommit === 每次提交的集合\ntree === 文件夹\nblob === 文件\n1 git cat file -p master 如何快速淘到自己感兴趣的开源项目 在搜索框输入 git 最好 学习 资料 in:readme, 利用git搜索引擎提高查询效率。\n默认搜索框搜索的是 仓库名称 和仓库描述 这段话。\n搜索:\nlaunguage:go starts:\u0026gt;3000 web in:readme\n取消暂存区部分文件变更 只是取消某个文件撤销 1 2 git reset HEAD -- styles/style.css git reset -- index.html readme.me 恢复全部 1 git reset --hard git log 查看历史 1 2 3 4 5 6 7 git log --oneline # 查看哪次变更了什么东西 git log -n4 # 最近的4次 commit git branch -v # 本地多少分支 git log -n3 --graph 通过 github 进行 code review 点击 settings.branchs, add rule\nadd rule to master, 勾选上 require pull request reviews before merging\ncommit Messge 相关 我们修改代码 提交后，发现 commit message 写的不好\n要如何修改 message 呢？\n修改最近一次的 commit message 1 2 3 4 5 # 命令演示如下： 也可用 gitk工具 修改 git log -l git commit --amend # 就可以对最近一次提交的message 变更 修改前几次提交的 commit message 如果觉得 前几次的 commit message 有问题，就可以用 rebase 修改\n1 2 3 4 5 6 git log -3 # 查看最近3次提交 # 变基 git rebase # 交互式变基 git rebase -i 连续的几个 commit 整理成1个 1 2 3 4 5 git branch -av git rebase -i git log --graph commit message 那里 ，将pick 改为 s, 具体命令用法参考注释文档\n间隔的几个 commit 整理成1个 1 2 3 4 git rebase -i f09112c # 将一个 地方 的 pick 改为 s, 然后 合并 git rebase --continue git rebase 合并代码 参考学习教程 1 2 3 4 git checkout main git rebase feacture1 git push “rebase的最大好处并不是消除merge，而是避免merge的交织。\n简要来说，就是在merge进被合分支（如master）之前，最好将自己的分支给rebase到最新的被合分支（如master）上，然后用pull request创建merge请求\n官网推荐的是\n第一步，次级分支rebase main\n第二步， main merge次级分支。\n参考教程 rebase 其他用法演示 git 提倡多用分之，开发的时候你可以根据 bug fix 或者 new feature 前缀命名分之。\n1 2 3 4 5 # 新建分之并切过去开搞(一般我在 zsh 里映射了很多 git 快捷命令) git checkout -b bugfix # ... 在你搞完了之后执行 add 和 commit （当然中间可以用 rabase -i 合并一些无用提交信息） git add . git commit -m \u0026#34;fix a bug balabala\u0026#34; 注意这个时候可能有其他人已经把它的代码合并到了 zhihu 的 master 上了，你本地的 master 已经落后了。这个时候可以用 git rebase 了。\n1 2 3 4 5 git checkout master # 切换自己的 master git pull zhihu master # 拉取 zhihu 主仓库 master 保持本地 master 最新 git checkout bugfix git rebase master # 切到刚才的分支并且 rebase master。中间有冲突解决后 git add add 然后 git rebase --contiune # 这个时候就可以提个 MR 了。 上边也可以用 git pull --rebase zhihu master 来简化，一般我都是用 git 简化命令，操作起来很快 Rebase 黄金法则 最后必须要提到一条 rebase 黄金法则：绝不要在公共的分支上使用它。 git rebase 会重写历史，一定只能在你自己的分支上使用它, 否则你的队友们可能会暴打你一顿。\n自定义 alias 参考博客 1 2 3 4 5 6 7 git config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; git config --global alias.ld \u0026#39;log --pretty=format:\u0026#34;%C(yellow)%h\\\\ %C(green)%ad%Cred%d\\\\ %Creset%s%Cblue\\\\ [%cn]\u0026#34; --decorate --date=short --graph\u0026#39; git config --global alias.ls \u0026#39;log --pretty=format:\u0026#34;%C(green)%h\\\\ %C(yellow)[%ad]%Cred%d\\\\ %Creset%s%Cblue\\\\ [%cn]\u0026#34; --decorate --date=relative\u0026#39; git config --global alias.ll \u0026#39;log --pretty=format:\u0026#34;%C(yellow)%h%Cred%d\\\\ %Creset%s%Cblue\\\\ [%cn]\u0026#34; --decorate --numstat\u0026#39; git config --global alias.last \u0026#39;log -1 HEAD\u0026#39; git config --global alias.s \u0026#39;status\u0026#39; git config --global alias.view \u0026#39;diff\u0026#39; 比较 HEAD 和 暂存区 1 2 3 4 5 6 7 8 # example: vi index.html # 修改了文件 git add index.html git status # modified: index.html git diff --cached ","date":"2022-10-02T09:26:17+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/git%E6%93%8D%E4%BD%9C%E6%9D%82%E8%AE%B0/git%E6%93%8D%E4%BD%9C%E6%9D%82%E8%AE%B0/","tags":["git操作杂记"],"title":"git操作杂记"},{"categories":["深度优先搜索"],"contents":" 473. 火柴拼正方形 Description Difficulty: 中等\nRelated Topics: 位运算 , 数组 , 动态规划 , 回溯 , 状态压缩 你将得到一个整数数组 matchsticks ，其中 matchsticks[i] 是第 i 个火柴棒的长度。你要用 所有的火柴棍 拼成一个正方形。你 不能折断 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 使用一次 。\n如果你能使这个正方形，则返回 true ，否则返回 false 。\n示例 1:\n1 2 3 输入: matchsticks = [1,1,2,2,2] 输出: true 解释: 能拼成一个边长为2的正方形，每边两根火柴。 示例 2:\n1 2 3 输入: matchsticks = [3,3,3,3,4] 输出: false 解释: 不能用所有火柴拼成一个正方形。 提示:\n1 \u0026lt;= matchsticks.length \u0026lt;= 15 1 \u0026lt;= matchsticks[i] \u0026lt;= 108 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public: bool makesquare(vector\u0026lt;int\u0026gt;\u0026amp; matchsticks) { int n = matchsticks.size(); if (n\u0026lt;4) return false; sort(matchsticks.begin(),matchsticks.end()); vector\u0026lt;int\u0026gt; arr(4); int sum = 0; for (auto x: matchsticks) sum += x; //计算木棍总长度 for (int i=0;i\u0026lt;4;i++) arr[i] = sum / 4; if (arr[0] * 4 != sum) return false; return dfs(matchsticks.size()-1, arr,matchsticks); } bool dfs(int ind,vector\u0026lt;int\u0026gt; \u0026amp;arr,vector\u0026lt;int\u0026gt; \u0026amp;matchs) { if (ind == -1) return true; //尝试第 i个 木棍依次放入四桶 for (int i=0;i\u0026lt;4;i++) { if (matchs[ind] \u0026gt; arr[i]) { //放不下 continue; } // 能放下 if (arr[i] == matchs[ind] || arr[i] \u0026gt;= matchs[ind] + matchs[0]) { // 当前桶 \u0026gt;= 当前棍子+ 最短棍子的长度 arr[i] -= matchs[ind]; // bool ok = if (dfs(ind -1, arr,matchs)) { return true; } arr[i] += matchs[ind]; } } return false; } }; ","date":"2022-10-02T00:31:33+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%9E%9A%E4%B8%BE/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/lc.473.%E7%81%AB%E6%9F%B4%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2/","tags":["深度优先搜索"],"title":"lc.473.火柴拼正方形"},{"categories":["深度优先搜索"],"contents":" 39. 组合总和 Description Difficulty: 中等\nRelated Topics: 数组 , 回溯 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\ncandidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。\n对于给定的输入，保证和为 target 的不同组合数少于 150 个。\n示例 1：\n1 2 3 4 5 6 输入：candidates = [2,3,6,7], target = 7 输出：[[2,2,3],[7]] 解释： 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。 7 也是一个候选， 7 = 7 。 仅有这两种组合。 示例 2：\n1 2 输入: candidates = [2,3,5], target = 8 输出: [[2,2,2,2],[2,3,3],[3,5]] 示例 3：\n1 2 输入: candidates = [2], target = 1 输出: [] 提示：\n1 \u0026lt;= candidates.length \u0026lt;= 30 1 \u0026lt;= candidates[i] \u0026lt;= 200 candidate 中的每个元素都 互不相同 1 \u0026lt;= target \u0026lt;= 500 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; ans; vector\u0026lt;int\u0026gt; buf; dfs(0,target,buf,ans,candidates); return ans; } void dfs(int ind,int target, vector\u0026lt;int\u0026gt; \u0026amp;buf, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;ret,vector\u0026lt;int\u0026gt; \u0026amp;candidates) { if(ind \u0026gt;= candidates.size()) return; if (target\u0026lt;0) return ; if (target == 0) { // add buf ret.push_back(buf); return ; } // 尝试放入 数字到 buf //case 不选 dfs(ind+1,target,buf,ret,candidates); buf.push_back(candidates[ind]); //case 选 dfs(ind,target - candidates[ind],buf,ret,candidates); //一个位置可以无限次选 buf.pop_back(); } }; ","date":"2022-10-02T00:31:06+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%9E%9A%E4%B8%BE/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/lc.39.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/","tags":["深度优先搜索"],"title":"lc.39.组合总和"},{"categories":["广度优先搜索"],"contents":" 993. 二叉树的堂兄弟节点 Description Difficulty: 简单\nRelated Topics: 树 , 深度优先搜索 , 广度优先搜索 , 二叉树 在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。\n如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对_堂兄弟节点_。\n我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。\n只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。\n示例 1：\n1 2 输入：root = [1,2,3,4], x = 4, y = 3 输出：false 示例 2：\n1 2 输入：root = [1,2,3,null,4,null,5], x = 5, y = 4 输出：true 示例 3：\n1 2 输入：root = [1,2,3,null,4], x = 2, y = 3 输出：false 提示：\n二叉树的节点数介于 2 到 100 之间。 每个节点的值都是唯一的、范围为 1 到 100 的整数。 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: struct Data { TreeNode * data, *parent; int depth; }; bool isCousins(TreeNode* root, int x, int y) { if(!root) { return false; } if(!x) return false; if(!y) return false; if(x == y) return false; //深度相同，并且值不同，就是堂兄弟节点 queue\u0026lt;Data\u0026gt; q; q.push({root,NULL,0}); int xdepth = -1,ydepth = -1; TreeNode *xnode=NULL, *ynode=NULL; while(q.size()) { auto f= q.front();q.pop(); auto node = f.data; auto depth = f.depth; if(node-\u0026gt;val == x) { xdepth = depth; xnode = f.parent; }else if(node-\u0026gt;val == y) { ydepth = depth; ynode = f.parent; } if(node-\u0026gt;left) q.push({node-\u0026gt;left,node,depth+1}); if(node-\u0026gt;right) q.push({node-\u0026gt;right,node,depth+1}); } if(xdepth!=ydepth) return false; return xnode != ynode; } }; ","date":"2022-10-02T00:30:09+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%9E%9A%E4%B8%BE/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/lc.993.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/","tags":["广度优先搜索"],"title":"lc.993.二叉树堂兄弟节点"},{"categories":["枚举"],"contents":"搜索的核心 问题求解树：\n","date":"2022-10-01T21:07:15+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%9E%9A%E4%B8%BE/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83/","tags":["枚举"],"title":"搜索算法的核心"},{"categories":["哈希"],"contents":"布隆过滤器算法 ","date":"2022-10-01T16:00:50+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%AE%97%E6%B3%95/","tags":["哈希"],"title":"布隆过滤器算法"},{"categories":["哈希"],"contents":"哈希表学习 字符串哈希算法经典实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class HashTable { public: vector\u0026lt;bool\u0026gt; flag; vector\u0026lt;string\u0026gt; data; int cnt; HashTable(int n = 100) : flag(n), data(n), cnt(n) {} bool find(string \u0026amp;s) { int ind = hash_func(s) % data.size(); recalc_ind(ind, s); return flag[ind]; } bool remove(string \u0026amp;s) { int ind = hash_func(s) % data.size(); recalc_ind(ind, s); flag[ind] = false; --cnt; } void insert(string \u0026amp;s) { int ind = hash_func(s) % data.size(); recalc_ind(ind, s); if (!flag[ind]) { data[ind] = s; flag[ind] = true; cnt += 1; if (cnt * 100 \u0026gt; data.size() * 75) { expand(); } } } void expand() { vector\u0026lt;int\u0026gt; newFlag; int n = data.size(); HashTable newTab(n * 2); for (int i = 0; i \u0026lt; n; i++) { if (!flag[i]) continue; newTab.insert(data[i]); } *this = newTab; } int hash_func(string \u0026amp;s) { int seed = 131, hash = 0; for (int i = 0; s[i]; i++) { hash = hash * seed + s[i]; } return hash \u0026amp; 0x7fffffff; } void recalc_ind(int ind, string \u0026amp;s) { int t = 1; while (flag[ind] \u0026amp;\u0026amp; data[ind] != s) { ind += t * t; t++; ind %= data.size(); } } }; 哈希表扩容效率分析\n假设 元素数量 到达 $n/2$ 时候，2倍扩容。\n历史扩容次数公式为：\n$总次数=n/2 + n/4 + n/8 + n/16+ \u0026hellip;$\n对总次数求极限\n扩容的均摊时间复杂度为 $O(N)$\n公共溢出区算法 将哈希表分为基本表和溢出表两部分，范式和基本表发生冲突的元素，一律填入溢出表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void insert(string \u0026amp;s) { int ind = hash_func(s) % data.size(); recalc_ind(ind, s); if (!flag[ind]) { data[ind] = s; flag[ind] = true; cnt += 1; if (cnt * 100 \u0026gt; data.size() * 75) { expand(); } }else { //公共溢出区算法 buff.insert(s); } } ","date":"2022-09-29T22:45:46+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C/%E5%93%88%E5%B8%8C%E8%A1%A8/","tags":["哈希"],"title":"哈希表"},{"categories":["单调栈"],"contents":" 42. 接雨水 Description Difficulty: 困难\nRelated Topics: 栈 , 数组 , 双指针 , 动态规划 , 单调栈 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n示例 1：\n1 2 3 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2：\n1 2 输入：height = [4,2,0,3,2,5] 输出：9 提示：\nn == height.length 1 \u0026lt;= n \u0026lt;= 2 * 104 0 \u0026lt;= height[i] \u0026lt;= 105 Solution Language: C++\n单调栈解法 思路： v字形结构 ，维护一个单调递减栈，遇到比栈顶高的元素就形成 v字形结构体，\n这种情况就能接住雨水。 然后把这个接住雨水的面积算出来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int trap(vector\u0026lt;int\u0026gt; \u0026amp;height) { stack\u0026lt;int\u0026gt; s; int n = height.size(); if(!n) return 0; int area = 0; for (int i = 0; i \u0026lt; n; i++) { // v 结构, 递减栈 while (!s.empty() \u0026amp;\u0026amp; height[i] \u0026gt; height[s.top()]) { int lowh = s.top(); s.pop(); if (s.empty()) break; int L = s.top(); int w = i - L - 1; int h = (min(height[i], height[L]) - height[lowh]); area += w * h; } s.push(i); } return area; } }; 解法二，记录当前元素两边的最大值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int trap(vector\u0026lt;int\u0026gt;\u0026amp; height) { int n = height.size(); // left[i]表示i左边的最大值，right[i]表示i右边的最大值 vector\u0026lt;int\u0026gt; left(n), right(n); for (int i = 1; i \u0026lt; n; i++) { left[i] = max(left[i - 1], height[i - 1]); } for (int i = n - 2; i \u0026gt;= 0; i--) { right[i] = max(right[i + 1], height[i + 1]); } int water = 0; for (int i = 0; i \u0026lt; n; i++) { int level = min(left[i], right[i]); water += max(0, level - height[i]); } return water; } }; ","date":"2022-09-29T22:34:24+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/lc.42.%E6%8E%A5%E9%9B%A8%E6%B0%B4/","tags":["单调栈"],"title":"lc.42.接雨水"},{"categories":["单调栈"],"contents":" 456. 132 模式 Description Difficulty: 中等\nRelated Topics: 栈 , 数组 , 二分查找 , 有序集合 , 单调栈 给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i \u0026lt; j \u0026lt; k 和 nums[i] \u0026lt; nums[k] \u0026lt; nums[j] 。\n如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。\n示例 1：\n1 2 3 输入：nums = [1,2,3,4] 输出：false 解释：序列中不存在 132 模式的子序列。 示例 2：\n1 2 3 输入：nums = [3,1,4,2] 输出：true 解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。 示例 3：\n1 2 3 输入：nums = [-1,3,2,0] 输出：true 解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。 提示：\nn == nums.length 1 \u0026lt;= n \u0026lt;= 2 * 105 -109 \u0026lt;= nums[i] \u0026lt;= 109 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: bool find132pattern(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // i 常数, j,k , j\u0026lt;k ,and nums[j] \u0026gt; nums[k] // nums[i] \u0026lt; nums[k], 找到 最大的满足要求 的 nums[k] stack\u0026lt;int\u0026gt; s; int n = nums.size(); if(n\u0026lt;3) return 0; int K = INT_MIN; for (int i=n-1;i\u0026gt;=0;i--) { if(nums[i] \u0026lt; K) return true; // 固定i, (i\u0026lt;j\u0026lt;k), 求 nums[j] \u0026gt; nums[k], 维护一个递减序列 while(s.size() \u0026amp;\u0026amp; nums[i] \u0026gt; nums[s.top()]) { K = nums[s.top()]; s.pop(); } s.push(i); } return false; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: bool find132pattern(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if (n\u0026lt;3) return false; if(n==3) { return nums[0] \u0026lt; nums[1] \u0026amp;\u0026amp; nums[1] \u0026gt; nums[2] \u0026amp;\u0026amp; nums[2] \u0026gt; nums[0]; } stack\u0026lt;int\u0026gt; s; vector\u0026lt;int\u0026gt; l(n); l[0] = INT_MAX; //int 的最大值 for (int i=1;i\u0026lt;n;i++) l[i] = min(l[i-1],nums[i-1]); for (int i=n-1;i\u0026gt;=0;i--) { int val = nums[i]; while(s.size() \u0026amp;\u0026amp; nums[i] \u0026gt; nums[s.top()]) { val = nums[s.top()]; s.pop(); } s.push(i); // 小于当前值的最大值 if (l[i] \u0026lt; nums[i] \u0026amp;\u0026amp; val \u0026lt; nums[i] \u0026amp;\u0026amp; val \u0026gt; l[i]) { return true; } } return false; } }; ","date":"2022-09-29T00:17:51+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/lc.456.132%E6%A8%A1%E5%BC%8F/","tags":["单调栈"],"title":"lc.456.132模式"},{"categories":["单调栈"],"contents":" 496. 下一个更大元素 I Description Difficulty: 简单\nRelated Topics: 栈 , 数组 , 哈希表 , 单调栈 nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x大的元素。\n给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。\n对于每个 0 \u0026lt;= i \u0026lt; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。\n返回一个长度为 nums1.length 的数组ans作为答案，满足ans[i]是如上所述的 下一个更大元素 。\n示例 1：\n1 2 3 4 5 6 输入：nums1 = [4,1,2], nums2 = [1,3,4,2]. 输出：[-1,3,-1] 解释：nums1 中每个值的下一个更大元素如下所述： - 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。 - 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。 - 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。 示例 2：\n1 2 3 4 5 输入：nums1 = [2,4], nums2 = [1,2,3,4]. 输出：[3,-1] 解释：nums1 中每个值的下一个更大元素如下所述： - 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。 - 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。 提示：\n1 \u0026lt;= nums1.length \u0026lt;= nums2.length \u0026lt;= 1000 0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 104 nums1和nums2中所有整数 互不相同 nums1 中的所有整数同样出现在 nums2 中 **进阶：**你可以设计一个时间复杂度为 O(nums1.length + nums2.length) 的解决方案吗？\n代码1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: vector\u0026lt;int\u0026gt; nextGreaterElement(vector\u0026lt;int\u0026gt; \u0026amp;nums1, vector\u0026lt;int\u0026gt; \u0026amp;nums2) { stack\u0026lt;int\u0026gt; s; int n = nums1.size(); int m = nums2.size(); unordered_map\u0026lt;int, int\u0026gt; idx; vector\u0026lt;int\u0026gt; res(n, -1); for (int i = 0; i \u0026lt; n; i++) { idx[nums1[i]] = i; } for (int j = 0; j \u0026lt; m; j++) { // 回溯到前面小的 while (s.size() \u0026amp;\u0026amp; nums2[j] \u0026gt; nums2[s.top()]) { // 递减 int i = s.top(); s.pop(); if (idx.count(nums2[i])) { int i0 = idx[nums2[i]]; res[i0] = nums2[j]; } } s.push(j); } return res; } }; 解题代码2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: vector\u0026lt;int\u0026gt; nextGreaterElement(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { int n = nums1.size(); unordered_map\u0026lt;int,int\u0026gt; h; stack\u0026lt;int\u0026gt; s; for (auto x: nums2) { while(s.size() \u0026amp;\u0026amp; x \u0026gt; s.top()) { h[s.top()] = x; s.pop(); } s.push(x); } vector\u0026lt;int\u0026gt; res(n,-1); for (int i=0;i\u0026lt;n;i++) { if(h.count(nums1[i])) { res[i] = h[nums1[i]]; } } return res; } }; ","date":"2022-09-28T23:47:18+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/lc.496.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0i/","tags":["单调栈"],"title":"lc.496.下一个更大元素I"},{"categories":["单调栈"],"contents":" 907. 子数组的最小值之和 Description Difficulty: 中等\nRelated Topics: 栈 , 数组 , 动态规划 , 单调栈 给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。\n由于答案可能很大，因此 返回答案模 10^9 + 7 。\n示例 1：\n1 2 3 4 5 输入：arr = [3,1,2,4] 输出：17 解释： 子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。 示例 2：\n1 2 输入：arr = [11,81,94,43,3] 输出：444 提示：\n1 \u0026lt;= arr.length \u0026lt;= 3 * 104 1 \u0026lt;= arr[i] \u0026lt;= 3 * 104 解题思路 原型参考 柱状图的最大矩形，leetcode 84题\n可以理解为短板原理，一个木桶因为一个短板，容量以最短的短板决定。\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int sumSubarrayMins(vector\u0026lt;int\u0026gt;\u0026amp; arr) { int n = arr.size(); vector\u0026lt;int\u0026gt; left(n, -1), right(n, n); stack\u0026lt;int\u0026gt; stk; int mod = 1E9 + 7; for(int i = 0; i \u0026lt; n; i++){ while(!stk.empty() \u0026amp;\u0026amp; arr[stk.top()] \u0026gt; arr[i]){ right[stk.top()] = i; stk.pop(); } if(!stk.empty()){ left[i] = stk.top(); } stk.push(i); } int res = 0; for(int i = 0; i \u0026lt; n; i++){ res = (res + (long long)(i - left[i]) * (right[i] - i) * arr[i]) % mod; } return res; } }; ","date":"2022-09-28T22:33:50+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/lc.907.%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C./","tags":["单调栈"],"title":"lc.907.子数组的最小值之和."},{"categories":["单调栈"],"contents":" 1856. 子数组最小乘积的最大值 Description Difficulty: 中等\nRelated Topics: 栈 , 数组 , 前缀和 , 单调栈 一个数组的 最小乘积 定义为这个数组中 最小值 乘以数组的 和 。\n比方说，数组 [3,2,5] （最小值是 2）的最小乘积为 2 * (3+2+5) = 2 * 10 = 20 。 给你一个正整数数组 nums ，请你返回 nums 任意 非空子数组 的最小乘积 的 最大值 。由于答案可能很大，请你返回答案对 109 + 7 取余的结果。\n请注意，最小乘积的最大值考虑的是取余操作 之前 的结果。题目保证最小乘积的最大值在 不取余 的情况下可以用 64 位有符号整数 保存。\n子数组 定义为一个数组的 连续 部分。\n示例 1：\n1 2 3 4 输入：nums = [1,2,3,2] 输出：14 解释：最小乘积的最大值由子数组 [2,3,2] （最小值是 2）得到。 2 * (2+3+2) = 2 * 7 = 14 。 示例 2：\n1 2 3 4 输入：nums = [2,3,3,1,2] 输出：18 解释：最小乘积的最大值由子数组 [3,3] （最小值是 3）得到。 3 * (3+3) = 3 * 6 = 18 。 示例 3：\n1 2 3 4 输入：nums = [3,1,5,6,4,2] 输出：60 解释：最小乘积的最大值由子数组 [5,6,4] （最小值是 4）得到。 4 * (5+6+4) = 4 * 15 = 60 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= nums[i] \u0026lt;= 107 解题思路 [[lc.84.柱状图最大矩形]]\n柱状图的最大矩形\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 typedef long long LL; class Solution { public: int maxSumMinProduct(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if (!n) return 0; vector\u0026lt;int \u0026gt; l(n),r(n); for (int i=0;i\u0026lt;n;i++) { l[i] = -1, r[i] = n; } stack\u0026lt;int\u0026gt; s; for (int i=0;i\u0026lt;n;i++) { while(s.size() \u0026amp;\u0026amp; nums[s.top()] \u0026gt;= nums[i]) { r[s.top()] = i; s.pop(); } if(s.size()) l[i] = s.top(); s.push(i); } vector\u0026lt;LL\u0026gt;sum(n+1); for (int i=0;i\u0026lt;n;i++) sum[i+1] = sum[i]+nums[i]; LL ans = 0; LL mod = (1e9+7); for (int i=0;i\u0026lt;n;i++) { ans = max(ans, nums[i] * (sum[r[i]] - sum[l[i]+1] ) ); } return ans % mod; } }; ","date":"2022-09-28T21:47:47+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/lc.1856.%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E4%B9%98%E7%A7%AF%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","tags":["单调栈"],"title":"lc.1856.子数组最小乘积的最大值"},{"categories":["单调栈"],"contents":" 84. 柱状图中最大的矩形 Description Difficulty: 困难\nRelated Topics: 栈 , 数组 , 单调栈 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n示例 1:\n1 2 3 输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 示例 2：\n1 2 输入： heights = [2,4] 输出： 4 提示：\n1 \u0026lt;= heights.length \u0026lt;=105 0 \u0026lt;= heights[i] \u0026lt;= 104 Solution Language: C++\n解题思路 找两边第一个小于它的值\n暴力解法 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution: def largestRectangleArea(self, heights: List[int]) -\u0026gt; int: res = 0 n = len(heights) for i in range(n): left_i = i right_i = i while left_i \u0026gt;= 0 and heights[left_i] \u0026gt;= heights[i]: left_i -= 1 while right_i \u0026lt; n and heights[right_i] \u0026gt;= heights[i]: right_i += 1 res = max(res, (right_i - left_i - 1) * heights[i]) return res 时间复杂度为 $O(N ^2)$\n单调栈解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int largestRectangleArea(vector\u0026lt;int\u0026gt;\u0026amp; heights) { stack\u0026lt;int\u0026gt; s; // 前面第一个比 i 小 和后面第一个比 i小的，围成的面积中的最大值就是答案 int n = heights.size(); int res = -1; vector\u0026lt;int\u0026gt; l(n,-1),r(n,n); for (int i=0;i\u0026lt;n;i++) { while(s.size() \u0026amp;\u0026amp; heights[i] \u0026lt;= heights[s.top()]) { //单调递增栈 r[s.top()] = i; // 非严格单调递增 s.pop(); } if(s.size()) l[i] = s.top(); s.push(i); } for(int i=0;i\u0026lt;n;i++) { res = max(res, (r[i] - l[i] - 1) * heights[i] ); } return res; } }; ","date":"2022-09-27T21:57:18+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/lc.84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/","tags":["单调栈"],"title":"lc.84.柱状图最大矩形"},{"categories":["单调栈"],"contents":" 739. 每日温度 Description Difficulty: 中等\nRelated Topics: 栈 , 数组 , 单调栈 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n示例 1:\n1 2 输入: temperatures = [73,74,75,71,69,72,76,73] 输出: [1,1,4,2,1,1,0,0] 示例 2:\n1 2 输入: temperatures = [30,40,50,60] 输出: [1,1,1,0] 示例 3:\n1 2 输入: temperatures = [30,60,90] 输出: [1,1,0] 提示：\n1 \u0026lt;= temperatures.length \u0026lt;= 105 30 \u0026lt;= temperatures[i] \u0026lt;= 100 Solution Language: C++\n解题思路 遇到一个元素就把元素压入栈， 直到栈里面找到了比他大的元素，就弹出来\n单调栈相当于备忘录\n单调栈解法代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: vector\u0026lt;int\u0026gt; dailyTemperatures(vector\u0026lt;int\u0026gt;\u0026amp; temperatures) { // 自动回溯？ int n = temperatures.size(); stack\u0026lt;int\u0026gt; s; vector\u0026lt;int\u0026gt; res(n,0); for (int i = 0; i \u0026lt; n; i++) { while (!s.empty() \u0026amp;\u0026amp; temperatures[i] \u0026gt; temperatures[s.top()]) { int pre = s.top(); s.pop(); int lenx = i - pre; res[pre] = lenx; } s.push(i); } return res; } }; ","date":"2022-09-27T20:27:16+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/%E8%AE%A1%E6%95%B0/lc.739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/","tags":["单调栈"],"title":"lc.739.每日温度"},{"categories":["单调栈"],"contents":" 901. 股票价格跨度 Description Difficulty: 中等\nRelated Topics: 栈 , 设计 , 数据流 , 单调栈 编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。\n今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。\n例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 输入：[\u0026#34;StockSpanner\u0026#34;,\u0026#34;next\u0026#34;,\u0026#34;next\u0026#34;,\u0026#34;next\u0026#34;,\u0026#34;next\u0026#34;,\u0026#34;next\u0026#34;,\u0026#34;next\u0026#34;,\u0026#34;next\u0026#34;], [[],[100],[80],[60],[70],[60],[75],[85]] 输出：[null,1,1,1,2,1,4,6] 解释： 首先，初始化 S = StockSpanner()，然后： S.next(100) 被调用并返回 1， S.next(80) 被调用并返回 1， S.next(60) 被调用并返回 1， S.next(70) 被调用并返回 2， S.next(60) 被调用并返回 1， S.next(75) 被调用并返回 4， S.next(85) 被调用并返回 6。 注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格 (包括今天的价格 75) 小于或等于今天的价格。 提示：\n调用 StockSpanner.next(int price) 时，将有 1 \u0026lt;= price \u0026lt;= 10^5。 每个测试用例最多可以调用 10000 次 StockSpanner.next。 在所有测试用例中，最多调用 150000 次 StockSpanner.next。 此问题的总时间限制减少了 50%。 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class StockSpanner { public: #define PII pair\u0026lt;int,int\u0026gt; StockSpanner() { s.push(PII(INT_MAX,id++));// 时间戳 } int id; stack\u0026lt;PII\u0026gt; s; int next(int price) { // s.push(price); int cnt = 0; while(s.size() \u0026amp;\u0026amp; s.top().first \u0026lt;= price) { s.pop(); } cnt += (id - s.top().second); // \u0026lt;= 的数量 s.push({price,id++}); return cnt; } }; /** * Your StockSpanner object will be instantiated and called as such: * StockSpanner* obj = new StockSpanner(); * int param_1 = obj-\u0026gt;next(price); */ ","date":"2022-09-26T22:27:56+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/lc.901.%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6/","tags":["单调栈"],"title":"lc.901.股票价格跨度"},{"categories":["单调栈"],"contents":" 503. 下一个更大元素 II Description Difficulty: 中等\nRelated Topics: 栈 , 数组 , 单调栈 给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。\n数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。\n示例 1:\n1 2 3 4 5 输入: nums = [1,2,1] 输出: [2,-1,2] 解释: 第一个 1 的下一个更大的数是 2； 数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 示例 2:\n1 2 输入: nums = [1,2,3,4,3] 输出: [2,3,4,-1,4] 提示:\n1 \u0026lt;= nums.length \u0026lt;= 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 Solution Language: C++\n循环数组，直接用 mod 运算即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: vector\u0026lt;int\u0026gt; nextGreaterElements(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if(!n) return {}; // vector\u0026lt;int\u0026gt; nums(n*2); // for (int i=0;i\u0026lt;n;i++) { // nums[i] = nums_[i]; // } // for (int i=0;i\u0026lt;n;i++) { // nums[i+n] = nums_[i]; // } // todo: // 1 2 1 // [1 2 1 1 2] 1 stack\u0026lt;int\u0026gt; s; vector\u0026lt;int\u0026gt; res(n,-1); for (int i = 0; i \u0026lt; 2 * n - 1; i++) { while(s.size() \u0026amp;\u0026amp; nums[remap(s.top(),n)] \u0026lt; nums[remap(i,n)]) { int j = s.top(); s.pop(); res[remap(j,n)] = nums[remap(i,n)]; } s.push(i); } return res; } int remap(int i,int n) { return i % n; // if (i \u0026gt;= n) { // return i-n; // } // return i; } }; 思路 单调栈解法： 环形数组相当于执行两次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: vector\u0026lt;int\u0026gt; nextGreaterElements(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); stack\u0026lt;int\u0026gt; s; vector\u0026lt;int\u0026gt; ret(n,-1); for (int i=0;i\u0026lt;n;i++) { while(s.size() \u0026amp;\u0026amp; nums[i] \u0026gt; nums[s.top()]) { //利用单调栈找到适合的男神 ret[s.top()] = nums[i];// 匹配 s.pop(); } s.push(i); } //循环数组可以直接复制两边 for (int i=0;i\u0026lt;n;i++) { while(s.size() \u0026amp;\u0026amp; nums[i] \u0026gt; nums[s.top()]) { ret[s.top()] = nums[i]; s.pop(); } s.push(i); } // while(s.size()) ret[s.top()] = -1,s.pop(); return ret; } }; ","date":"2022-09-26T21:56:18+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/lc.503.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0ii/","tags":["单调栈"],"title":"lc.503.下一个更大元素II"},{"categories":["单调栈"],"contents":" 155. 最小栈 Description Difficulty: 中等\nRelated Topics: 栈 , 设计 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\n实现 MinStack 类:\nMinStack() 初始化堆栈对象。 void push(int val) 将元素val推入堆栈。 void pop() 删除堆栈顶部的元素。 int top() 获取堆栈顶部的元素。 int getMin() 获取堆栈中的最小元素。 示例 1:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 输入： [\u0026#34;MinStack\u0026#34;,\u0026#34;push\u0026#34;,\u0026#34;push\u0026#34;,\u0026#34;push\u0026#34;,\u0026#34;getMin\u0026#34;,\u0026#34;pop\u0026#34;,\u0026#34;top\u0026#34;,\u0026#34;getMin\u0026#34;] [[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --\u0026gt; 返回 -3. minStack.pop(); minStack.top(); --\u0026gt; 返回 0. minStack.getMin(); --\u0026gt; 返回 -2. 提示：\n-231 \u0026lt;= val \u0026lt;= 231 - 1 pop、top 和 getMin 操作总是在 非空栈 上调用 push, pop, top, and getMin最多被调用 3 * 104 次 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class MinStack { public: MinStack() { } stack\u0026lt;int\u0026gt; s,mins; void push(int val) { s.push(val); if(mins.size() == 0 || mins.top() \u0026gt;= val) mins.push(val); } void pop() { int u = s.top();s.pop(); if(mins.top() == u) mins.pop(); } int top() { return s.top(); } int getMin() { return mins.top(); } }; /** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-\u0026gt;push(val); * obj-\u0026gt;pop(); * int param_3 = obj-\u0026gt;top(); * int param_4 = obj-\u0026gt;getMin(); */ /** ","date":"2022-09-26T21:20:31+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/%E6%9C%80%E5%B0%8F%E6%A0%88/","tags":["单调栈"],"title":"最小栈"},{"categories":["vim操作记录"],"contents":"vim 其他需要了解的用法 text Object 高效编辑 word w iw ,inner word aw , arround word paragraph ip,inner paragraph is ,inner sentence vim sourround 插件 快速单引号改双引号 或者 括号等操作\nysiw + 符号， 单词添加上 对应符号 cs +符号1+ 符号2， 符号1变符号2 1 app.config.use(\u0026#39;helloworld\u0026#39;) 搜索单词 * ,当前光标的下一个单词 #, 匹配当前光标单词的前一个单词 快速跳转命令 ]] 跳转函数结尾 [[ 跳到函数开头 文本块移动：\n(： 移到当前句子的开头\n): 移到下一个句子的开头\n{: 移到当前一段的开头\n}: 移到下一段的开头\n[[: 移到当前这一节的开头\n]]: 移到下一节的开头\nx%: 按照百分比跳转，比如 跳转到文件 百分之50 的地方就 50%\n半屏滚动: ctrl+u/ctrl+d\n全屏滚动: ctrl+f/ctrl+b\n定位光标的位置\nzz: 将光标置于屏幕的中间\nzt: 将光标移动到屏幕的顶部\nzb: 将光标移动到屏幕的底部\ncw: 删除从光标处到单词结尾的文本并进入到插入模式\ncb: 删除从光标处到单词开头的文本并进入到插入模式\ncc: 删除一整行并进入到插入模式\n~： 修改光标下字符的大小写\nr: 替换当前光标下的字符\nR: 进入到替换模式\nxp: 交换光标和下一个字符\n切换大小写 常用：\n~: 可以选中单词，直接按 ~ 就可以切换大小写了 guu ,gUU ,分别是小写和大写，上面的方法比较通用，可以只记录上面的 vscode 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 { \u0026#34;before\u0026#34;: [ \u0026#34;+\u0026#34;,\u0026#34;p\u0026#34; ], \u0026#34;after\u0026#34;: [ \u0026#34;\\\u0026#34;\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;p\u0026#34; ] //粘贴剪切板 }, { \u0026#34;before\u0026#34;: [ \u0026#34;d\u0026#34;, \u0026#34;f\u0026#34; ], \u0026#34;after\u0026#34;: [ \u0026#34;\u0026lt;ESC\u0026gt;\u0026#34; ] }, { // afa \u0026#34;before\u0026#34;: [ \u0026#34;y\u0026#34;, \u0026#34;b\u0026#34; ], \u0026#34;after\u0026#34;: [ \u0026#34;y\u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;w\u0026#34;, \u0026#34;(\u0026#34; ] }, { // \u0026#34;( afa )\u0026#34; \u0026#34;before\u0026#34;: [ \u0026#34;y\u0026#34;, \u0026#34;)\u0026#34; ], \u0026#34;after\u0026#34;: [ \u0026#34;y\u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;p\u0026#34;, \u0026#34;(\u0026#34; ] }, { // \u0026#34;( afa )\u0026#34; \u0026#34;before\u0026#34;: [ \u0026#34;y\u0026#34;, \u0026#34;(\u0026#34; ], \u0026#34;after\u0026#34;: [ \u0026#34;y\u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;w\u0026#34;, \u0026#34;(\u0026#34; ] }, { // \u0026#34;[ afa ]\u0026#34; \u0026#34;before\u0026#34;: [ \u0026#34;y\u0026#34;, \u0026#34;[\u0026#34; ], \u0026#34;after\u0026#34;: [ \u0026#34;y\u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;w\u0026#34;, \u0026#34;[\u0026#34; ] }, { // \u0026#34;[ afa ]\u0026#34; \u0026#34;before\u0026#34;: [ \u0026#34;y\u0026#34;, \u0026#34;]\u0026#34; ], \u0026#34;after\u0026#34;: [ \u0026#34;y\u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;p\u0026#34;, \u0026#34;[\u0026#34; ] }, { // \u0026#34;*afa*\u0026#34; \u0026#34;before\u0026#34;: [ \u0026#34;y\u0026#34;, \u0026#34;*\u0026#34; ], \u0026#34;after\u0026#34;: [ \u0026#34;y\u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;w\u0026#34;, \u0026#34;*\u0026#34; ] }, { // \u0026#34;afa\u0026#34; \u0026#34;before\u0026#34;: [ \u0026#34;y\u0026#34;, \u0026#34;\\\u0026#34;\u0026#34; ], \u0026#34;after\u0026#34;: [ \u0026#34;y\u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;w\u0026#34;, \u0026#34;\\\u0026#34;\u0026#34; ] }, ","date":"2022-09-25T22:27:08+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/vim%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/vim%E5%85%B6%E4%BB%96%E7%94%A8%E6%B3%95/","tags":["vim操作记录"],"title":"vim其他用法"},{"categories":["枚举"],"contents":" 43. 字符串相乘 Description Difficulty: 中等\nRelated Topics: 数学 , 字符串 , 模拟 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。\n**注意：**不能使用任何内置的 BigInteger 库或直接将输入转换为整数。\n示例 1:\n1 2 输入: num1 = \u0026#34;2\u0026#34;, num2 = \u0026#34;3\u0026#34; 输出: \u0026#34;6\u0026#34; 示例 2:\n1 2 输入: num1 = \u0026#34;123\u0026#34;, num2 = \u0026#34;456\u0026#34; 输出: \u0026#34;56088\u0026#34; 提示：\n1 \u0026lt;= num1.length, num2.length \u0026lt;= 200 num1 和 num2 只能由数字组成。 num1 和 num2 都不包含任何前导零，除了数字0本身。 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: string multiply(string num1, string num2) { int size_1 = num1.size(),size_2 = num2.size(); string res(size_2+size_1,\u0026#39;0\u0026#39;); for (int i=size_1-1;i\u0026gt;=0;--i) { for (int j = size_2 -1; j\u0026gt;=0;--j) { int _t = res[i+j+1]-\u0026#39;0\u0026#39; + (num2[j]-\u0026#39;0\u0026#39;) * (num1[i]-\u0026#39;0\u0026#39;); //当前位置 + 进位 res[i+j+1] = _t%10 + \u0026#39;0\u0026#39;; res[i+j] += _t/10; } } for (int i=0,n=res.size(); i\u0026lt;n;++i) { if (res[i]!=\u0026#39;0\u0026#39;) return res.substr(i); } return {\u0026#39;0\u0026#39;}; } }; ","date":"2022-09-25T15:16:35+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%9E%9A%E4%B8%BE/lc.43.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/","tags":["枚举"],"title":"lc.43.字符串相乘"},{"categories":["枚举"],"contents":" 93. 复原 IP 地址 Description Difficulty: 中等\nRelated Topics: 字符串 , 回溯 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。\n例如：\u0026quot;0.1.2.201\u0026quot; 和 \u0026quot;192.168.1.1\u0026quot; 是 有效 IP 地址，但是 \u0026quot;0.011.255.245\u0026quot;、\u0026quot;192.168.1.312\u0026quot; 和 \u0026quot;192.168@1.1\u0026quot; 是 无效 IP 地址。 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。\n示例 1：\n1 2 输入：s = \u0026#34;25525511135\u0026#34; 输出：[\u0026#34;255.255.11.135\u0026#34;,\u0026#34;255.255.111.35\u0026#34;] 示例 2：\n1 2 输入：s = \u0026#34;0000\u0026#34; 输出：[\u0026#34;0.0.0.0\u0026#34;] 示例 3：\n1 2 输入：s = \u0026#34;101023\u0026#34; 输出：[\u0026#34;1.0.10.23\u0026#34;,\u0026#34;1.0.102.3\u0026#34;,\u0026#34;10.1.0.23\u0026#34;,\u0026#34;10.10.2.3\u0026#34;,\u0026#34;101.0.2.3\u0026#34;] 提示：\n1 \u0026lt;= s.length \u0026lt;= 20 s 仅由数字组成 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: vector\u0026lt;string\u0026gt; restoreIpAddresses(string s) { if(s.size()\u0026lt;4) return {}; vector\u0026lt;string\u0026gt; res; dfs(res,0,0,s,\u0026#34;\u0026#34;); return res; } //IPV4 地址 void dfs(vector\u0026lt;string\u0026gt; \u0026amp;res,int pos,int cnt,string \u0026amp;str,string path) { if(pos==str.size() \u0026amp;\u0026amp; cnt==4) { path.pop_back(); res.push_back(path); } if(cnt\u0026gt;=4) return ; int cur=0; for(int i=pos;i\u0026lt;str.size();++i) { //判断前导0 if(i\u0026gt;pos \u0026amp;\u0026amp; str[pos] ==\u0026#39;0\u0026#39;) break; cur = cur*10 + str[i]-\u0026#39;0\u0026#39;; if(cur\u0026gt;=0 \u0026amp;\u0026amp; cur\u0026lt;=255) { dfs(res,i+1,cnt+1,str, path+ to_string(cur)+\u0026#34;.\u0026#34;); }else { break; } //如果超过 250 了，剪枝 } } }; ","date":"2022-09-25T15:12:53+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%9E%9A%E4%B8%BE/lc.96.%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80/","tags":["枚举"],"title":"lc.96.复原ip地址"},{"categories":["贪心"],"contents":" 45. 跳跃游戏 II Description Difficulty: 中等\nRelated Topics: 贪心 , 数组 , 动态规划 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n你的目标是使用最少的跳跃次数到达数组的最后一个位置。\n假设你总是可以到达数组的最后一个位置。\n示例 1:\n1 2 3 4 输入: nums = [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 示例 2:\n1 2 输入: nums = [2,3,0,1,4] 输出: 2 提示:\n1 \u0026lt;= nums.length \u0026lt;= 104 0 \u0026lt;= nums[i] \u0026lt;= 1000 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int jump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if(n\u0026lt;=1) return 0; int min_step = 0; int lastPos = nums[0]; int pos = 0; for (int i=0;i\u0026lt;n;i++) { if (nums[i] + i \u0026gt; lastPos) { lastPos = nums[i] + i; } if (lastPos \u0026gt;= n-1) return min_step+1; if (pos == i) { pos = lastPos; min_step++; } } return min_step; } }; ","date":"2022-09-25T14:06:21+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/%E8%B4%AA%E5%BF%83/lc.45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/","tags":["贪心"],"title":"lc.45.跳跃游戏"},{"categories":["二分"],"contents":" 1760. 袋子里最少数目的球 Description Difficulty: 中等\nRelated Topics: 数组 , 二分查找 给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。\n你可以进行如下操作至多 maxOperations 次：\n选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。 比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。 你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。\n请你返回进行上述操作后的最小开销。\n示例 1：\n1 2 3 4 5 6 输入：nums = [9], maxOperations = 2 输出：3 解释： - 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -\u0026gt; [6,3] 。 - 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -\u0026gt; [3,3,3] 。 装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。 示例 2：\n1 2 3 4 5 6 7 8 输入：nums = [2,4,8,2], maxOperations = 4 输出：2 解释： - 将装有 8 个球的袋子分成装有 4 个和 4 个球的袋子。[2,4,8,2] -\u0026gt; [2,4,4,4,2] 。 - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,4,4,4,2] -\u0026gt; [2,2,2,4,4,2] 。 - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,4,4,2] -\u0026gt; [2,2,2,2,2,4,2] 。 - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,2,2,4,2] -\u0026gt; [2,2,2,2,2,2,2,2] 。 装有最多球的袋子里装有 2 个球，所以开销为 2 并返回 2 。 示例 3：\n1 2 输入：nums = [7,17], maxOperations = 2 输出：7 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= maxOperations, nums[i] \u0026lt;= 109 Solution Language: C++\n二分解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int minimumSize(vector\u0026lt;int\u0026gt;\u0026amp; nums, int maxOperations) { //尽可能平分，才能让球变小 return binarySolve(nums,maxOperations); } int binarySolve(vector\u0026lt;int\u0026gt; \u0026amp;nums,int k) { int l=1,r=0; for (int x:nums) r = max(r,x); while(l\u0026lt;r) { int mid = l+ (r-l)/2; if (f(nums,mid) \u0026lt;= k) r = mid; else l = mid+1; } return l; } int f(vector\u0026lt;int\u0026gt; \u0026amp;nums,int k) { int cnt = 0; int n = nums.size(); for(int i=0;i\u0026lt;n;i++) { cnt += (nums[i] / k); if (nums[i] % k == 0) cnt--; } return cnt; } }; ","date":"2022-09-25T13:44:03+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/lc.1760.%E8%A2%8B%E5%AD%90%E9%87%8C%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E7%90%83/","tags":["二分"],"title":"lc.1760.袋子里最少数目的球"},{"categories":["单调队列"],"contents":" 365. 水壶问题 Description Difficulty: 中等\nRelated Topics: 深度优先搜索 , 广度优先搜索 , 数学 有两个水壶，容量分别为 jug1Capacity 和 jug2Capacity 升。水的供应是无限的。确定是否有可能使用这两个壶准确得到 targetCapacity 升。\n如果可以得到 targetCapacity 升水，最后请用以上水壶中的一或两个来盛放取得的 targetCapacity 升水。\n你可以：\n装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空 示例 1:\n1 2 3 输入: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4 输出: true 解释：来自著名的 \u0026#34;Die Hard\u0026#34; 示例 2:\n1 2 输入: jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5 输出: false 示例 3:\n1 2 输入: jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3 输出: true 提示:\n1 \u0026lt;= jug1Capacity, jug2Capacity, targetCapacity \u0026lt;= 106 Solution Language: C++\n广度优先算法解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public: bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) { //准确得到 targetCapacity ,不是大于或者等于 unordered_set\u0026lt;PII,HASH\u0026gt; repeat_set; queue\u0026lt;PII\u0026gt; q; repeat_set.insert({0,0}); q.push({0,0}); while(q.size()) { PII cur = q.front();q.pop(); if (cur.first + cur.second == targetCapacity) return true; for (int i=0;i\u0026lt;6;i++) { PII temp = getnext(i,cur.first,cur.second,jug1Capacity,jug2Capacity); if (repeat_set.count(temp)) continue; if (temp.first + temp.second == targetCapacity) return true; q.push(temp); repeat_set.insert(temp); } } return false; } typedef pair\u0026lt;int,int\u0026gt; PII; struct HASH { long long operator() (const PII \u0026amp;a) const { return ((long long)(a.first)\u0026lt;\u0026lt;31)+a.second; } }; PII getnext(int k,int x,int y,int X,int Y) { switch (k) { case 0: return PII(0,y); case 1: return PII(x,0); case 2: { //向另一个水倒满 //x-\u0026gt;y int delta = min(x,Y-y); return PII(x-delta,y+delta); } case 3: { int delta = min(X-x,y); return PII(x+delta,y-delta); } case 4: return PII(X,y); case 5: return PII(x,Y); } return PII(0,0); //清空 } }; 辗转相除法 整个倒水的过程，其实就是辗转相除的过程\n两个整数的最大公约数主要有两种寻找方法：\n两数各分解质因子，然后取出同样有的项乘起来 辗转相除法（扩展版）\n和最小公倍数（lcm）的关系：gcd(a, b)×lcm(a, b) = ab\n两个整数的最大公因子可用于计算两数的最小公倍数，或分数化简成最简分数。\n两个整数的最大公因子和最小公倍数中存在分配律： gcd(a, lcm(b, c)) = lcm(gcd(a, b), gcd(a, c)) lcm(a, gcd(b, c)) = gcd(lcm(a, b), lcm(a, c)) 假设要用辗转相除法求 36 和 24 的最大公约数，则要经历以下步骤：\n1 2 3 36 ÷ 24 = 1 …… 12 24 ÷ 12 = 2 …… 0 12 为 36 和 24 的最大公约数 更相减损法出自《九章算术》，其原理其实与辗转相除法一样，只是辗转相除法将的是相除取余，而更相减损法讲的是相减取差。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) { //准确得到 targetCapacity ,不是大于或者等于 if(jug1Capacity + jug2Capacity \u0026lt; targetCapacity) return false; if (jug1Capacity == 0) return jug2Capacity == targetCapacity; if (jug1Capacity \u0026lt; jug2Capacity) swap(jug1Capacity,jug2Capacity); int u = gcd(jug1Capacity,jug2Capacity); //最大公约数 return targetCapacity % u == 0; } int gcd(int a,int b) { if(b==0) return a; return gcd(b,a%b); } }; ","date":"2022-09-25T01:00:54+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/lc.365.%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/","tags":["单调队列"],"title":"lc.365.水壶问题"},{"categories":["单调队列"],"contents":" 135. 分发糖果 Description Difficulty: 困难\nRelated Topics: 贪心 , 数组 n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。\n你需要按照以下要求，给这些孩子分发糖果：\n每个孩子至少分配到 1 个糖果。 相邻两个孩子评分更高的孩子会获得更多的糖果。 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。\n示例 1：\n1 2 3 输入：ratings = [1,0,2] 输出：5 解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。 示例 2：\n1 2 3 4 输入：ratings = [1,2,2] 输出：4 解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。 提示：\nn == ratings.length 1 \u0026lt;= n \u0026lt;= 2 * 104 0 \u0026lt;= ratings[i] \u0026lt;= 2 * 104 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int candy(vector\u0026lt;int\u0026gt;\u0026amp; ratings) { int n = ratings.size(); vector\u0026lt;int\u0026gt; l(n,1); vector\u0026lt;int\u0026gt; r(n,1); for (int i=0,j=1;i\u0026lt;n;i++) { if(i \u0026amp;\u0026amp; ratings[i] \u0026gt; ratings[i-1]) j+=1; else { j=1; } l[i] = j; } for (int i=n-1,j=1;i\u0026gt;=0;i--) { if(i\u0026lt;n-1 \u0026amp;\u0026amp; ratings[i] \u0026gt; ratings[i+1]) j+=1; else j=1; r[i] = j; } int ans=0; for (int i=0;i\u0026lt;n;i++) { ans += max(l[i],r[i]); } return ans; } }; ","date":"2022-09-24T23:39:54+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/lc.135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/","tags":["单调队列"],"title":"lc.135.分发糖果"},{"categories":["单调队列"],"contents":" 1438. 绝对差不超过限制的最长连续子数组 Description Difficulty: 中等\nRelated Topics: 队列 , 数组 , 有序集合 , 滑动窗口 , 单调队列 , 堆（优先队列） 给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。\n如果不存在满足条件的子数组，则返回 0 。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 输入：nums = [8,2,4,7], limit = 4 输出：2 解释：所有子数组如下： [8] 最大绝对差 |8-8| = 0 \u0026lt;= 4. [8,2] 最大绝对差 |8-2| = 6 \u0026gt; 4\\. [8,2,4] 最大绝对差 |8-2| = 6 \u0026gt; 4. [8,2,4,7] 最大绝对差 |8-2| = 6 \u0026gt; 4. [2] 最大绝对差 |2-2| = 0 \u0026lt;= 4. [2,4] 最大绝对差 |2-4| = 2 \u0026lt;= 4. [2,4,7] 最大绝对差 |2-7| = 5 \u0026gt; 4. [4] 最大绝对差 |4-4| = 0 \u0026lt;= 4. [4,7] 最大绝对差 |4-7| = 3 \u0026lt;= 4. [7] 最大绝对差 |7-7| = 0 \u0026lt;= 4\\. 因此，满足题意的最长子数组的长度为 2 。 示例 2：\n1 2 3 输入：nums = [10,1,2,4,7,2], limit = 5 输出：4 解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 \u0026lt;= 5 。 示例 3：\n1 2 输入：nums = [4,2,2,2,4,4,2,2], limit = 0 输出：3 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^9 0 \u0026lt;= limit \u0026lt;= 10^9 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public: int longestSubarray(vector\u0026lt;int\u0026gt;\u0026amp; nums, int limit) { return binarySolve(nums,limit); } //二分长度 int binarySolve(vector\u0026lt;int\u0026gt; \u0026amp;nums,int limit) { int l=1,r = nums.size(); // 二分长度，长度 属于 [1,N] while(l\u0026lt;r) { int mid = (l+r+1)/2; if (check(nums,mid,limit)) { l = mid;//满足条件 }else { r = mid -1 ; } } return r; } bool check(vector\u0026lt;int\u0026gt; \u0026amp;nums,int k,int limit) { deque\u0026lt;int\u0026gt; asc,desc; int n = nums.size(); for (int i=0;i\u0026lt;n;i++) { while(asc.size() \u0026amp;\u0026amp; nums[asc.back()] \u0026lt; nums[i]) asc.pop_back(); while(desc.size() \u0026amp;\u0026amp; nums[desc.back()] \u0026gt; nums[i]) desc.pop_back(); asc.push_back(i); desc.push_back(i); if(i - asc.front() \u0026gt;= k) asc.pop_front(); if (i - desc.front() \u0026gt;= k) desc.pop_front(); // solve if (i\u0026gt;=k-1) { // 计算子数组长度 if (abs(nums[desc.front()] - nums[asc.front()]) \u0026lt;= limit) { return true; } // \u0026gt;= limit } } return false; } }; ","date":"2022-09-24T23:25:27+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/lc.1438.%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/","tags":["单调队列"],"title":"lc.1438.绝对值不超过限制的最长连续子数组"},{"categories":["单调队列"],"contents":" 862. 和至少为 K 的最短子数组 Description Difficulty: 困难\nRelated Topics: 队列 , 数组 , 二分查找 , 前缀和 , 滑动窗口 , 单调队列 , 堆（优先队列） 给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。\n子数组 是数组中 连续 的一部分。\n示例 1：\n1 2 输入：nums = [1], k = 1 输出：1 示例 2：\n1 2 输入：nums = [1,2], k = 4 输出：-1 示例 3：\n1 2 输入：nums = [2,-1,2], k = 3 输出：3 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 -105 \u0026lt;= nums[i] \u0026lt;= 105 1 \u0026lt;= k \u0026lt;= 109 Solution Language: C++\n单调队列解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int shortestSubarray(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); deque\u0026lt;int\u0026gt; q; vector\u0026lt;long long \u0026gt; sum(n+1); for (int i=1;i\u0026lt;=n;i++) sum[i] = sum[i-1] + nums[i-1]; int ans = INT_MAX; for (int i=0;i\u0026lt;=n;i++) { while(q.size() \u0026amp;\u0026amp; sum[q.back()] \u0026gt;= sum[i]) { q.pop_back(); } while(q.size() \u0026amp;\u0026amp; sum[i] - sum[q.front()] \u0026gt;= k) { ans = min(ans, i - q.front()); // 作差\u0026gt;=k q.pop_front(); } q.push_back(i); } return ans == INT_MAX? -1: ans; } }; 其他解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int shortestSubarray(int[] A, int K) { int minLen = A.length + 1; int[] preSum = new int[A.length + 1]; preSum[0] = 0; for (int i = 0; i \u0026lt; A.length; i++) { preSum[i + 1] = preSum[i] + A[i]; } for (int i = 0; i \u0026lt; A.length; i++) { for (int j = i + 1; j \u0026lt; A.length + 1; j++) { if ((preSum[j] - preSum[i]) \u0026gt;= K) { if ((j - i) \u0026lt; minLen) { minLen = j - i; } } } } return minLen == A.length + 1 ? -1 : minLen; } } ","date":"2022-09-24T21:50:23+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/lc.862.%E5%92%8C%E6%9C%80%E5%B0%91%E4%B8%BAk%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/","tags":["单调队列"],"title":"lc.862.和最少为k的最短子数组"},{"categories":["单调队列"],"contents":" 面试题59 - II. 队列的最大值 Description Difficulty: 中等\nRelated Topics: 设计 , 队列 , 单调队列 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。\n若队列为空，pop_front 和 max_value 需要返回 -1\n示例 1：\n1 2 3 4 输入: [\u0026#34;MaxQueue\u0026#34;,\u0026#34;push_back\u0026#34;,\u0026#34;push_back\u0026#34;,\u0026#34;max_value\u0026#34;,\u0026#34;pop_front\u0026#34;,\u0026#34;max_value\u0026#34;] [[],[1],[2],[],[],[]] 输出: [null,null,null,2,1,2] 示例 2：\n1 2 3 4 输入: [\u0026#34;MaxQueue\u0026#34;,\u0026#34;pop_front\u0026#34;,\u0026#34;max_value\u0026#34;] [[],[],[]] 输出: [null,-1,-1] 限制：\n1 \u0026lt;= push_back,pop_front,max_value的总操作数 \u0026lt;= 10000 1 \u0026lt;= value \u0026lt;= 10^5 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class MaxQueue { public: deque\u0026lt;int\u0026gt; q,mq; MaxQueue() {} int max_value() { if(mq.size()==0) return -1; return mq.front(); } void push_back(int value) { q.push_back(value); while(mq.size() \u0026amp;\u0026amp; value \u0026gt; mq.back()) mq.pop_back(); mq.push_back(value); } int pop_front() { if(!q.size()) return -1; // if(q.size()) q.pop_front(); int x = q.front(); if (mq.front() == x) { mq.pop_front(); } q.pop_front(); return x; } }; /** * Your MaxQueue object will be instantiated and called as such: * MaxQueue* obj = new MaxQueue(); * int param_1 = obj-\u0026gt;max_value(); * obj-\u0026gt;push_back(value); * int param_3 = obj-\u0026gt;pop_front(); */ ","date":"2022-09-24T19:57:11+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","tags":["单调队列"],"title":"队列的最大值"},{"categories":["项目开发"],"contents":"项目开发 shell 的2种工作模式 交换模式 非交互模式 1 /bin/bash -c \u0026#34;ls -l\u0026#34; 涉及到的系统调用 pipe() : 创建2个文件描述符 fd[0] 可读，fd[1]可写 fork() : 创建子进程， fd[1]继承到子进程 dup2() : 重定向子进程 stdout/stderr 到 fd[1] exec() 在当前进程内，加载并且执行二进制程序 ","date":"2022-09-19T19:46:11+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/","tags":["项目开发"],"title":"项目开发相关"},{"categories":["二分"],"contents":" 81. 搜索旋转排序数组 II Description Difficulty: 中等\nRelated Topics: 数组 , 二分查找 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。\n在传递给函数之前，nums 在预先未知的某个下标 k（0 \u0026lt;= k \u0026lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。\n给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。\n你必须尽可能减少整个操作步骤。\n示例 1：\n1 2 输入：nums = [2,5,6,0,0,1,2], target = 0 输出：true 示例 2：\n1 2 输入：nums = [2,5,6,0,0,1,2], target = 3 输出：false 提示：\n1 \u0026lt;= nums.length \u0026lt;= 5000 -104 \u0026lt;= nums[i] \u0026lt;= 104 题目数据保证 nums 在预先未知的某个下标上进行了旋转 -104 \u0026lt;= target \u0026lt;= 104 进阶：\n这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: bool search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); if (n==0) return false; if (nums[n-1] == target || nums[0] == target) return true; int l=0,r = n-1; while(r\u0026gt;0 \u0026amp;\u0026amp; nums[l] == nums[r]) r--; int m; int head = nums[l],tail = nums[r]; while(l\u0026lt;=r) { m = l + (r-l)/2; if (nums[m] == target) return m; if (nums[m] \u0026lt;= tail) { if (target\u0026lt;= tail \u0026amp;\u0026amp; target\u0026gt; nums[m]) l = m+1; else r = m-1; }else { //is left part if (target\u0026gt;= head \u0026amp;\u0026amp; target \u0026lt;= nums[m]) r = m-1; else l=m+1; } } return false; } }; ","date":"2022-09-18T22:19:43+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/lc.18.%E6%90%9C%E7%B4%A2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%842/","tags":["二分"],"title":"lc.18.搜索选择排序数组2"},{"categories":["二分"],"contents":" 475. 供暖器 Description Difficulty: 中等\nRelated Topics: 数组 , 双指针 , 二分查找 , 排序 冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。\n在加热器的加热半径范围内的每个房屋都可以获得供暖。\n现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。\n说明：所有供暖器都遵循你的半径标准，加热的半径也一样。\n示例 1:\n1 2 3 输入: houses = [1,2,3], heaters = [2] 输出: 1 解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。 示例 2:\n1 2 3 输入: houses = [1,2,3,4], heaters = [1,4] 输出: 1 解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。 示例 3：\n1 2 输入：houses = [1,5], heaters = [2] 输出：3 提示：\n1 \u0026lt;= houses.length, heaters.length \u0026lt;= 3 * 104 1 \u0026lt;= houses[i], heaters[i] \u0026lt;= 109 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: int findRadius(vector\u0026lt;int\u0026gt;\u0026amp; houses, vector\u0026lt;int\u0026gt;\u0026amp; heaters) { sort(heaters.begin(),heaters.end()); // sort(houses.begin(),houses.end()); int n = houses.size(); int ans=0; for (int i=0;i\u0026lt;n;i++) { int j = bfind(heaters, houses[i]); // right int right = abs(heaters[j] - houses[i]);// 右边机器的半径 // int left = (j? houses[i] - heaters[j-1]:right+1); int left=right; if (j) { left = abs(heaters[j-1] - houses[i]); } ans = max(ans,min(left,right)); //最小值中的最大值 } return ans; } int bfind(vector\u0026lt;int\u0026gt; \u0026amp;a, int x) { int l=0,r = a.size()-1; int m; while(l\u0026lt;r) { m = (l+r)/2; if (a[m] \u0026gt;= x) r = m; else l = m+1; } return l; } }; ","date":"2022-09-18T21:55:34+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/lc.475.%E4%BE%9B%E6%9A%96%E5%99%A8/","tags":["二分"],"title":"lc.475.供暖器"},{"categories":["二分"],"contents":" 1658. 将 x 减到 0 的最小操作数 Description Difficulty: 中等\nRelated Topics: 数组 , 哈希表 , 二分查找 , 前缀和 , 滑动窗口 给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。\n如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。\n示例 1：\n1 2 3 输入：nums = [1,1,4,2,3], x = 5 输出：2 解释：最佳解决方案是移除后两个元素，将 x 减到 0 。 示例 2：\n1 2 输入：nums = [5,6,7,8,9], x = 4 输出：-1 示例 3：\n1 2 3 输入：nums = [3,2,20,1,1,3], x = 10 输出：5 解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= nums[i] \u0026lt;= 104 1 \u0026lt;= x \u0026lt;= 109 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public: int minOperations(vector\u0026lt;int\u0026gt;\u0026amp; nums, int x) { int n = nums.size();//没有负数，可以用前缀和【sum 数组 单调递增】 // n*log(N) vector\u0026lt;int\u0026gt; sum(n+1),suf(n+1); for (int i=1;i\u0026lt;=n;i++) { sum[i] = sum[i-1] + nums[i-1]; } for (int i=n-1;i\u0026gt;=0;i--) { // suf[i-1] += (suf[i] + nums[i-1]); suf[n-i] = suf[n-i-1] + nums[i]; //后缀和 } int res=-1; for (int i=0;i\u0026lt;=n;i++) { int target = x - sum[i]; int j = bfind(suf,target); if (j==-1) continue; if (i+j \u0026gt;n) { continue; } // printf(\u0026#34;%d--%d\\n\u0026#34;,suf[j],sum[i]); // if (x - nums[i] - suf[n-j]!=0) continue; if (res==-1 || res \u0026gt; i+j) res = i+j; } // if(res==n+1) return -1; return res; } int bfind(vector\u0026lt;int\u0026gt; \u0026amp;a ,int x) { // int l=0,r = if(a.size()==0) return 0; int l=0,r = a.size()-1; int m ; while(l\u0026lt;r) { m = l+ (r-l)/2; if (a[m] \u0026gt;= x) r = m; else l=m+1; } if (a[r] == x) return r; return -1; } }; ","date":"2022-09-18T21:37:01+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/lc.1658.%E5%B0%86x%E5%87%8F%E5%88%B00%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/","tags":["二分"],"title":"lc.1658.将x减到0的最小操作数"},{"categories":["二分"],"contents":" 34. 在排序数组中查找元素的第一个和最后一个位置 Description Difficulty: 中等\nRelated Topics: 数组 , 二分查找 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\n示例 1：\n1 2 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2：\n1 2 输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3：\n1 2 输入：nums = [], target = 0 输出：[-1,-1] 提示：\n0 \u0026lt;= nums.length \u0026lt;= 105 -109 \u0026lt;= nums[i] \u0026lt;= 109 nums 是一个非递减数组 -109 \u0026lt;= target \u0026lt;= 109 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: vector\u0026lt;int\u0026gt; searchRange(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { if (nums.size() == 0) return {-1,-1}; int pos = bfind(nums,target); if (nums[pos] != target) { return {-1,-1}; } int r = bfind(nums,target+1); if (nums[r] != target) r--; return {pos, r}; } int bfind(vector\u0026lt;int\u0026gt; \u0026amp; nums,int target) { int l=0,r = nums.size()-1; int m; while(l\u0026lt;r) { m = l + (r-l)/2; if (nums[m] \u0026gt;= target) r = m; else l = m+1;//nums[m] \u0026lt; target ==\u0026gt; m+1,r } return r; } }; 最优解法 二分查找，找到比target-1大的第一个位置r1，然后从r1开始找比target+1小的第一个位置，即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: vector\u0026lt;int\u0026gt; searchRange(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); if(n==0) return {-1,-1}; int l=0,r=n-1; while(l\u0026lt;r) { int m = (l+r)/2; if(nums[m] \u0026lt; target ) { // \u0026lt;=target-1 l = m+1; }else { r=m; } } int first = l; if(nums[l] !=target) return {-1,-1}; l= l,r = n-1; while(l\u0026lt;r) { int m = (l+r+1)/2; if(nums[m] \u0026gt; target ) { //\u0026gt;=target+1 r = m-1; }else { l = m; } } return {first,l}; } }; ","date":"2022-09-18T21:04:59+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/lc.34.%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/","tags":["二分"],"title":"lc.34.排序数组中查找元素的第一个位置"},{"categories":["排序"],"contents":" 1288. 删除被覆盖区间 Description Difficulty: 中等\nRelated Topics: 数组 , 排序 给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。\n只有当 c \u0026lt;= a 且 b \u0026lt;= d 时，我们才认为区间 [a,b) 被区间 [c,d) 覆盖。\n在完成所有删除操作后，请你返回列表中剩余区间的数目。\n示例：\n1 2 3 输入：intervals = [[1,4],[3,6],[2,8]] 输出：2 解释：区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。 **提示：**​​​​​​\n1 \u0026lt;= intervals.length \u0026lt;= 1000 0 \u0026lt;= intervals[i][0] \u0026lt; intervals[i][1] \u0026lt;= 10^5 对于所有的 i != j：intervals[i] != intervals[j] Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int removeCoveredIntervals(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { // vector\u0026lt;int\u0026gt; temp; sort(intervals.begin(),intervals.end(),[](auto \u0026amp;a,auto \u0026amp;b) -\u0026gt; bool { if (a[0]==b[0]) return a[1] \u0026gt; b[1]; else return a[0] \u0026lt; b[0]; } ); int del = 0; int n = intervals.size(); int r = -1; for (int i=0;i\u0026lt;n;i++) { if (intervals[i][1] \u0026lt;= r) { del++; }else { r = intervals[i][1]; } } return n - del; } }; ","date":"2022-09-18T19:30:19+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/lc.1288.%E5%88%A0%E9%99%A4%E8%A2%AB%E8%A6%86%E7%9B%96%E7%9A%84%E5%8C%BA%E9%97%B4/","tags":["排序"],"title":"lc.1288.删除被覆盖的区间"},{"categories":["排序"],"contents":" 56. 合并区间 Description Difficulty: 中等\nRelated Topics: 数组 , 排序 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。\n示例 1：\n1 2 3 输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2：\n1 2 3 输入：intervals = [[1,4],[4,5]] 输出：[[1,5]] 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 提示：\n1 \u0026lt;= intervals.length \u0026lt;= 104 intervals[i].length == 2 0 \u0026lt;= starti \u0026lt;= endi \u0026lt;= 104 Solution Language: ****\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { sort(intervals.begin(),intervals.end(), [](const vector\u0026lt;int\u0026gt; \u0026amp;a,const vector\u0026lt;int\u0026gt; \u0026amp;b) -\u0026gt; bool { if (a[0] - b[0]) return a[0] \u0026lt; b[0]; return a[1] \u0026gt; b[1]; // a覆盖b } ); // int max_r = -1;//记录最右边的 值 // int cnt =0;//被覆盖的区间 // for (auto s :intervals) { // if(r \u0026gt;= s[1]) // cnt ++; // 覆盖了一个 // else r = s[1]; // } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; for (auto s: intervals) { int l = s[0],r = s[1]; if(res.size()==0 || res.back()[1] \u0026lt; l) { res.push_back(s); }else { res.back()[1] = max(res.back()[1],r); } } return res; } }; ","date":"2022-09-18T18:36:52+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/lc.56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/","tags":["排序"],"title":"lc.56.合并区间"},{"categories":["基数排序"],"contents":" 164. 最大间距 Description Difficulty: 困难\nRelated Topics: 数组 , 桶排序 , 基数排序 , 排序 给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。\n您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。\n示例 1:\n1 2 3 输入: nums = [3,6,9,1] 输出: 3 解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。 示例 2:\n1 2 3 输入: nums = [10] 输出: 0 解释: 数组元素个数小于 2，因此返回 0。 提示:\n1 \u0026lt;= nums.length \u0026lt;= 105 0 \u0026lt;= nums[i] \u0026lt;= 109 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: int maximumGap(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if (n \u0026lt; 2) { return 0; } int exp = 1; vector\u0026lt;int\u0026gt; buf(n); int maxVal = *max_element(nums.begin(), nums.end()); while (maxVal \u0026gt;= exp) { vector\u0026lt;int\u0026gt; cnt(10); for (int i = 0; i \u0026lt; n; i++) { int digit = (nums[i] / exp) % 10; cnt[digit]++; } for (int i = 1; i \u0026lt; 10; i++) { cnt[i] += cnt[i - 1]; } for (int i = n - 1; i \u0026gt;= 0; i--) { int digit = (nums[i] / exp) % 10; buf[cnt[digit] - 1] = nums[i]; cnt[digit]--; } copy(buf.begin(), buf.end(), nums.begin()); exp *= 10; } int ret = 0; for (int i = 1; i \u0026lt; n; i++) { ret = max(ret, nums[i] - nums[i - 1]); } return ret; } }; ","date":"2022-09-18T15:57:37+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/lc.164.%E6%9C%80%E5%A4%A7%E9%97%B4%E8%B7%9D/","tags":["基数排序"],"title":"lc.164.最大间距"},{"categories":["排序"],"contents":"桶排序 计数排序 统计每个元素的个数，然后复制到数组上。\n基数排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; using namespace std; #define ArraySize 8 void radix(int data[],int size) { int n; for(int i=1;i\u0026lt;=100;i=i*10) { int tmp[20][10]={0};//建立一个20行，10列的数组，每一列分别代表0~9位数，20行代表能存放的总个数 for(int j=0;j\u0026lt;size;j++) { n=(data[j]/i)%10; tmp[j][n]=data[j]; } int k=0; for(int p=0;p\u0026lt;10;p++) for(int q=0;q\u0026lt;size;q++) { if(tmp[q][p]!=0) data[k++]=tmp[q][p]; } } } int main() { int data[ArraySize]; /*输入数组数据*/ cout\u0026lt;\u0026lt;\u0026#34;input number\u0026#34;\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;ArraySize;i++) cin\u0026gt;\u0026gt;data[i]; /*执行排序*/ radix(data,8); /*输出排序结果*/ cout\u0026lt;\u0026lt;\u0026#34;\u0026#34;\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;ArraySize;i++) cout\u0026lt;\u0026lt;data[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; return 0; } ","date":"2022-09-18T14:43:24+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E6%A1%B6%E6%8E%92%E5%BA%8F/","tags":["排序"],"title":"桶排序"},{"categories":["归并排序"],"contents":" 1508. 子数组和排序后的区间和 Description Difficulty: 中等\nRelated Topics: 数组 , 双指针 , 二分查找 , 排序 给你一个数组 nums ，它包含 n 个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序，得到一个新的包含 n * (n + 1) / 2 个数字的数组。\n请你返回在新数组中下标为left 到 right **（下标从 1 开始）**的所有数字和（包括左右端点）。由于答案可能很大，请你将它对 10^9 + 7 取模后返回。\n示例 1：\n1 2 3 输入：nums = [1,2,3,4], n = 4, left = 1, right = 5 输出：13 解释：所有的子数组和为 1, 3, 6, 10, 2, 5, 9, 3, 7, 4 。将它们升序排序后，我们得到新的数组 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 1 到 ri = 5 的和为 1 + 2 + 3 + 3 + 4 = 13 。 示例 2：\n1 2 3 输入：nums = [1,2,3,4], n = 4, left = 3, right = 4 输出：6 解释：给定数组与示例 1 一样，所以新数组为 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 3 到 ri = 4 的和为 3 + 3 = 6 。 示例 3：\n1 2 输入：nums = [1,2,3,4], n = 4, left = 1, right = 10 输出：50 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^3 nums.length == n 1 \u0026lt;= nums[i] \u0026lt;= 100 1 \u0026lt;= left \u0026lt;= right \u0026lt;= n * (n + 1) / 2 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: struct Data { int i; int j; int sum; bool operator \u0026lt;(const Data \u0026amp;b) const { return sum \u0026gt; b.sum; } }; int rangeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int n, int left, int right) { priority_queue\u0026lt;Data\u0026gt; q; for (int i=0;i\u0026lt;n;i++) q.push({i,i,nums[i]}); //多路归并排序 int ans=0,mod = 1e9+7; for (int i=1;i\u0026lt;=right;i++) { Data d = q.top(); q.pop(); if (i\u0026gt;=left) ans = (ans + d.sum) % mod; //求和 if (d.j+1 \u0026lt; n) { q.push(Data{d.i,d.j+1,(d.sum + nums[d.j+1]) % mod}); } } return ans; } }; ","date":"2022-09-18T14:40:48+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/lc.1508.%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E5%8C%BA%E9%97%B4%E5%92%8C/","tags":["归并排序"],"title":"lc.1508.子数组和排序后的区间和"},{"categories":["归并排序"],"contents":" 315. 计算右侧小于当前元素的个数 Description Difficulty: 困难\nRelated Topics: 树状数组 , 线段树 , 数组 , 二分查找 , 分治 , 有序集合 , 归并排序 给你一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。\n示例 1：\n1 2 3 4 5 6 7 输入：nums = [5,2,6,1] 输出：[2,1,1,0] 解释： 5 的右侧有 2 个更小的元素 (2 和 1) 2 的右侧仅有 1 个更小的元素 (1) 6 的右侧有 1 个更小的元素 (1) 1 的右侧有 0 个更小的元素 示例 2：\n1 2 输入：nums = [-1] 输出：[0] 示例 3：\n1 2 输入：nums = [-1,-1] 输出：[0,0] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 -104 \u0026lt;= nums[i] \u0026lt;= 104 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Solution { public: struct Data { int val; int ind; int cnt; bool operator \u0026gt; (const Data \u0026amp;a) { return val \u0026gt; a.val; } }; int ans; vector\u0026lt;Data\u0026gt; temp; void mergeSort(vector\u0026lt;Data\u0026gt; \u0026amp;arr,int l ,int r) { if (l\u0026gt;=r) return; int m = l + (r-l)/2; mergeSort(arr,l,m); mergeSort(arr,m+1,r); //merge int p1 = l,p2=m+1,k=l; while(p1\u0026lt;=m \u0026amp;\u0026amp; p2 \u0026lt;= r) { if(arr[p1] \u0026gt; arr[p2]) { arr[p1].cnt += (r-p2+1); temp[k++] = arr[p1++]; }else { temp[k++] = arr[p2++]; } } while(p1 \u0026lt;= m) { arr[p1].cnt += (r-p2+1); temp[k++] = arr[p1++]; } while(p2 \u0026lt;= r) { temp[k++] = arr[p2++]; } for (int i=l;i\u0026lt;=r;i++) { arr[i] = temp[i]; } return; } vector\u0026lt;int\u0026gt; countSmaller(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;Data\u0026gt; arr; int n = nums.size(); for (int i=0;i\u0026lt;n;i++) arr.push_back(Data{nums[i],i,0}); temp.resize(arr.size()); mergeSort(arr,0,n-1); vector\u0026lt;int\u0026gt; ret(n); for (auto x: arr) { ret[x.ind] = x.cnt; } return ret; } }; ","date":"2022-09-18T12:05:03+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/lc.315.%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/","tags":["归并排序"],"title":"lc.315.计算右侧小于当前元素的个数"},{"categories":["前缀和"],"contents":" 327. 区间和的个数 Description Difficulty: 困难\nRelated Topics: 树状数组 , 线段树 , 数组 , 二分查找 , 分治 , 有序集合 , 归并排序 给你一个整数数组 nums 以及两个整数 lower 和 upper 。求数组中，值位于范围 [lower, upper] （包含 lower 和 upper）之内的 区间和的个数 。\n区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。\n示例 1：\n1 2 3 输入：nums = [-2,5,-1], lower = -2, upper = 2 输出：3 解释：存在三个区间：[0,0]、[2,2] 和 [0,2] ，对应的区间和分别是：-2 、-1 、2 。 示例 2：\n1 2 输入：nums = [0], lower = 0, upper = 0 输出：1 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 -105 \u0026lt;= lower \u0026lt;= upper \u0026lt;= 105 题目数据保证答案是一个 32 位 的整数 Solution Language: C++\n前缀和推导：\n$j\u0026lt;i$\n$lower\u0026lt;= sum[j] - sum[i] \u0026lt;= upper $\n即:\n$ sum[i] \u0026gt;= sum[j] - upper $\n$ sum[i] \u0026lt;= sum[j] - lower $\n上面公式是解题关键：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #define lowbit(x) x\u0026amp;-x const int N = 1e4+10; int n; int tr[N]; void incr(int pos,int c) { for(int i=pos;i\u0026lt;=n;i+=lowbit(i)) tr[i] += c; } long long count(int pos) { long long sum=0; for(int i=pos;i;i-=lowbit(i)) sum+=tr[i]; return sum; } class Solution { public: int countRangeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int lower, int upper) { //区间和 -\u0026gt; 前缀和 -\u0026gt; 线段树 //区间和 在 lower 和 upper 之间 int len = nums.size(); if(len\u0026lt;=0) return 0; memset(tr,0,sizeof tr); vector\u0026lt;long long\u0026gt; sum(len + 1,0);//求前缀和 在[lower,upper] -\u0026gt; for(int i=1;i\u0026lt;= len;++i) sum[i] = sum[i-1] + nums[i-1]; set\u0026lt;long long\u0026gt; _set; unordered_map\u0026lt;long long,int\u0026gt;_ranks; for(long long x: sum) _set.insert(x),_set.insert(x-lower),_set.insert(x-upper); int rank = 1; for(long long x: _set) _ranks[x] = rank++; int res=0; //注意： 是离散化后的 点的个数 n = _set.size(); for(long long x: sum) { //rank int left = _ranks[x-upper], right = _ranks[x-lower]; res+= count(right) - count(left-1); incr(_ranks[x],1); } return res; } }; ","date":"2022-09-18T11:39:42+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C/lc.327.%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0/","tags":["前缀和"],"title":"lc.327.区间和的个数"},{"categories":["排序"],"contents":"快速排序代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void quick_sort(int *arr,int l,int r) { if (l\u0026gt;=r) return ; int x = arr[l]; int bl = l,br = r; while(l\u0026lt;r) { while(l \u0026lt; r \u0026amp;\u0026amp; arr[r] \u0026gt;= x) r--; //\u0026gt;= if (l \u0026lt; r ) arr[l++] = arr[r]; while(l \u0026lt; r \u0026amp;\u0026amp; arr[l] \u0026lt; x) l++; //\u0026lt; if(l\u0026lt;r) arr[r--] = arr[l]; } arr[l] = x; quick_sort(arr,bl,l-1); quick_sort(arr,l+1,br); } int main(void) { int arr[] = {1,5 ,2,2,111,6666,-11111,77,22,4355,4577,0,856678568,-1,412}; int N = sizeof(arr)/sizeof(int); quick_sort(arr,0,N-1); for (int i=0;i\u0026lt;N;i++) { printf(\u0026#34;%d,\u0026#34;,arr[i]); } return 0; } 参考模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5+10; int a[N]; int fast_select (int l,int r, int k) { if (l\u0026gt;=r) return a[l]; int mid = l+r \u0026gt;\u0026gt; 1; int i = l-1, j = r+1, x = a[mid]; while (i\u0026lt;j) { do ++i; while (i\u0026lt;=r \u0026amp;\u0026amp; a[i] \u0026lt; x); do --j; while (j\u0026gt;=l \u0026amp;\u0026amp; a[j]\u0026gt;x); if (i\u0026lt;j) swap (a[i], a[j]); } int index = j-l+1; if (index \u0026gt;=k) return fast_select(l,j,k); return fast_select(j+1, r,k-index); } int main() { int n,k;cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for (int i=0;i\u0026lt;n;++i) cin\u0026gt;\u0026gt;a[i]; cout \u0026lt;\u0026lt; fast_select(0,n-1,k); } 参考模板2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package main /** * 找到数组中第 K 大的元素 * @param a int整型一维数组 * @param n int整型 数组长度 * @param K int整型 第 K 大 * @return int整型 */ func findKth(a []int, n int, K int) int { // 第 K 大元素等价于数组中第 n-K+1 小的元素 targetIndex := n - K return quickSelect(a, 0, n-1, targetIndex) } // 快速选择函数 func quickSelect(a []int, left, right, k int) int { if left == right { return a[left] } pivotIndex := partition(a, left, right) if pivotIndex == k { return a[k] } else if pivotIndex \u0026gt; k { return quickSelect(a, left, pivotIndex-1, k) } else { return quickSelect(a, pivotIndex+1, right, k) } } // 分区函数，返回分区后基准值的最终位置 func partition(a []int, left, right int) int { pivot := a[right] // 选择最右边的元素作为基准值 i := left - 1 for j := left; j \u0026lt; right; j++ { if a[j] \u0026lt;= pivot { i++ a[i], a[j] = a[j], a[i] } } // 将基准值放到正确的位置 a[i+1], a[right] = a[right], a[i+1] return i + 1 } ","date":"2022-09-15T21:14:27+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/","tags":["排序"],"title":"快速排序代码模板"},{"categories":["dp"],"contents":"动态规划基础理解 阶段，状态、决策 重叠子问题 找零钱问题 最长公共子序列 例题 lcs lis 乘积的最大子数组 经典例题 零钱兑换问题：\n搜索遍历整个状态空间\ngraph LR coin18--\u0026gt;coin9_1--\u0026gt;coin_9_2 coin18--\u0026gt;coin17_1--\u0026gt;coin16_2 零钱兑换： 最优子结构 状态中没有必要包含 “已用硬币枚数”\n每个 “剩余金额”, 搜索一次，求出“兑换这个金额所需要的最少硬币枚数” 就足够了。\n原始状态：剩余金额、已用硬币枚数，目标：到达终点（0元）\n新状态：剩余金额，最优化目标：硬币枚数最少。\n推导关系： “兑换n元的最少硬币枚数”\n$opt(n) = min(opt(n-9),opt(n-1),opt(n-10))$\n状态+最优化模板+ 最优化目标之间的递推关系=最优子结构\n1 2 3 4 5 6 7 8 9 10 11 12 opt[0] = 0; for (int i=1;i\u0026lt;=amount;i++) { opt[i] = INF; for (int x: coins) { if (i-x \u0026gt;= 0) { opt[i] = min(opt[i],opt[i-x] + 1); } } } if(opt[amount]\u0026gt;=INF) return -1; return opt[amount]; 最长公共子序列 [[区间dp/区间dp问题详解.md]]\n给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int longestCommonSubsequence(string text1, string text2) { int n = text1.size(),m = text2.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n+1,(vector\u0026lt;int\u0026gt;(m+1))); for (int i=1;i\u0026lt;=n;i++) { for (int j=1;j\u0026lt;=m;j++) { if(text1[i-1] == text2[j-1]) { dp[i][j] = dp[i-1][j-1]+1; } dp[i][j] = max(dp[i-1][j],max(dp[i][j],dp[i][j-1])); } } return dp[n][m]; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Solution { public: int longestCommonSubsequence(string text1, string text2) { int n = text1.size(),m = text2.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n+1,(vector\u0026lt;int\u0026gt;(m+1))); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dir(n+1,(vector\u0026lt;int\u0026gt;(m+1))); for (int i=1;i\u0026lt;=n;i++) { for (int j=1;j\u0026lt;=m;j++) { if(text1[i-1] == text2[j-1]) { dp[i][j] = dp[i-1][j-1]+1; dir[i][j] = 1; }else { if (dp[i-1][j] \u0026gt; dp[i][j-1]) { dir[i][j] = 2; dp[i][j] = dp[i-1][j]; }else { dir[i][j] = 3; dp[i][j] = dp[i][j-1]; } } } } string buf; print_result(dir,buf,n,m,text1,text2); cout \u0026lt;\u0026lt; \u0026#34;result: \u0026#34;\u0026lt;\u0026lt; buf \u0026lt;\u0026lt;endl; return dp[n][m]; } void print_result(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;ans,string \u0026amp;buf,int i,int j,string \u0026amp;a,string \u0026amp;b) { if(i\u0026lt;0 ||j\u0026lt;0) { return; } if(i==0 \u0026amp;\u0026amp; j==0) { buf.push_back(a[i]); return; } switch (ans[i][j]) { case 1: { print_result(ans,buf,i-1,j-1,a,b); buf.push_back(a[i]); break; } case 2: { print_result(ans,buf,i-1,j,a,b); // buf.push_back(a[i-1][j]) break; } case 3: { print_result(ans,buf,i,j-1,a,b); // buf.push_back(a[i][j-1]); break; } } } }; ","date":"2022-09-14T00:01:43+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/","tags":["dp"],"title":"动态规划基础"},{"categories":["计数排序"],"contents":" 1122. 数组的相对排序 Description Difficulty: 简单\nRelated Topics: 数组 , 哈希表 , 计数排序 , 排序 给你两个数组，arr1 和 arr2，arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中。\n对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。\n示例 1：\n1 2 输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] 输出：[2,2,2,1,4,3,3,9,6,7,19] 示例 2:\n1 2 输入：arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6] 输出：[22,28,8,6,17,44] 提示：\n1 \u0026lt;= arr1.length, arr2.length \u0026lt;= 1000 0 \u0026lt;= arr1[i], arr2[i] \u0026lt;= 1000 arr2 中的元素 arr2[i] 各不相同 arr2 中的每个元素 arr2[i] 都出现在 arr1 中 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: vector\u0026lt;int\u0026gt; relativeSortArray(vector\u0026lt;int\u0026gt;\u0026amp; arr1, vector\u0026lt;int\u0026gt;\u0026amp; arr2) { vector\u0026lt;int\u0026gt; res(arr1.size()); vector\u0026lt;int\u0026gt; count(1001); for (int u: arr1) count[u]++; int index=0; for (int u: arr2) { while(count[u] \u0026gt; 0) { res[index++] = u; count[u]--; } } int n = count.size(); for (int i=0;i\u0026lt;n;i++) { while(count[i]\u0026gt;0) count[i]--,res[index++] = i; } return res; } }; ","date":"2022-09-11T10:22:53+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/lc.1122.%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/","tags":["计数排序"],"title":"lc.1122.数组的相对排序"},{"categories":["二分"],"contents":" 1482. 制作 m 束花所需的最少天数 Description Difficulty: 中等\nRelated Topics: 数组 , 二分查找 给你一个整数数组 bloomDay，以及两个整数 m 和 k 。\n现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。\n花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。\n请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。\n示例 1：\n1 2 3 4 5 6 7 输入：bloomDay = [1,10,3,10,2], m = 3, k = 1 输出：3 解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。 现在需要制作 3 束花，每束只需要 1 朵。 1 天后：[x, _, _, _, _] // 只能制作 1 束花 2 天后：[x, _, _, _, x] // 只能制作 2 束花 3 天后：[x, _, x, _, x] // 可以制作 3 束花，答案为 3 示例 2：\n1 2 3 输入：bloomDay = [1,10,3,10,2], m = 3, k = 2 输出：-1 解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。 示例 3：\n1 2 3 4 5 6 7 8 输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3 输出：12 解释：要制作 2 束花，每束需要 3 朵。 花园在 7 天后和 12 天后的情况如下： 7 天后：[x, x, x, x, _, x, x] 可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。 12 天后：[x, x, x, x, x, x, x] 显然，我们可以用不同的方式制作两束花。 示例 4：\n1 2 3 输入：bloomDay = [1000000000,1000000000], m = 1, k = 1 输出：1000000000 解释：需要等 1000000000 天才能采到花来制作花束 示例 5：\n1 2 输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2 输出：9 提示：\nbloomDay.length == n 1 \u0026lt;= n \u0026lt;= 10^5 1 \u0026lt;= bloomDay[i] \u0026lt;= 10^9 1 \u0026lt;= m \u0026lt;= 10^6 1 \u0026lt;= k \u0026lt;= n Solution Language: C++\n解题思路:\n用二分划分最少天数的定义域(时间是定义域，制作m束花是否可行为0和1，能够成功范围为值域)。\n判定性质：\n如果T可行，T越大，花朵开的越多，越能制作 (T+1,+无穷) 都是可行的范围\n判定 mid天的开花情况，能否制作m朵花，每朵花是连续的K朵\n时间复杂度是 $o(NlogN)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public: int minDays(vector\u0026lt;int\u0026gt;\u0026amp; bloomDay, int m, int k) { //制作m朵 \u0026lt;- 需要 k个相邻的位置 //最少的天数 if(m*k \u0026gt; bloomDay.size() ) return -1; if (bloomDay.size()==0) return -1; int l=(int)(1e9),r=0; for (int temp: bloomDay) { l = min(l,temp); r = max(r,temp); } int no = r+1; r = no; int temp=0; while(l\u0026lt;r) { temp = l+(r-l)/2; if(valid(bloomDay,temp,m,k )) { //最少 r = temp; }else { l = temp+1; //不够数 } } if(r==no) return -1;//无解 return r; } // minday bool valid (vector\u0026lt;int\u0026gt; \u0026amp;bloomDay ,int minday,int m,int k) { int n = bloomDay.size(); int tempk = 0; int cnt = 0; for (int i=0;i\u0026lt;n;i++) { if (bloomDay[i] - minday \u0026lt;= 0) { //成熟的花 tempk++; }else { tempk = 0; } if(tempk\u0026gt;=k) { tempk = 0;//满足一束花 cnt++; } } return cnt\u0026gt;=m;// 最少需要 } }; ","date":"2022-09-11T09:19:45+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/lc.1482.%E5%88%B6%E4%BD%9Cm%E6%9D%9F%E8%8A%B1%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A4%A9%E6%95%B0/","tags":["二分"],"title":"lc.1482.制作m束花需要的最小天数"},{"categories":["二分"],"contents":" 410. 分割数组的最大值 Description Difficulty: 困难\nRelated Topics: 贪心 , 数组 , 二分查找 , 动态规划 给定一个非负整数数组 nums 和一个整数 m ，你需要将这个数组分成 m个非空的连续子数组。\n设计一个算法使得这 m个子数组各自和的最大值最小。\n示例 1：\n1 2 3 4 5 6 输入：nums = [7,2,5,10,8], m = 2 输出：18 解释： 一共有四种方法将 nums 分割为 2 个子数组。 其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。 因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。 示例 2：\n1 2 输入：nums = [1,2,3,4,5], m = 2 输出：9 示例 3：\n1 2 输入：nums = [1,4,4], m = 3 输出：4 提示：\n1 \u0026lt;= nums.length \u0026lt;= 1000 0 \u0026lt;= nums[i] \u0026lt;= 106 1 \u0026lt;= m \u0026lt;= min(50, nums.length) 区间DP解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int splitArray(vector\u0026lt;int\u0026gt;\u0026amp; nums, int m) { vector\u0026lt;long long\u0026gt; sum(nums.size()+1); int n = nums.size(); for(int i=1;i\u0026lt;=n;i++) sum[i] += (sum[i-1] + nums[i-1]); vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; dp(n+1,vector\u0026lt;long long\u0026gt;(m+1,INT_MAX)); dp[0][0] = 0; for(int i=1;i\u0026lt;=n;i++) { //dp[i][1] = sum[i];// 前i 个 1组 // 前 i个 一共 m组 for(int j=1;j\u0026lt;=min(i,m);j++) { for(int k=0;k\u0026lt;i;k++) { // max(不分配， 分配(i-k)) dp[i][j] = min(dp[i][j],max(dp[k][j-1], sum[i] - sum[k])); } } } return dp[n][m]; } }; 二分法+贪心 答案？为什么是 \u0026lt;=T\nnums = [7,2,5,10,8], 一共有四种方法将nums分割为2个子数组\n[7,| 2,5,10,8], max=25\n[7, 2 | ,5,10,8], max=23\n[7, 2 ,5 |,10,8], max=18\n[7, 2 ,5 ,10|,8], max=24\n我们可以考虑让 nums 分为m个子数组，最大一组的和 = T, \u0026ndash; 只有 18,23,24.25 合法\n如果每组的和 \u0026lt;=T, 17以前都不合法，18之后合法， 25 之前合法。\n我们的目的就是二分枚举出分割数组的最大值。\n注意： 前提条件是非负的数组 ，可以 令 l=0,r = sum(array),枚举中间的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public: int splitArray(vector\u0026lt;int\u0026gt;\u0026amp; nums, int m) { int n = nums.size(); // int sum = 0; int l=0,r = 0; for (auto v: nums) { r += v; //上界 l = max(l,v); //下界 } while(l\u0026lt;r) { int T = l+(r-l)/2; if (valid(nums,T,m)) { r = T; //找到一个上界，继续往下移动 }else { l = T+1;//not valid } } return l; } bool valid(vector\u0026lt;int\u0026gt; \u0026amp;nums,int T,int m) { int group_sum=0,group_cnt = 1; int n = nums.size(); for (int i=0;i\u0026lt;n;i++) { if (group_sum+nums[i] \u0026lt;=T) { group_sum += nums[i]; }else { if (group_sum==0) return false; //要求非空 group_sum = nums[i]; if (group_sum \u0026gt; T) return false; // 要求小于上界 group_cnt++; } } return group_cnt \u0026lt;= m; } }; ","date":"2022-09-10T22:58:56+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/lc.410.%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","tags":["二分"],"title":"lc.410.分割数组的最大值"},{"categories":["二分"],"contents":" 374. 猜数字大小 Description Difficulty: 简单\nRelated Topics: 二分查找 , 交互 猜数字游戏的规则如下：\n每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。 你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：\n-1：我选出的数字比你猜的数字小 pick \u0026lt; num 1：我选出的数字比你猜的数字大 pick \u0026gt; num 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num 返回我选出的数字。\n示例 1：\n1 2 输入：n = 10, pick = 6 输出：6 示例 2：\n1 2 输入：n = 1, pick = 1 输出：1 示例 3：\n1 2 输入：n = 2, pick = 1 输出：1 示例 4：\n1 2 输入：n = 2, pick = 2 输出：2 提示：\n1 \u0026lt;= n \u0026lt;= 231 - 1 1 \u0026lt;= pick \u0026lt;= n Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * Forward declaration of guess API. * @param num your guess * @return -1 if num is lower than the guess number * 1 if num is higher than the guess number * otherwise return 0 * int guess(int num); */ class Solution { public: int guessNumber(int n) { int l=1,r = n; if (guess(l) == 0) return l; if (guess(n) == 0) return n; int m; while(l\u0026lt;r) { m = l + ((r-l) /2 ); if(guess(m) \u0026lt;= 0) r = m; else l = m+1; } return l; } }; ","date":"2022-09-10T22:57:11+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/lc.374.%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F/","tags":["二分"],"title":"lc.374.猜数字大小"},{"categories":["二分"],"contents":" 162. 寻找峰值 Description Difficulty: 中等\nRelated Topics: 数组 , 二分查找 峰值元素是指其值严格大于左右相邻值的元素。\n给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。\n你可以假设 nums[-1] = nums[n] = -∞ 。\n你必须实现时间复杂度为 O(log n)的算法来解决此问题。\n示例 1：\n1 2 3 输入：nums = [1,2,3,1] 输出：2 解释：3 是峰值元素，你的函数应该返回其索引 2。 示例 2：\n1 2 3 4 输入：nums = [1,2,1,3,5,6,4] 输出：1 或 5 解释：你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 1000 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 对于所有有效的 i 都有 nums[i] != nums[i + 1] Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int findPeakElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(),l=0,r = n-1; while(l\u0026lt;r) { int lmid = l + (r-l)/2; int rmid = lmid+1; if (nums[lmid] \u0026lt; nums[rmid]) { //峰值在 [lmid+1,r] l = lmid+1; }else { //f(lmid) \u0026gt;= f(rmid) ==\u0026gt; r = rmid-1; r = rmid-1; } } return l; } }; ","date":"2022-09-10T22:35:45+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/lc.162.%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/","tags":["二分"],"title":"lc.162.寻找峰值"},{"categories":["二分"],"contents":"二分查找学习 二分： 用于在单调函数上查找特定值\n由二分衍生出的三分查找 三分： 用于在单峰值函数上寻找极大值\n单峰函数f的极大值为例， [l,r]区间中任意取出两个点 lmid,rmid.\n$$\nf(lmid) \u0026lt;= f(rmid) ,函数比在lmid 处单调递增，极值在[lmid,r]上\n$$\n$$\nf(lmid) \u0026gt; f(rmid)，函数在rmid 出单调递减，极值在 [l,rmid]上\n$$\nlmid，rmid可以取三等分点\n也可以取lmid为二等分点， rmid 比二等分大一点点。\n取黄金分割点最快。\nleetcode 162题，寻找峰值参考\n解题代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int findPeakElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(),l=0,r = n-1; while(l\u0026lt;r) { int lmid = l + (r-l)/2; int rmid = lmid+1; if (nums[lmid] \u0026lt; nums[rmid]) { //峰值在 [lmid+1,r] l = lmid+1; }else { //f(lmid) \u0026gt;= f(rmid) ==\u0026gt; r = rmid-1; r = rmid-1; } } return l; } }; 二分通用解题模板 lower_bound 模板(第一个\u0026gt;=target的数) 解题技巧， 查找第一个 \u0026gt; target -1 的元素下表\n1 2 3 4 5 6 7 8 9 10 int l = 0,r = n -1; while(l\u0026lt;r) { int mid = (l+r) /2; if(arr[mid] \u0026gt;= target) { r = mid; }else { l = mid + 1; } } 查找最后一个 \u0026lt;=target 的数 (前驱数) 解题技巧， 查找比 target + 1 小的第一个元素\n1 2 3 4 5 6 7 8 9 10 int l = -1,r = n-1; while (l \u0026lt; r) { int mid = (l+r+1) /2; if (arr[mid] \u0026lt;= target) { l = mid; }else { r = mid -1; } } return r; 二分的本质是建立一个单调分段 0/1函数，定义域为解空间(答案)，值域为 0 或者 1,在这个函数上二分查找出分界点。\n解空间\n二分答案问题 通常用于最优化问题求解：\n尤其是出现 最大值最小，最小值最大 这类字眼题目上 最大值最小中的最小是一个最优化目标，最大一般是一个限制条件(例如：限制划分出子数组的和) 判定问题条件通常是一个不等式：不等式反映了上述限制\n关于这个条件的合法情况具有特殊单调性，就可以用二分答案把求解转化为判定的技巧。\n练习题:\nleetcode.1482.制作m束花所需的最小天数 ","date":"2022-09-10T22:12:40+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%9F%BA%E7%A1%80/","tags":["二分"],"title":"二分查找基础"},{"categories":["图的后序遍历"],"contents":" 329. 矩阵中的最长递增路径 Description Difficulty: 困难\nRelated Topics: 深度优先搜索 , 广度优先搜索 , 图 , 拓扑排序 , 记忆化搜索 , 数组 , 动态规划 , 矩阵 给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。\n对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。\n示例 1：\n1 2 3 输入：matrix = [[9,9,4],[6,6,8],[2,1,1]] 输出：4 解释：最长递增路径为 [1, 2, 6, 9]。 示例 2：\n1 2 3 输入：matrix = [[3,4,5],[3,2,6],[2,2,1]] 输出：4 解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。 示例 3：\n1 2 输入：matrix = [[1]] 输出：1 提示：\nm == matrix.length n == matrix[i].length 1 \u0026lt;= m, n \u0026lt;= 200 0 \u0026lt;= matrix[i][j] \u0026lt;= 231 - 1 Solution 后序遍历解法 Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 const int MAXN = 250; int dx[] = {-1,1,0,0}; int dy[] = {0,0,-1,1}; class Solution { public: int longestIncreasingPath(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int n = matrix.size(); if(n\u0026lt;=0) return 0; int m = matrix[0].size(); if (m\u0026lt;=0) return 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(matrix.size(),vector\u0026lt;int\u0026gt;(matrix[0].size(),-1)); int res=0; for (int i=0;i\u0026lt;n;i++) { for (int j=0;j\u0026lt;m;j++) { res = max(res,solve(matrix,dp, i,j)); } } return res; } int solve(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;dp,int x,int y) { if (dp[x][y] != -1) return dp[x][y]; dp[x][y] = 1; for (int i=0;i\u0026lt;4;i++) { int nx = x+ dx[i]; int ny = y+dy[i]; if (nx\u0026lt;0 || ny\u0026lt;0 || nx \u0026gt;= dp.size()||ny\u0026gt;=dp[0].size()) continue; if (matrix[nx][ny] \u0026gt; matrix[x][y]) {//后序遍历 dp[x][y] = max(dp[x][y],solve(matrix,dp,nx,ny)+1); } } return dp[x][y]; } }; 拓扑排序解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class Solution { public: int longestIncreasingPath(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int n = matrix.size(); if(n\u0026lt;=0) return 0; int m = matrix[0].size(); if (m\u0026lt;=0) return 0; N = m*n; //total count dist.resize(N); indeg.resize(N); edges.resize(N); const int dx[] = {0,0,1,-1}; const int dy[] = {1,-1,0,0}; for (int i=0;i\u0026lt;n;i++) { for (int j=0;j\u0026lt;m;j++) { bool flag = true; for (int k=0;k\u0026lt;4;k++) { int ni = i+dx[k]; int nj = j+dy[k]; if (ni\u0026gt;=0 \u0026amp;\u0026amp; ni\u0026lt;n \u0026amp;\u0026amp; nj\u0026gt;=0 \u0026amp;\u0026amp; nj \u0026lt; m) { if (matrix[ni][nj] \u0026gt; matrix[i][j]) { addEdge(id(i,j,m),id(ni,nj,m)); } } } } } topsort(); int max_len=0; for (int i=0;i\u0026lt;N;i++) { max_len = max(max_len,dist[i]); } return max_len; } int N=0; vector\u0026lt;int\u0026gt; dist; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; edges; vector\u0026lt;int\u0026gt; indeg; void addEdge(int a,int b) { edges[a].push_back(b); indeg[b]++; } int id(int i,int j,int m) { return i*m + j; } void topsort() { queue\u0026lt;int \u0026gt; q; for (int i=0;i\u0026lt;N;i++) { if (indeg[i]==0) { q.push(i); dist[i] = 1; } } while(q.size()) { int st = q.front();q.pop(); for (int y: edges[st]) { indeg[y] --; dist[y] = max(dist[y],dist[st]+1); if (indeg[y] == 0) q.push(y); } } } }; ","date":"2022-09-09T23:25:43+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/lc.329.%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/","tags":["图的后序遍历"],"title":"lc.329.矩阵中的最长递增路径"},{"categories":["最短路径问题"],"contents":" 433. 最小基因变化 Description Difficulty: 中等\nRelated Topics: 广度优先搜索 , 哈希表 , 字符串 基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 'A'、'C'、'G' 和 'T' 之一。\n假设我们需要调查从基因序列 start 变为 end 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。\n例如，\u0026quot;AACCGGTT\u0026quot; --\u0026gt; \u0026quot;AACCGGTA\u0026quot; 就是一次基因变化。 另有一个基因库 bank 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 bank 中）\n给你两个基因序列 start 和 end ，以及一个基因库 bank ，请你找出并返回能够使 start 变化为 end 所需的最少变化次数。如果无法完成此基因变化，返回 -1 。\n注意：起始基因序列 start 默认是有效的，但是它并不一定会出现在基因库中。\n示例 1：\n1 2 输入：start = \u0026#34;AACCGGTT\u0026#34;, end = \u0026#34;AACCGGTA\u0026#34;, bank = [\u0026#34;AACCGGTA\u0026#34;] 输出：1 示例 2：\n1 2 输入：start = \u0026#34;AACCGGTT\u0026#34;, end = \u0026#34;AAACGGTA\u0026#34;, bank = [\u0026#34;AACCGGTA\u0026#34;,\u0026#34;AACCGCTA\u0026#34;,\u0026#34;AAACGGTA\u0026#34;] 输出：2 示例 3：\n1 2 输入：start = \u0026#34;AAAAACCC\u0026#34;, end = \u0026#34;AACCCCCC\u0026#34;, bank = [\u0026#34;AAAACCCC\u0026#34;,\u0026#34;AAACCCCC\u0026#34;,\u0026#34;AACCCCCC\u0026#34;] 输出：3 提示：\nstart.length == 8 end.length == 8 0 \u0026lt;= bank.length \u0026lt;= 10 bank[i].length == 8 start、end 和 bank[i] 仅由字符 ['A', 'C', 'G', 'T'] 组成 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public: int minMutation(string start, string end, vector\u0026lt;string\u0026gt;\u0026amp; bank) { const char gene[] = {\u0026#39;A\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;G\u0026#39;,\u0026#39;T\u0026#39;}; unordered_map\u0026lt;string,int\u0026gt; depth; queue\u0026lt;string \u0026gt; q; q.push(start); unordered_map\u0026lt;string,bool\u0026gt; allow; for(auto \u0026amp;u:bank) { allow[u] = true; } depth[start] = 0; while(q.size()) { string f = q.front(); q.pop(); for (int i=0;i\u0026lt;8;i++) { for (int j=0;j\u0026lt;4;j++) { string ns = f; ns[i] = gene[j]; if (depth.count(ns)) continue; //重复状态 if (allow.count(ns)) { if (ns == end) { return depth[f]+1; } allow.erase(ns); depth[ns] = depth[f]+1; q.push(ns); } } } } return -1; } }; ","date":"2022-09-09T23:14:16+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/lc.443.%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96/","tags":["最短路径问题"],"title":"lc.443.最小基因变化"},{"categories":["并查集"],"contents":" 1202. 交换字符串中的元素 Description Difficulty: 中等\nRelated Topics: 深度优先搜索 , 广度优先搜索 , 并查集 , 哈希表 , 字符串 给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。\n你可以 任意多次交换 在 pairs 中任意一对索引处的字符。\n返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。\n示例 1:\n1 2 3 4 5 输入：s = \u0026#34;dcab\u0026#34;, pairs = [[0,3],[1,2]] 输出：\u0026#34;bacd\u0026#34; 解释： 交换 s[0] 和 s[3], s = \u0026#34;bcad\u0026#34; 交换 s[1] 和 s[2], s = \u0026#34;bacd\u0026#34; 示例 2：\n1 2 3 4 5 6 输入：s = \u0026#34;dcab\u0026#34;, pairs = [[0,3],[1,2],[0,2]] 输出：\u0026#34;abcd\u0026#34; 解释： 交换 s[0] 和 s[3], s = \u0026#34;bcad\u0026#34; 交换 s[0] 和 s[2], s = \u0026#34;acbd\u0026#34; 交换 s[1] 和 s[2], s = \u0026#34;abcd\u0026#34; 示例 3：\n1 2 3 4 5 6 输入：s = \u0026#34;cba\u0026#34;, pairs = [[0,1],[1,2]] 输出：\u0026#34;abc\u0026#34; 解释： 交换 s[0] 和 s[1], s = \u0026#34;bca\u0026#34; 交换 s[1] 和 s[2], s = \u0026#34;bac\u0026#34; 交换 s[0] 和 s[1], s = \u0026#34;abc\u0026#34; 提示：\n1 \u0026lt;= s.length \u0026lt;= 10^5 0 \u0026lt;= pairs.length \u0026lt;= 10^5 0 \u0026lt;= pairs[i][0], pairs[i][1] \u0026lt; s.length s 中只含有小写英文字母 Solution Language: C++\n解题思路 假设 0,1 可以互换，1,3可以互换，那么 0,1,3 都是连通的，可以互换，题目说可以任意次互换，于是考虑并查集加小顶堆，小顶堆对字符排序就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public: string smallestStringWithSwaps(string s, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; pairs) { // string temp = p; int n = s.size(); int m = pairs.size(); init(n); priority_queue\u0026lt;char,vector\u0026lt;char\u0026gt;,greater\u0026lt;char\u0026gt; \u0026gt; q[n];// 对字符排序 for (int i=0;i\u0026lt;m;i++) { auto temp = pairs[i]; merge(temp[0],temp[1]); } for (int i=0;i\u0026lt;n;i++) { q[find(i)].push(s[i]); } string res; for (int i=0;i\u0026lt;n;i++) { res.push_back(q[find(i)].top()); q[find(i)].pop(); } return res; } vector\u0026lt;int\u0026gt; p; void init(int n) { p.resize(n); for (int i=0;i\u0026lt;n;i++) p[i] = i; } int find(int x) { if (x!=p[x]) p[x] = find(p[x]); return p[x]; } void merge(int a,int b) { p[find(a)] = find(b); } }; ","date":"2022-09-07T23:23:24+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/lc.1202.%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/","tags":["并查集"],"title":"lc.1202.交换字符串中的元素"},{"categories":["并查集"],"contents":" 947. 移除最多的同行或同列石头 Description Difficulty: 中等\nRelated Topics: 深度优先搜索 , 并查集 , 图 n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。\n如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。\n给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] 输出：5 解释：一种移除 5 块石头的方法如下所示： 1\\. 移除石头 [2,2] ，因为它和 [2,1] 同行。 2\\. 移除石头 [2,1] ，因为它和 [0,1] 同列。 3\\. 移除石头 [1,2] ，因为它和 [1,0] 同行。 4\\. 移除石头 [1,0] ，因为它和 [0,0] 同列。 5\\. 移除石头 [0,1] ，因为它和 [0,0] 同行。 石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。 示例 2：\n1 2 3 4 5 6 7 输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]] 输出：3 解释：一种移除 3 块石头的方法如下所示： 1\\. 移除石头 [2,2] ，因为它和 [2,0] 同行。 2\\. 移除石头 [2,0] ，因为它和 [0,0] 同列。 3\\. 移除石头 [0,2] ，因为它和 [0,0] 同行。 石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。 示例 3：\n1 2 3 输入：stones = [[0,0]] 输出：0 解释：[0,0] 是平面上唯一一块石头，所以不可以移除它。 提示：\n1 \u0026lt;= stones.length \u0026lt;= 1000 0 \u0026lt;= xi, yi \u0026lt;= 104 不会有两块石头放在同一个坐标点上 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public: int removeStones(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; stones) { int n = stones.size(); init(n); unordered_map\u0026lt;int,int\u0026gt; row; unordered_map\u0026lt;int,int \u0026gt; col; for (int i=0;i\u0026lt;n;i++) { auto item = stones[i]; int x = item[0],y = item[1]; // row[x].push_back(i); // col[y].push_back(i); if (row.count(x)) { merge(row[x],i); }else { row[x] = i; } if (col.count(y)) { merge(i,col[y]); }else { col[y] = i; } } int sz = 0; for (int i=0;i\u0026lt;n;i++) if(i == p[i]) //统计集合数目 sz++;//剩下的最小集合数目 return n - sz;//剩下集合最小，移除的最多 } vector\u0026lt;int\u0026gt; p; void init(int n) { p.resize(n); for (int i=0;i\u0026lt;n;i++) p[i] = i; } int find(int x) { if(x!=p[x]) p[x] = find(p[x]); return p[x]; } void merge(int a,int b) { p[find(a)] = find(b); } }; ","date":"2022-09-07T23:07:15+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/lc.947.%E7%A7%BB%E9%99%A4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%90%8C%E8%A1%8C%E6%88%96%E5%90%8C%E5%88%97%E7%9F%B3%E5%A4%B4/","tags":["并查集"],"title":"lc.947.移除最多的同行或同列石头"},{"categories":["并查集"],"contents":" 128. 最长连续序列 Description Difficulty: 中等\nRelated Topics: 并查集 , 数组 , 哈希表 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n请你设计并实现时间复杂度为 O(n)的算法解决此问题。\n示例 1：\n1 2 3 输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 示例 2：\n1 2 输入：nums = [0,3,7,2,5,8,4,6,0,1] 输出：9 提示：\n0 \u0026lt;= nums.length \u0026lt;= 105 -109 \u0026lt;= nums[i] \u0026lt;= 109 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Solution { public: int longestConsecutive(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); sz.resize(n); p.resize(n); unordered_map\u0026lt;int,int\u0026gt; mp; #define pos(i) mp[i] for (int i=0;i\u0026lt;n;i++) { // mp[nums[i]] = i; p[i] = i; sz[i] = 1; } for (int i=0;i\u0026lt;n;i++) { int x = nums[i]; if (mp.count(x)) { //重复元素只会记录第一个下标，以第一个为标准 // mp[x] = i; continue; } mp[x] = i; if(mp.count(x-1)) { merge( i , pos(x-1)); } if(mp.count(x+1)) { merge( i, pos(x+1)); } } int ans = 0; for (int i=0;i\u0026lt;n;i++) { if (pos(nums[i]) == i \u0026amp;\u0026amp; sz[pos(nums[i])] \u0026gt; ans) ans = sz[pos(nums[i])]; // printf(\u0026#34;%d -- %d, lmax=%d\\n\u0026#34;,pos(nums[i]),nums[i],sz[pos(nums[i])]); } return ans; } vector\u0026lt;int\u0026gt; p; vector\u0026lt;int\u0026gt; sz; //用来存每个集合元素的个数 void merge(int a,int b) { // printf(\u0026#34;%d merge %d\\n\u0026#34;,a,b); if(a==b) return; a = find(a),b = find(b); if (a==b) { return; } sz[find(b)] += sz[find(a)]; // b为根节点 p[find(a)] = find(b); } int find(int x) { if (x!=p[x]) p[x] = find(p[x]); return p[x]; } }; ","date":"2022-09-07T22:35:33+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/lc.128.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/","tags":["并查集"],"title":"lc.128.最长连续序列"},{"categories":["并查集"],"contents":" 1319. 连通网络的操作次数 Description Difficulty: 中等\nRelated Topics: 深度优先搜索 , 广度优先搜索 , 并查集 , 图 用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。\n网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。\n给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。\n示例 1：\n1 2 3 输入：n = 4, connections = [[0,1],[0,2],[1,2]] 输出：1 解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。 示例 2：\n1 2 输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]] 输出：2 示例 3：\n1 2 3 输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2]] 输出：-1 解释：线缆数量不足。 示例 4：\n1 2 输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]] 输出：0 提示：\n1 \u0026lt;= n \u0026lt;= 10^5 1 \u0026lt;= connections.length \u0026lt;= min(n*(n-1)/2, 10^5) connections[i].length == 2 0 \u0026lt;= connections[i][0], connections[i][1] \u0026lt; n connections[i][0] != connections[i][1] 没有重复的连接。 两台计算机不会通过多条线缆连接。 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: int makeConnected(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; connections) { if (connections.size() \u0026lt; n-1) return -1; p.resize(n+1); for (int i=0;i\u0026lt;n;i++) p[i] = i; for (auto temp: connections) { int a = temp[0],b = temp[1]; merge(a,b); } int cnt = 0; for (int i=0;i\u0026lt;n;i++) { if(p[i] == i) { cnt++; } } return cnt-1; } vector\u0026lt;int\u0026gt; p; int find(int x) { if(p[x]!=x) p[x] = find(p[x]); return p[x]; } void merge(int a,int b) { p[find(a)] = find(b); } }; ","date":"2022-09-07T21:26:50+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/lc.1319.%E8%BF%9E%E9%80%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","tags":["并查集"],"title":"lc.1319.连通网络的操作次数"},{"categories":["并查集"],"contents":" 990. 等式方程的可满足性 Description Difficulty: 中等\nRelated Topics: 并查集 , 图 , 数组 , 字符串 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：\u0026quot;a==b\u0026quot; 或 \u0026quot;a!=b\u0026quot;。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。\n只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。\n示例 1：\n1 2 3 输入：[\u0026#34;a==b\u0026#34;,\u0026#34;b!=a\u0026#34;] 输出：false 解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。 示例 2：\n1 2 3 输入：[\u0026#34;b==a\u0026#34;,\u0026#34;a==b\u0026#34;] 输出：true 解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。 示例 3：\n1 2 输入：[\u0026#34;a==b\u0026#34;,\u0026#34;b==c\u0026#34;,\u0026#34;a==c\u0026#34;] 输出：true 示例 4：\n1 2 输入：[\u0026#34;a==b\u0026#34;,\u0026#34;b!=c\u0026#34;,\u0026#34;c==a\u0026#34;] 输出：false 示例 5：\n1 2 输入：[\u0026#34;c==c\u0026#34;,\u0026#34;b==d\u0026#34;,\u0026#34;x!=z\u0026#34;] 输出：true 提示：\n1 \u0026lt;= equations.length \u0026lt;= 500 equations[i].length == 4 equations[i][0] 和 equations[i][3] 是小写字母 equations[i][1] 要么是 '='，要么是 '!' equations[i][2] 是 '=' Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class Solution { public: bool equationsPossible(vector\u0026lt;string\u0026gt;\u0026amp; equations) { vector\u0026lt;int\u0026gt; temp; #define pos(u) (u-\u0026#39;a\u0026#39;) p.resize(26); for (int i=0;i\u0026lt;26;i++) p[i] = i; int n = equations.size(); for (int i=0;i\u0026lt;n;i++) { auto expr = scanx(equations[i]); if(expr[0] == \u0026#39;!\u0026#39;) { // temp.push_back(expr); temp.push_back(i); continue; } int a = pos(expr[1]); int b = pos(expr[2]); merge(a,b); } n = temp.size(); for (int i=0;i\u0026lt;n;i++) { // auto expr = temp[i]; int a = find(pos( equations[temp[i]][3] )); int b = find(pos( equations[temp[i]][0] )); //!= if(a==b) { return false; } } return true; } vector\u0026lt;char\u0026gt; scanx(string s) { char a = s[0]; char b = s[3]; char op = s[1]; return {op,a,b}; } vector\u0026lt;int\u0026gt; p; int find(int x) { if(x!=p[x]) p[x] = find(p[x]); return p[x]; } void merge(int a,int b) { p[find(a)] = find(b); } }; ","date":"2022-09-07T21:03:41+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/lc.990.%E7%AD%89%E5%BC%8F%E6%96%B9%E7%A8%8B%E7%9A%84%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7/","tags":["并查集"],"title":"lc.990.等式方程的可满足性"},{"categories":["并查集"],"contents":" 200. 岛屿数量 Description Difficulty: 中等\nRelated Topics: 深度优先搜索 , 广度优先搜索 , 并查集 , 数组 , 矩阵 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。\n岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\n此外，你可以假设该网格的四条边均被水包围。\n示例 1：\n1 2 3 4 5 6 7 输入：grid = [ [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;] ] 输出：1 示例 2：\n1 2 3 4 5 6 7 输入：grid = [ [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;] ] 输出：3 提示：\nm == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 300 grid[i][j] 的值为 '0' 或 '1' Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public: int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(); if(n\u0026lt;=0) return 0; int m = grid[0].size(); int cnt = m*n; if (cnt == 0) return 0; p.resize(cnt+1); for (int i=0;i\u0026lt;cnt;i++) p[i] = i; #define pos(i,j) (i*m+j) for (int i=0;i\u0026lt;n;i++) for (int j=0;j\u0026lt;m;j++) { if(grid[i][j] == \u0026#39;0\u0026#39;) continue; if(i \u0026gt; 0 \u0026amp;\u0026amp; grid[i-1][j] == \u0026#39;1\u0026#39;) merge(pos((i-1),j),pos(i,j)); if(j \u0026gt; 0 \u0026amp;\u0026amp; grid[i][j-1] == \u0026#39;1\u0026#39;) merge(pos(i,j),pos(i,j-1)); } int res = 0; for (int i=0;i\u0026lt;n;i++) for (int j=0;j\u0026lt;m;j++) { if(grid[i][j] == \u0026#39;1\u0026#39;) if(p[pos(i,j)] == pos(i,j)) res++; } return res; } vector\u0026lt;int\u0026gt; p; int find(int x) { if(x != p[x]) p[x] = find(p[x]); return p[x]; } void merge(int a,int b) { p[find(a)] = find(b); } }; 其他解题思路 这个题可以用 flood fill 算法，从一个点触发去染色，将相邻的 1 染为0， 然后岛屿的数量+1， 最后整个岛屿的全部都是0 的时候，就可以计算出岛屿的数量。\n","date":"2022-09-07T20:46:22+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/","tags":["并查集"],"title":"岛屿数量"},{"categories":["并查集"],"contents":" 547. 省份数量 Description Difficulty: 中等\nRelated Topics: 深度优先搜索 , 广度优先搜索 , 并查集 , 图 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。\n省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。\n给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。\n返回矩阵中 省份 的数量。\n示例 1：\n1 2 输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]] 输出：2 示例 2：\n1 2 输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]] 输出：3 提示：\n1 \u0026lt;= n \u0026lt;= 200 n == isConnected.length n == isConnected[i].length isConnected[i][j] 为 1 或 0 isConnected[i][i] == 1 isConnected[i][j] == isConnected[j][i] Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: vector\u0026lt;int\u0026gt; p; int findCircleNum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; isConnected) { int n = isConnected.size(); p.resize(n+1); for (int i=0;i\u0026lt;=n;i++) p[i] = i; for (int i=0;i\u0026lt;n;i++) { for (int j=0;j\u0026lt;i;j++) { if (isConnected[i][j]) { // merge merge(i,j); } } } int cnt = 0; for (int i=0;i\u0026lt;n;i++) { if(p[i] == i) cnt++; } return cnt; } int find(int x) { if(p[x] != x) { p[x] = find(p[x]); } return p[x]; } void merge(int a,int b) { int u = find(a); int v = find(b); p[u] = v; } }; ","date":"2022-09-07T20:20:24+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/lc.547.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/","tags":["并查集"],"title":"lc.547.省份数量"},{"categories":["数据结构"],"contents":"连通性问题 连通性问题的性质： 传递性， a和b联通，b和c联通，那么 a和 c联通。\nquick find 算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; // void destroy() { // delete []color; // } vector\u0026lt;int\u0026gt; color; int n; //o(1) 时间复杂度返回 int find(int x) { return color[x]; } // o(N) 时间复杂度 merge void merge(int a,int b) { int cb = color[b]; for (int i=0;i\u0026lt;=n;i++) { if(color[i] == cb) color[i] = color[a]; } return; } quick find 使用的是染色法【将两个节点的颜色染成一样的】\nquick union 算法 quick union 利用了树形结构，通过一个数组去记录每个节点的根节点的编号。\n按秩优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class UnionSet { vector\u0026lt;int\u0026gt; father,size; int n; UnionSet(int n) : n(n) { father.resize(n + 1); size.resize(n+1); for (int i = 0; i \u0026lt;= n; i++) { father[i] = i; size[i]= 1; } } void merge(int a, int b) { int aroot = find(a); int broot = find(b); if (aroot == broot) return; if (size[aroot] \u0026lt; size[broot]\u0026gt;) { //b 节点多 father[aroot] = broot; size[broot] += size[aroot]; }else { father[broot] = aroot; size[aroot] += size[broot]; } // father[aroot] = broot; } int find(int a) { // return father[a];/ int boss = father[a]; //自己就是自己的老板，自己就是根节点 if (a == boss) { return a; } return find(boss); } }; 通过 size 进行按秩优化，谁的节点数量多，谁将成为为根节点。\n这么做的原因:\n由于树越高，极端情况下会退化成一条链表 将节点数量多的树接到少的树上面，导致退化 将树高深的接到浅的上面，导致退化。 路径压缩优化 【quick union】 在 find上面优化\n1 2 3 4 5 6 7 8 int find(int x) { if(fa[x] == x) return x; int finalRoot = find(fa[x]); //只会记录根节点 fa[x] = finalRoot; return finalRoot; } ","date":"2022-09-05T21:53:06+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98/","tags":["数据结构"],"title":"连通性问题"},{"categories":["图"],"contents":" 684. 冗余连接 Description Difficulty: 中等\nRelated Topics: 深度优先搜索 , 广度优先搜索 , 并查集 , 图 树可以看成是一个连通且 无环的 无向图。\n给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] = [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。\n请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的边。\n示例 1：\n1 2 输入: edges = [[1,2], [1,3], [2,3]] 输出: [2,3] 示例 2：\n1 2 输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]] 输出: [1,4] 提示:\nn == edges.length 3 \u0026lt;= n \u0026lt;= 1000 edges[i].length == 2 1 \u0026lt;= ai \u0026lt; bi \u0026lt;= edges.length ai != bi edges 中无重复元素 给定的图是连通的 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public: vector\u0026lt;int\u0026gt; findRedundantConnection(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { // int n = edges.size(); int n = 0; for (auto xx: edges) { n = max(xx[0],max(xx[1],n)); } edges_.resize(n+1); for (auto xx: edges) { int a = xx[0],b = xx[1]; addEdge(a,b); addEdge(b,a); for (int i=0;i\u0026lt;=n;i++) node_status[i] = 0; dfs(a,b); if(has_cycle) return xx; } return {}; } unordered_map\u0026lt;int,int\u0026gt; node_status; bool has_cycle = false; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; edges_; void addEdge(int a,int b) { edges_[a].push_back(b); } void dfs (int x ,int father) { node_status[x] = 1; for (int y: edges_[x]) { if (y == father) continue; if(node_status[y]) { has_cycle = true; }else { dfs(y,x); } } node_status[x] = 0; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: vector\u0026lt;int\u0026gt; findRedundantConnection(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { int n = edges.size(); p.resize(n+1); for (int i=0;i\u0026lt;n;i++) p[i] = i; for (auto temp: edges) { int a = temp[0]; int b = temp[1]; a = find(a),b = find(b); if (a==b) return temp; merge(a,b); } return {}; } vector\u0026lt;int\u0026gt; p; int find(int x) { if(x!=p[x]) p[x] = find(p[x]); return p[x]; } void merge(int a,int b) { p[find(a)] = find(b); } }; 并查集 ","date":"2022-09-04T23:09:36+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/lc.684.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/","tags":["图"],"title":"lc.684.冗余连接"},{"categories":["图"],"contents":" 207. 课程表 Description Difficulty: 中等\nRelated Topics: 深度优先搜索 , 广度优先搜索 , 图 , 拓扑排序 你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。\n在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程 bi。\n例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。 请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。\n示例 1：\n1 2 3 输入：numCourses = 2, prerequisites = [[1,0]] 输出：true 解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。 示例 2：\n1 2 3 输入：numCourses = 2, prerequisites = [[1,0],[0,1]] 输出：false 解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。 提示：\n1 \u0026lt;= numCourses \u0026lt;= 105 0 \u0026lt;= prerequisites.length \u0026lt;= 5000 prerequisites[i].length == 2 0 \u0026lt;= ai, bi \u0026lt; numCourses prerequisites[i] 中的所有课程对 互不相同 Solution Language: C++\n解法一： 拓扑排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: bool canFinish(int numCourses, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; prerequisites) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; edges(numCourses,vector\u0026lt;int\u0026gt; ()); vector\u0026lt;int\u0026gt; indeg(numCourses,0); for (auto arr: prerequisites) { addEdge(arr[1],arr[0],edges,indeg); } return topsort(numCourses,edges,indeg); } void addEdge(int a,int b, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;edges,vector\u0026lt;int\u0026gt;\u0026amp; indeg) { indeg[b] ++; edges[a].push_back(b); } bool topsort(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp; edges,vector\u0026lt;int\u0026gt;\u0026amp; indeg) { queue\u0026lt;int \u0026gt; q; for (int i=0;i\u0026lt;n;i++) { if(indeg[i] == 0) q.push(i); } int classes = 0; while(q.size()) { int x = q.front();q.pop(); classes++; for (int v: edges[x]) { indeg[v]--; if (indeg[v] ==0) q.push(v); } } return classes == n; } }; 解法二： dfs判环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: bool canFinish(int numCourses, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; prerequisites) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; edges(numCourses,vector\u0026lt;int\u0026gt; ()); // vector\u0026lt;int\u0026gt; indeg(numCourses,0); for (auto arr: prerequisites) { // addEdge(arr[1],arr[0],edges); edges[arr[1]].push_back(arr[0]); } node_status.resize(numCourses); // dfs(numCourses,edges,indeg); for (int i=0;i\u0026lt;numCourses \u0026amp;\u0026amp; status;i++) { if(node_status[i] == 0) dfs(i,numCourses,edges); } return status; } vector\u0026lt;int\u0026gt; node_status; bool status = true; void dfs(int i,int n ,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { node_status[i] = 1; for (int next : edges[i]) { if (node_status[next] == 0) { dfs(next,n,edges); if(!status) return; }else if (node_status[next] == 1) { //visiting // dfs(next,n,edges); status = false; return; } } node_status[i] = 2; } }; ","date":"2022-09-04T22:25:58+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/lc.207.%E8%AF%BE%E7%A8%8B%E8%A1%A8/","tags":["图"],"title":"lc.207.课程表"},{"categories":["树"],"contents":" 236. 二叉树的最近公共祖先 Description Difficulty: 中等\nRelated Topics: 树 , 深度优先搜索 , 二叉树 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n百度百科 中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n示例 1：\n1 2 3 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 示例 2：\n1 2 3 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 示例 3：\n1 2 输入：root = [1,2], p = 1, q = 2 输出：1 提示：\n树中节点数目在范围 [2, 105] 内。 -109 \u0026lt;= Node.val \u0026lt;= 109 所有 Node.val 互不相同 。 p != q p 和 q 均存在于给定的二叉树中。 思路解析 使用向上标记法， 有 a,b 两个节点，a从下面往上面染色， 染完根节点之后，再从b出发往上走，走到第一个染色节点，这个节点就是 a,b两个节点的 LCA\n因为标记的时候每个节点只会走一次，时间复杂度是 $O(N)$\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ #define Node TreeNode class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { unordered_map\u0026lt;int,Node*\u0026gt;mp; mark(mp,root,NULL); remove_mark(mp,p); return get_no_mark(mp,q); } Node* get_no_mark(unordered_map\u0026lt;int,Node*\u0026gt; \u0026amp;mp,TreeNode *q) { if(q==NULL || !mp.count(q-\u0026gt;val)) { return q; } Node *parent = mp[q-\u0026gt;val]; if(parent == NULL) return q; return get_no_mark(mp,parent); } void remove_mark(unordered_map\u0026lt;int,Node*\u0026gt; \u0026amp;mp, TreeNode *p) { if(p==NULL) return; Node* parent = mp[p-\u0026gt;val]; mp.erase(p-\u0026gt;val); if(parent) remove_mark(mp,parent); } void mark(unordered_map\u0026lt;int,Node*\u0026gt; \u0026amp;mp, TreeNode*p,TreeNode*parent) { if(p == NULL) return ; mp[p-\u0026gt;val] = parent; if(p-\u0026gt;left) mark(mp,p-\u0026gt;left,p); if(p-\u0026gt;right) mark(mp,p-\u0026gt;right,p); } }; 迭代法染色 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ #define Node TreeNode class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(p==NULL || q == NULL||root==NULL) return root; unordered_map\u0026lt;int,Node*\u0026gt;mp; Node dummy(0); mark(mp,root,\u0026amp;dummy); // remove_mark(mp,p); // return get_no_mark(mp,q); unordered_map\u0026lt;int,Node*\u0026gt; redNodes; redNodes[root-\u0026gt;val] = root; while( p-\u0026gt;val!=root-\u0026gt;val) { redNodes[p-\u0026gt;val] = p; p = mp[p-\u0026gt;val]; if(p==NULL) break; } while(!redNodes.count(q-\u0026gt;val)) { q = mp[q-\u0026gt;val]; } return q; } Node* get_no_mark(unordered_map\u0026lt;int,Node*\u0026gt; \u0026amp;mp,TreeNode *q) { if(q==NULL || !mp.count(q-\u0026gt;val)) { return q; } Node *parent = mp[q-\u0026gt;val]; if(parent == NULL) return q; return get_no_mark(mp,parent); } void remove_mark(unordered_map\u0026lt;int,Node*\u0026gt; \u0026amp;mp, TreeNode *p) { if(p==NULL) return; Node* parent = mp[p-\u0026gt;val]; mp.erase(p-\u0026gt;val); if(parent) remove_mark(mp,parent); } void mark(unordered_map\u0026lt;int,Node*\u0026gt; \u0026amp;mp, TreeNode*p,TreeNode*parent) { if(p == NULL) return ; mp[p-\u0026gt;val] = parent; if(p-\u0026gt;left) mark(mp,p-\u0026gt;left,p); if(p-\u0026gt;right) mark(mp,p-\u0026gt;right,p); } }; ","date":"2022-09-04T21:50:25+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/lc.232.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","tags":["树"],"title":"lc.232.二叉树的最近公共祖先"},{"categories":["树"],"contents":" 105. 从前序与中序遍历序列构造二叉树 Description Difficulty: 中等\nRelated Topics: 树 , 数组 , 哈希表 , 分治 , 二叉树 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。\n示例 1:\n1 2 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] 输出: [3,9,20,null,null,15,7] 示例 2:\n1 2 输入: preorder = [-1], inorder = [-1] 输出: [-1] 提示:\n1 \u0026lt;= preorder.length \u0026lt;= 3000 inorder.length == preorder.length -3000 \u0026lt;= preorder[i], inorder[i] \u0026lt;= 3000 preorder 和 inorder 均 无重复 元素 inorder 均出现在 preorder preorder 保证 为二叉树的前序遍历序列 inorder 保证 为二叉树的中序遍历序列 解题思路 [3,|9|,20,15,7] \u0026ndash;\u0026gt; 知道 3是 root， 通过中序遍历 我们可以知道两边都有哪些节点，哪些节点分别属于左右哪些子树\n[9,|3|,15,20,7]\n思路就是：\n先序序列告诉我们谁是根， 中序序列帮我们确立左右子树的分界线。\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #define Node TreeNode #define V vector\u0026lt;int\u0026gt; class Solution { public: TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder) { int n = preorder.size(); int m = inorder.size(); if (n!=m || n == 0) return NULL; return help(preorder,inorder,0,n-1,0,n-1); } Node* help(V \u0026amp;preor, V \u0026amp;inor, int pl,int pr,int il,int ir) { if(pl\u0026gt;pr) return NULL; if(pl==pr) { return new Node(preor[pl]); } int iroot=0; for (int i=il;i\u0026lt;=ir;i++) { if(inor[i] == preor[pl]) { //is root iroot = i; break; } } Node *root = new Node(inor[iroot]); int leftCount = iroot-il; int rightCount = ir - iroot; root-\u0026gt;left = help(preor,inor,pl+1,pl+leftCount,il,iroot-1); root-\u0026gt;right = help(preor,inor,pl+leftCount+1, pr,iroot+1,ir); return root; } }; ","date":"2022-09-04T21:36:10+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/lc.105.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":["树"],"title":"lc.105.重建二叉树"},{"categories":["树"],"contents":"二叉树的最大宽度 662. 二叉树最大宽度 Description Difficulty: 中等\nRelated Topics: 树 , 深度优先搜索 , 广度优先搜索 , 二叉树 给你一棵二叉树的根节点 root ，返回树的 最大宽度 。\n树的 最大宽度 是所有层中最大的 宽度 。\n每一层的 宽度 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 null 节点，这些 null 节点也计入长度。\n题目数据保证答案将会在 32 位 带符号整数范围内。\n示例 1：\n1 2 3 输入：root = [1,3,2,5,3,null,9] 输出：4 解释：最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。 示例 2：\n1 2 3 输入：root = [1,3,2,5,null,null,9,6,null,7] 输出：7 解释：最大宽度出现在树的第 4 层，宽度为 7 (6,null,null,null,null,null,7) 。 示例 3：\n1 2 3 输入：root = [1,3,2,5] 输出：2 解释：最大宽度出现在树的第 2 层，宽度为 2 (3,2) 。 提示：\n树中节点的数目范围是 [1, 3000] -100 \u0026lt;= Node.val \u0026lt;= 100 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #define Node TreeNode #define PNI pair\u0026lt;Node*,unsigned long long\u0026gt; class Solution { public: int widthOfBinaryTree(TreeNode* root) { if(root == NULL) return 0; queue\u0026lt;PNI\u0026gt; q; q.push({root,0}); unsigned long long max_width = 0; while(q.size()) { int cnt = q.size(); unsigned long long l = q.front().second, r = q.front().second; for (int i=0;i\u0026lt;cnt;i++) { PNI data = q.front(); TreeNode *x = data.first; unsigned long long no = data.second; r = max(r,no); if(x-\u0026gt;left) q.push(PNI(x-\u0026gt;left,no*2)); if(x-\u0026gt;right) q.push(PNI(x-\u0026gt;right,no*2+1)); q.pop(); } max_width = max(max_width,r-l+1); } return max_width; } }; 缩减下标 由于 一直乘2 会溢出，这里可以减去上一层的最小编号，可以缩小编号的范围。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #define Node TreeNode #define PNI pair\u0026lt;Node*,int\u0026gt; class Solution { public: int widthOfBinaryTree(TreeNode* root) { if(root == NULL) return 0; queue\u0026lt;PNI\u0026gt; q; q.push({root,0}); unsigned int max_width = 0; while(q.size()) { int cnt = q.size(); unsigned int l = q.front().second, r = q.front().second; for (int i=0;i\u0026lt;cnt;i++) { PNI data = q.front(); TreeNode *x = data.first; unsigned int no = data.second; r = no; if(x-\u0026gt;left) q.push(PNI(x-\u0026gt;left,(no-l)*2)); if(x-\u0026gt;right) q.push(PNI(x-\u0026gt;right,(no-l)*2+1)); q.pop(); } max_width = max(max_width,r-l+1); } return max_width; } }; ","date":"2022-09-04T21:13:26+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/lc.662.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/","tags":["树"],"title":"lc.662.二叉树的最大宽度"},{"categories":["树"],"contents":" 968. 监控二叉树 Description Difficulty: 困难\nRelated Topics: 树 , 深度优先搜索 , 动态规划 , 二叉树 给定一个二叉树，我们在树的节点上安装摄像头。\n节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。\n计算监控树的所有节点所需的最小摄像头数量。\n示例 1：\n1 2 3 输入：[0,0,null,0,0] 输出：1 解释：如图所示，一台摄像头足以监控所有节点。 示例 2：\n1 2 3 输入：[0,0,null,0,null,0,null,null,0] 输出：2 解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。 提示：\n给定树的节点数的范围是 [1, 1000]。 每个节点的值都是 0。 dp状态思路解析 dp[i][j] 表示当前节点不放 最少放摄像头的数量\ni=1 表示父节点放，0表示父节点不放\nj=1 表示当前节点放，0表示不放\n这样就可以列出当前节点和父亲节点的 4种状态。\n状态表达式：\n当前节点不放 dp[0][0] = min ( [左放，右不放], [左不放，右放],[左右都放] )\n这个表达式 覆盖了左右节点和当前节点\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int minCameraCover(TreeNode* root) { //本节点不放置摄像头可否最少？放摄像头可否最少？ 动态规划问题！！ [1, 1000]， //dp[n][k] = min(dp[n][0],dp[n][1]) int dp[2][2]; getDp(root,dp); return min(dp[0][1],dp[0][0]); } #define min3(i,j,k) (min(i,min(j,k))) void getDp(TreeNode * root, int dp[2][2]) { if(!root) { dp[0][0] = 0; //父节点不放，当前节点不放 dp[0][1] = 10000;//父节点不放，当前节点放 dp[1][0] = 0; //父节点放，当前不放 dp[1][1] = 10000; return; } if(root-\u0026gt;left==NULL \u0026amp;\u0026amp; root-\u0026gt;right==NULL) { dp[0][0] = 10000;// 父节点不放，当前节点不放 dp[0][1] = 1;//父节点不放，当前节点放 dp[1][0] = 0; dp[1][1] = 1;//父节点放不放不影响当前数量 } int l[2][2],r[2][2]; getDp(root-\u0026gt;left,l); getDp(root-\u0026gt;right,r); dp[0][0] = min3(l[0][1] + r[0][0],l[0][0]+r[0][1],l[0][1]+r[0][1]); dp[1][0] = min(dp[0][0],l[0][0] + r[0][0]);//父节点放，当前不放 dp[0][1] = min(dp[0][0],l[0][0] + r[0][0]) + 1; dp[0][1] = min(min(l[1][0] + r[1][0],l[1][1]+r[1][1]) , min(l[1][0] + r[1][1],l[1][1]+r[1][0])) + 1; dp[1][1] = dp[0][1];//父节点不放，当前节点放 } }; ","date":"2022-09-04T20:35:38+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/lc.968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":["树"],"title":"lc.968.监控二叉树"},{"categories":["树"],"contents":"树的作用 完全二叉树，堆，优先队列\u0026ndash; 维护集合最值 多叉树，森林， 字典树，ac自动机，并查集，\u0026mdash; 字符串转换问题，连通性问题 二叉排序树： AVL树，2-3数，红黑树 语言标准库中重要的数据检索容器实现 b+树， 文件系统、数据库底层数据结构 左孩子右兄弟表示法节省空间 1 2 3 4 5 typedef struct ForestNode { int data; struct ForestNode *lchild, *rbrother; } ForestNode, *ForestHead; 任意的多叉树其实都可以转为二叉树，二叉树可以节省空间。\n","date":"2022-09-04T20:04:52+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E4%BD%9C%E7%94%A8/","tags":["树"],"title":"树的作用"},{"categories":["栈"],"contents":" 1124. 表现良好的最长时间段 Description Difficulty: 中等\nRelated Topics: 栈 , 数组 , 哈希表 , 前缀和 , 单调栈 给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。\n我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。\n所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。\n请你返回「表现良好时间段」的最大长度。\n示例 1：\n1 2 3 输入：hours = [9,9,6,0,6,6,9] 输出：3 解释：最长的表现良好时间段是 [9,9,6]。 示例 2：\n1 2 输入：hours = [6,6,6] 输出：0 提示：\n1 \u0026lt;= hours.length \u0026lt;= 104 0 \u0026lt;= hours[i] \u0026lt;= 16 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int longestWPI(vector\u0026lt;int\u0026gt;\u0026amp; hours) { int n = hours.size(); int ans = 0; unordered_map\u0026lt;int,int\u0026gt; mp; int sum = 0; for (int i=0;i\u0026lt;n;i++) { if (hours[i] \u0026gt; 8) sum++; else sum--; if(!mp.count(sum)) mp[sum] = i; if (sum \u0026gt; 0) ans = i+1; // 0 到 i 都是 绩效满分的日子啊。。。。 else { //sum \u0026lt; 0 , current - (current-1) \u0026gt; 0 if(mp.count(sum-1)) ans = max(ans,i - mp[sum-1]); } } return ans; } }; ","date":"2022-09-03T22:25:41+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/lc.1124.%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%AE%B5/","tags":["栈"],"title":"lc.1124.表现良好的最长时间段"},{"categories":["栈"],"contents":" 636. 函数的独占时间 Description Difficulty: 中等\nRelated Topics: 栈 , 数组 有一个 单线程 CPU 正在运行一个含有 n 道函数的程序。每道函数都有一个位于 0 和 n-1 之间的唯一标识符。\n函数调用 存储在一个 上 ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 当前正在执行的函数 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。\n给你一个由日志组成的列表 logs ，其中 logs[i] 表示第 i 条日志消息，该消息是一个按 \u0026quot;{function_id}:{\u0026quot;start\u0026quot; | \u0026quot;end\u0026quot;}:{timestamp}\u0026quot; 进行格式化的字符串。例如，\u0026quot;0:start:3\u0026quot; 意味着标识符为 0 的函数调用在时间戳 3 的 起始开始执行 ；而 \u0026quot;1🔚2\u0026quot; 意味着标识符为 1 的函数调用在时间戳 2 的 末尾结束执行。注意，函数可以 调用多次，可能存在递归调用 。\n函数的 独占时间 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 2 单位时间，另一次调用执行 1 单位时间，那么该函数的 独占时间 为 2 + 1 = 3 。\n以数组形式返回每个函数的 独占时间 ，其中第 i 个下标对应的值表示标识符 i 的函数的独占时间。\n示例 1：\n1 2 3 4 5 6 7 输入：n = 2, logs = [\u0026#34;0:start:0\u0026#34;,\u0026#34;1:start:2\u0026#34;,\u0026#34;1🔚5\u0026#34;,\u0026#34;0🔚6\u0026#34;] 输出：[3,4] 解释： 函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。 函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。 函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。 所以函数 0 总共执行 2 + 1 = 3 个单位时间，函数 1 总共执行 4 个单位时间。 示例 2：\n1 2 3 4 5 6 7 8 9 输入：n = 1, logs = [\u0026#34;0:start:0\u0026#34;,\u0026#34;0:start:2\u0026#34;,\u0026#34;0🔚5\u0026#34;,\u0026#34;0:start:6\u0026#34;,\u0026#34;0🔚6\u0026#34;,\u0026#34;0🔚7\u0026#34;] 输出：[8] 解释： 函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。 函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。 函数 0（初始调用）恢复执行，并立刻再次调用它自身。 函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。 函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。 所以函数 0 总共执行 2 + 4 + 1 + 1 = 8 个单位时间。 示例 3：\n1 2 3 4 5 6 7 8 9 输入：n = 2, logs = [\u0026#34;0:start:0\u0026#34;,\u0026#34;0:start:2\u0026#34;,\u0026#34;0🔚5\u0026#34;,\u0026#34;1:start:6\u0026#34;,\u0026#34;1🔚6\u0026#34;,\u0026#34;0🔚7\u0026#34;] 输出：[7,1] 解释： 函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。 函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。 函数 0（初始调用）恢复执行，并立刻调用函数 1 。 函数 1在时间戳 6 的起始开始执行，执行 1 个单位时间，于时间戳 6 的末尾结束执行。 函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间，于时间戳 7 的末尾结束执行。 所以函数 0 总共执行 2 + 4 + 1 = 7 个单位时间，函数 1 总共执行 1 个单位时间。 示例 4：\n1 2 输入：n = 2, logs = [\u0026#34;0:start:0\u0026#34;,\u0026#34;0:start:2\u0026#34;,\u0026#34;0🔚5\u0026#34;,\u0026#34;1:start:7\u0026#34;,\u0026#34;1🔚7\u0026#34;,\u0026#34;0🔚8\u0026#34;] 输出：[8,1] 示例 5：\n1 2 输入：n = 1, logs = [\u0026#34;0:start:0\u0026#34;,\u0026#34;0🔚0\u0026#34;] 输出：[1] 提示：\n1 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= logs.length \u0026lt;= 500 0 \u0026lt;= function_id \u0026lt; n 0 \u0026lt;= timestamp \u0026lt;= 109 两个开始事件不会在同一时间戳发生 两个结束事件不会在同一时间戳发生 每道函数都有一个对应 \u0026quot;start\u0026quot; 日志的 \u0026quot;end\u0026quot; 日志 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: vector\u0026lt;int\u0026gt; exclusiveTime(int n, vector\u0026lt;string\u0026gt;\u0026amp; logs) { vector\u0026lt;int\u0026gt; ans(n); stack\u0026lt;int\u0026gt; fid; for (int i=0,pre=0,n = logs.size();i\u0026lt;n;i++) { int pos1 = logs[i].find_first_of(\u0026#34;:\u0026#34;); int pos2 = logs[i].find_last_of(\u0026#34;:\u0026#34;); string id_str = logs[i].substr(0,pos1); string status = logs[i].substr(pos1+1,pos2-pos1-1); string t = logs[i].substr(pos2+1); int id = atoi(id_str.c_str()); int time = atoi(t.c_str()); if(status == \u0026#34;start\u0026#34;) { if(fid.size()) ans[fid.top()] += time - pre; pre = time; fid.push(id); }else { ans[id] += time - pre+1; pre = time + 1; fid.pop(); } } return ans; } }; ","date":"2022-09-03T21:06:09+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/lc.636.%E5%87%BD%E6%95%B0%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%97%B6%E9%97%B4/","tags":["栈"],"title":"lc.636.函数的独占时间"},{"categories":["栈"],"contents":" 227. 基本计算器 II Description Difficulty: 中等\nRelated Topics: 栈 , 数学 , 字符串 给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。\n整数除法仅保留整数部分。\n你可以假设给定的表达式总是有效的。所有中间结果将在 [-231, 231 - 1] 的范围内。\n**注意：**不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。\n示例 1：\n1 2 输入：s = \u0026#34;3+2*2\u0026#34; 输出：7 示例 2：\n1 2 输入：s = \u0026#34; 3/2 \u0026#34; 输出：1 示例 3：\n1 2 输入：s = \u0026#34; 3+5 / 2 \u0026#34; 输出：5 提示：\n1 \u0026lt;= s.length \u0026lt;= 3 * 105 s 由整数和算符 ('+', '-', '*', '/') 组成，中间由一些空格隔开 s 表示一个 有效表达式 表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内 题目数据保证答案是一个 32-bit 整数 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public: int calculate(string s) { return dfs(s,0,s.size()-1); } int dfs(string \u0026amp;s,int l,int r) { int pri= 10000-1, curr,index=-1; int bra = 0; for (int i=l;i\u0026lt;=r;i++) { curr = 10000; if(s[i] == \u0026#39;+\u0026#39; || s[i] == \u0026#39;-\u0026#39;) { curr = bra + 1; }else if(s[i] == \u0026#39;*\u0026#39; || s[i] == \u0026#39;/\u0026#39;) { curr = bra + 2; }else if(s[i] == \u0026#39;(\u0026#39;) { bra += 100; }else if(s[i] == \u0026#39;)\u0026#39;) { bra -= 100; } if (curr \u0026lt;= pri) { pri = curr; index = i; } } if(index == -1) { //no int u =0; for(int i=l;i\u0026lt;=r;i++) { if(s[i]\u0026gt;=\u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[i]\u0026lt;=\u0026#39;9\u0026#39;) u = u*10 + (s[i] - \u0026#39;0\u0026#39;); } return u; } int a = dfs(s,l,index-1); int b = dfs(s,index+1,r); //printf(\u0026#34;%d %c %d\\n\u0026#34;,a,s[index],b); if(s[index] == \u0026#39;+\u0026#39;) return a+b; if(s[index] == \u0026#39;-\u0026#39;) return a- b; if(s[index] == \u0026#39;*\u0026#39;) return a * b; if(s[index] == \u0026#39;/\u0026#39;) return a /b; return -1; } }; 基于双栈来实现 上面这种做法使用递归，卡到最后2个案例的时候超时了。这里用双栈速度才会快。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public: int level(char x) { if(x==\u0026#39;+\u0026#39; || x==\u0026#39;-\u0026#39;) return 1; else if (x==\u0026#39;*\u0026#39; || x==\u0026#39;/\u0026#39;) return 2; // if (x == \u0026#39;(\u0026#39;) // if(x\u0026gt;=\u0026#39;0\u0026#39; \u0026amp;\u0026amp; x\u0026lt;=\u0026#39;9\u0026#39;) return 0; if (x == \u0026#39;$\u0026#39;) return -1; return 0; } int calc(char x,int a,int b) { printf(\u0026#34;%d %c %d\\n\u0026#34;,a,x,b); if (x == \u0026#39;+\u0026#39;) return a+b; if (x==\u0026#39;-\u0026#39;) return a-b; if (x==\u0026#39;*\u0026#39;) return a*b; if (x==\u0026#39;/\u0026#39;) return a/b; return -1; } int calculate(string s) { stack\u0026lt;int\u0026gt; num; stack\u0026lt;char\u0026gt; ops; s += \u0026#39;$\u0026#39;; int n = s.size(); for (int i=0,u=0;i\u0026lt;n;i++) { if(s[i] == \u0026#39; \u0026#39;) continue; if (level(s[i]) == 0) { u = u*10 + (s[i] - \u0026#39;0\u0026#39;); continue; } num.push(u);//u is right num [left op right] u = 0; while(ops.size() \u0026amp;\u0026amp; level(s[i]) \u0026lt;= level(ops.top())) { //优先级小，先处理小优先级的 int b = num.top();num.pop(); int a = num.top();num.pop(); num.push(calc(ops.top(),a,b)); ops.pop(); } ops.push(s[i]); } return num.top(); } }; ","date":"2022-09-03T17:54:33+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/lc.227.%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8ii/","tags":["栈"],"title":"lc.227.基本计算器II"},{"categories":["栈"],"contents":" 331. 验证二叉树的前序序列化 Description Difficulty: 中等\nRelated Topics: 栈 , 树 , 字符串 , 二叉树 序列化二叉树的一种方法是使用 前序遍历 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。\n例如，上面的二叉树可以被序列化为字符串 \u0026quot;9,3,4,#,#,1,#,#,2,#,6,#,#\u0026quot;，其中 # 代表一个空节点。\n给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。\n保证 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 '#' 。\n你可以认为输入格式总是有效的\n例如它永远不会包含两个连续的逗号，比如 \u0026quot;1,,3\u0026quot; 。 **注意：**不允许重建树。\n示例 1:\n1 2 输入: preorder = \u0026#34;9,3,4,#,#,1,#,#,2,#,6,#,#\u0026#34; 输出: true 示例 2:\n1 2 输入: preorder = \u0026#34;1,#\u0026#34; 输出: false 示例 3:\n1 2 输入: preorder = \u0026#34;9,#,#,1\u0026#34; 输出: false 提示:\n1 \u0026lt;= preorder.length \u0026lt;= 104 preorder 由以逗号 “，” 分隔的 [0,100] 范围内的整数和 “#” 组成 Solution Language: C++\n思路： 利用栈 的特性，当遇到两个 # 就出栈，把叶子节点弹出，并且插入一个 # ， 重复到最后这个过程，如果是二叉树的前序遍历，最后只有一个 #。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: bool isValidSerialization(string preorder) { vector\u0026lt;string\u0026gt; s; int n = preorder.size(); for (int i=0,j=0;i\u0026lt;n;i=j+1) { j=i; while(j\u0026lt; n \u0026amp;\u0026amp; preorder[j]!=\u0026#39;,\u0026#39;) j++; string u = preorder.substr(i,j-i); s.push_back(u); int last = s.size() - 1; while(s.size() \u0026gt;= 3 \u0026amp;\u0026amp; s[last] == \u0026#34;#\u0026#34; \u0026amp;\u0026amp; s[last-1] == \u0026#34;#\u0026#34;) { s[last-2] = \u0026#34;#\u0026#34;; s.pop_back(); s.pop_back(); last = s.size()-1; } if(s.size() == 2 \u0026amp;\u0026amp; s[0] == \u0026#34;#\u0026#34; \u0026amp;\u0026amp; s[1] == \u0026#34;#\u0026#34;) return false; } return s.size() == 1 \u0026amp;\u0026amp; s[0] == \u0026#34;#\u0026#34;; } }; ","date":"2022-09-03T17:11:53+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/lc.331.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/","tags":["栈"],"title":"lc.331.验证二叉树的前序遍历"},{"categories":["栈"],"contents":" 94. 二叉树的中序遍历 Description Difficulty: 简单\nRelated Topics: 栈 , 树 , 深度优先搜索 , 二叉树 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\n示例 1：\n1 2 输入：root = [1,null,2,3] 输出：[1,3,2] 示例 2：\n1 2 输入：root = [] 输出：[] 示例 3：\n1 2 输入：root = [1] 输出：[1] 提示：\n树中节点数目在范围 [0, 100] 内 -100 \u0026lt;= Node.val \u0026lt;= 100 进阶: 递归算法很简单，你可以通过迭代算法完成吗？\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { if(!root) return {}; #define Node TreeNode stack\u0026lt;Node*\u0026gt; s; stack\u0026lt;int\u0026gt; tmp; vector\u0026lt;int\u0026gt; ans; s.push(root); tmp.push(0); while(s.size()) { int status = tmp.top();tmp.pop(); switch (status) { case 0: // push left tmp.push(1); if(s.top()-\u0026gt;left) { s.push(s.top()-\u0026gt;left); tmp.push(0); } break; case 1: //push right Node *x = s.top();s.pop(); ans.push_back(x-\u0026gt;val); if(x-\u0026gt;right) { s.push(x-\u0026gt;right); tmp.push(0); } break; } } return ans; } }; ","date":"2022-09-03T16:06:47+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/lc.94.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","tags":["栈"],"title":"lc.94.二叉树中序遍历"},{"categories":["栈"],"contents":" 145. 二叉树的后序遍历 Description Difficulty: 简单\nRelated Topics: 栈 , 树 , 深度优先搜索 , 二叉树 给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。\n示例 1：\n1 2 输入：root = [1,null,2,3] 输出：[3,2,1] 示例 2：\n1 2 输入：root = [] 输出：[] 示例 3：\n1 2 输入：root = [1] 输出：[1] 提示：\n树中节点的数目在范围 [0, 100] 内 -100 \u0026lt;= Node.val \u0026lt;= 100 **进阶：**递归算法很简单，你可以通过迭代算法完成吗？\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { if(root == NULL) return {}; stack\u0026lt;TreeNode *\u0026gt; s1; stack\u0026lt;int\u0026gt; s2; s1.push(root); s2.push(0); vector\u0026lt;int\u0026gt; ans; while(s1.size()) { int status = s2.top();s2.pop(); switch (status) { case 0: //push left s2.push(1); if(s1.top() -\u0026gt; left) { s1.push(s1.top()-\u0026gt;left); s2.push(0); } break; case 1: //push right s2.push(2); if(s1.top()-\u0026gt;right) { s1.push(s1.top()-\u0026gt;right); s2.push(0); } break; case 2: // pop case ans.push_back(s1.top()-\u0026gt;val); s1.pop(); break; } } return ans; } }; ","date":"2022-09-03T15:57:46+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/lc.145.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","tags":["栈"],"title":"lc.145.二叉树后序遍历"},{"categories":["栈"],"contents":" 1021. 删除最外层的括号 Description Difficulty: 简单\nRelated Topics: 栈 , 字符串 有效括号字符串为空 \u0026quot;\u0026quot;、\u0026quot;(\u0026quot; + A + \u0026quot;)\u0026quot; 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。\n例如，\u0026quot;\u0026quot;，\u0026quot;()\u0026quot;，\u0026quot;(())()\u0026quot; 和 \u0026quot;(()(()))\u0026quot; 都是有效的括号字符串。 如果有效字符串 s 非空，且不存在将其拆分为 s = A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。\n给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。\n对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。\n示例 1：\n1 2 3 4 5 输入：s = \u0026#34;(()())(())\u0026#34; 输出：\u0026#34;()()()\u0026#34; 解释： 输入字符串为 \u0026#34;(()())(())\u0026#34;，原语化分解得到 \u0026#34;(()())\u0026#34; + \u0026#34;(())\u0026#34;， 删除每个部分中的最外层括号后得到 \u0026#34;()()\u0026#34; + \u0026#34;()\u0026#34; = \u0026#34;()()()\u0026#34;。 示例 2：\n1 2 3 4 5 输入：s = \u0026#34;(()())(())(()(()))\u0026#34; 输出：\u0026#34;()()()()(())\u0026#34; 解释： 输入字符串为 \u0026#34;(()())(())(()(()))\u0026#34;，原语化分解得到 \u0026#34;(()())\u0026#34; + \u0026#34;(())\u0026#34; + \u0026#34;(()(()))\u0026#34;， 删除每个部分中的最外层括号后得到 \u0026#34;()()\u0026#34; + \u0026#34;()\u0026#34; + \u0026#34;()(())\u0026#34; = \u0026#34;()()()()(())\u0026#34;。 示例 3：\n1 2 3 4 5 输入：s = \u0026#34;()()\u0026#34; 输出：\u0026#34;\u0026#34; 解释： 输入字符串为 \u0026#34;()()\u0026#34;，原语化分解得到 \u0026#34;()\u0026#34; + \u0026#34;()\u0026#34;， 删除每个部分中的最外层括号后得到 \u0026#34;\u0026#34; + \u0026#34;\u0026#34; = \u0026#34;\u0026#34;。 提示：\n1 \u0026lt;= s.length \u0026lt;= 105 s[i] 为 '(' 或 ')' s 是一个有效括号字符串 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: string removeOuterParentheses(string s) { int cnt = 0,pre=0; int n = s.size(); string res; for (int i=0;i\u0026lt;n;i++) { if (s[i] == \u0026#39;(\u0026#39;) cnt ++; else cnt --; if (cnt ) continue; res += s.substr(pre+1,i-pre+1-2) ; //cout \u0026lt;\u0026lt; s.substr(pre,i-pre+1) \u0026lt;\u0026lt;endl; pre = i+1; } return res; } }; ","date":"2022-09-03T14:37:50+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/lc.1021.%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7/","tags":["栈"],"title":"lc.1021.删除最外层的括号"},{"categories":["栈"],"contents":" 20. 有效的括号 Description Difficulty: 简单\nRelated Topics: 栈 , 字符串 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\n有效字符串需满足：\n左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 示例 1：\n1 2 输入：s = \u0026#34;()\u0026#34; 输出：true 示例 2：\n1 2 输入：s = \u0026#34;()[]{}\u0026#34; 输出：true 示例 3：\n1 2 输入：s = \u0026#34;(]\u0026#34; 输出：false 提示：\n1 \u0026lt;= s.length \u0026lt;= 104 s 仅由括号 '()[]{}' 组成 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: bool isValid(string s) { stack\u0026lt;char \u0026gt; st; int n = s.size(); for (int i=0;i\u0026lt;n;i++) { switch (s[i]) { case \u0026#39;(\u0026#39;: case \u0026#39;[\u0026#39;: case \u0026#39;{\u0026#39;: st.push(s[i]);break; case \u0026#39;}\u0026#39;: if (st.empty() || st.top() != \u0026#39;{\u0026#39;) return false; st.pop();break; case \u0026#39;]\u0026#39;: if(st.empty() || st.top()!=\u0026#39;[\u0026#39;) return false; st.pop();break; case \u0026#39;)\u0026#39;: if(st.empty() || st.top() != \u0026#39;(\u0026#39;) return false; st.pop();break; } } return st.empty(); } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func isValid(s string) bool { n := len(s) if n % 2 ==1 { return false } bs := map[rune]rune { \u0026#39;)\u0026#39;:\u0026#39;(\u0026#39;, \u0026#39;}\u0026#39;:\u0026#39;{\u0026#39;, \u0026#39;]\u0026#39;:\u0026#39;[\u0026#39;, } var st []rune for _,c := range s { if bs[c] == 0 { st = append(st,c) }else { if len(st) == 0 || st[len(st)-1] != bs[c] { return false } st = st[:len(st)-1] } } return len(st) == 0 } ","date":"2022-09-03T13:32:05+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/lc.20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/","tags":["栈"],"title":"lc.20.有效括号"},{"categories":["栈"],"contents":" 844. 比较含退格的字符串 Description Difficulty: 简单\nRelated Topics: 栈 , 双指针 , 字符串 , 模拟 给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。\n**注意：**如果对空文本输入退格字符，文本继续为空。\n示例 1：\n1 2 3 输入：s = \u0026#34;ab#c\u0026#34;, t = \u0026#34;ad#c\u0026#34; 输出：true 解释：s 和 t 都会变成 \u0026#34;ac\u0026#34;。 示例 2：\n1 2 3 输入：s = \u0026#34;ab##\u0026#34;, t = \u0026#34;c#d#\u0026#34; 输出：true 解释：s 和 t 都会变成 \u0026#34;\u0026#34;。 示例 3：\n1 2 3 输入：s = \u0026#34;a#c\u0026#34;, t = \u0026#34;b\u0026#34; 输出：false 解释：s 会变成 \u0026#34;c\u0026#34;，但 t 仍然是 \u0026#34;b\u0026#34;。 提示：\n1 \u0026lt;= s.length, t.length \u0026lt;= 200 s 和 t 只含有小写字母以及字符 '#' 进阶：\n你可以用 O(n) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？ Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: bool backspaceCompare(string s, string t) { return calc(s) == calc(t); } string calc(string \u0026amp;s) { string b; for (char x :s ) { if (x == \u0026#39;#\u0026#39;) { if(b.size()) b.pop_back(); }else { b.push_back(x); } } return b; } }; ","date":"2022-09-03T13:16:11+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/lc.844.%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","tags":["栈"],"title":"lc.844.比较含退格的字符串"},{"categories":["栈"],"contents":"栈的使用方法 栈是一种后进先出的数据结构，适合使用在需要回溯状态，解析脚本语言表达式的场景。\n解析表达式 下面代码就是用来解决计算表达式的场景的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;bits/stdc++.h\u0026gt; int calc(char *s, int l, int r) { int pri = 10000 - 1, cur_pri = 10000, bracket_pri = 0; int op_index = -1; for (int i = l; i \u0026lt;= r; i++) { cur_pri = 10000; switch (s[i]) { case \u0026#39;+\u0026#39;: case \u0026#39;-\u0026#39;: cur_pri = 1 + bracket_pri; break; case \u0026#39;*\u0026#39;: case \u0026#39;/\u0026#39;: cur_pri = 2 + bracket_pri; break; case \u0026#39;(\u0026#39;: bracket_pri += 100; break; case \u0026#39;)\u0026#39;: bracket_pri -= 100; break; } if (cur_pri \u0026lt;= pri) { pri = cur_pri; op_index = i; } } if (op_index == -1) return 0; printf(\u0026#34;%c\\t\u0026#34;, s[op_index]); int a = calc(s, l, op_index - 1); int b = calc(s, op_index + 1, r); return 0; } int main(void) { char s[100]; int u = 0; while (~scanf(\u0026#34;%[^\\n]s\u0026#34;, s)) { getchar(); printf(\u0026#34;\\n%s=%d\\n\u0026#34;, s, calc(s, 0, strlen(s) - 1)); } return 0; } 解析表达式完整代码 整体的逻辑其实就是一个后序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;bits/stdc++.h\u0026gt; int calc(char *s, int l, int r) { int pri = 10000 - 1, cur_pri = 10000, bracket_pri = 0; int op_index = -1; for (int i = l; i \u0026lt;= r; i++) { cur_pri = 10000; switch (s[i]) { case \u0026#39;+\u0026#39;: case \u0026#39;-\u0026#39;: cur_pri = 1 + bracket_pri; break; case \u0026#39;*\u0026#39;: case \u0026#39;/\u0026#39;: cur_pri = 2 + bracket_pri; break; case \u0026#39;(\u0026#39;: bracket_pri += 100; break; case \u0026#39;)\u0026#39;: bracket_pri -= 100; break; } if (cur_pri \u0026lt;= pri) { pri = cur_pri; op_index = i; } } if (op_index == -1) { int num = 0; for (int i=l;i\u0026lt;=r;i++) { if(s[i] \u0026lt;\u0026#39;0\u0026#39; || s[i] \u0026gt; \u0026#39;9\u0026#39;) continue; num = num*10 + (s[i] - \u0026#39;0\u0026#39;); } return num; } printf(\u0026#34;%c\\t\u0026#34;, s[op_index]); int a = calc(s, l, op_index - 1); int b = calc(s, op_index + 1, r); switch (s[op_index]) { case \u0026#39;+\u0026#39;: return a+b; case \u0026#39;-\u0026#39;: return a-b; case \u0026#39;*\u0026#39;: return a*b; case \u0026#39;/\u0026#39;: return a/b; } return 0; } int main(void) { char s[100]; int u = 0; while (~scanf(\u0026#34;%[^\\n]s\u0026#34;, s)) { getchar(); printf(\u0026#34;\\n%s=%d\\n\u0026#34;, s, calc(s, 0, strlen(s) - 1)); } return 0; } ","date":"2022-09-03T11:11:04+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/","tags":["栈"],"title":"栈"},{"categories":["循环队列"],"contents":" 面试题 17.09. 第 k 个数 Description Difficulty: 中等\nRelated Topics: 哈希表 , 数学 , 动态规划 , 堆（优先队列） 有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。\n示例 1:\n1 2 3 输入: k = 5 输出: 9 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int getKthMagicNumber(int k) { if(k\u0026lt;=1) return 1; vector\u0026lt;int\u0026gt; q; q.push_back(1); int a=0,b=0,c=0; for(int i=1;i\u0026lt;k;i++) { int n = q.size(); //int u = q[n-1]; int x1 = q[a]*3; int x2 = q[b]*5; int x3 = q[c]*7; int t = min(x1,min(x2,x3)); q.push_back(t); if (t%3==0) a++; if(t%5==0) b++; if(t%7==0) c++; } return q[k-1]; } }; ","date":"2022-09-02T21:44:08+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/lc.17.09.%E7%AC%ACk%E4%B8%AA%E6%95%B0/","tags":["循环队列"],"title":"lc.17.09.第k个数"},{"categories":["循环队列"],"contents":" 859. 亲密字符串 Description Difficulty: 简单\nRelated Topics: 哈希表 , 字符串 给你两个字符串 s 和 goal ，只要我们可以通过交换 s 中的两个字母得到与 goal 相等的结果，就返回 true ；否则返回 false 。\n交换字母的定义是：取两个下标 i 和 j （下标从 0 开始）且满足 i != j ，接着交换 s[i] 和 s[j] 处的字符。\n例如，在 \u0026quot;abcd\u0026quot; 中交换下标 0 和下标 2 的元素可以生成 \u0026quot;cbad\u0026quot; 。 示例 1：\n1 2 3 输入：s = \u0026#34;ab\u0026#34;, goal = \u0026#34;ba\u0026#34; 输出：true 解释：你可以交换 s[0] = \u0026#39;a\u0026#39; 和 s[1] = \u0026#39;b\u0026#39; 生成 \u0026#34;ba\u0026#34;，此时 s 和 goal 相等。 示例 2：\n1 2 3 输入：s = \u0026#34;ab\u0026#34;, goal = \u0026#34;ab\u0026#34; 输出：false 解释：你只能交换 s[0] = \u0026#39;a\u0026#39; 和 s[1] = \u0026#39;b\u0026#39; 生成 \u0026#34;ba\u0026#34;，此时 s 和 goal 不相等。 示例 3：\n1 2 3 输入：s = \u0026#34;aa\u0026#34;, goal = \u0026#34;aa\u0026#34; 输出：true 解释：你可以交换 s[0] = \u0026#39;a\u0026#39; 和 s[1] = \u0026#39;a\u0026#39; 生成 \u0026#34;aa\u0026#34;，此时 s 和 goal 相等。 提示：\n1 \u0026lt;= s.length, goal.length \u0026lt;= 2 * 104 s 和 goal 由小写英文字母组成 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: bool valid1(string \u0026amp;a, string \u0026amp;b) { char s[26] = {0}; for (int i=0,n=a.size();i\u0026lt;n;i++) { s[a[i] - \u0026#39;a\u0026#39;]++; if (s[a[i]-\u0026#39;a\u0026#39;] \u0026gt;=2) return true; } return false; } bool buddyStrings(string s, string goal) { int n = s.size(),m = goal.size(); if (n!=m) return false; if (s == goal) { return valid1(s,goal); } vector\u0026lt;int\u0026gt; tmp; for(int i=0;i\u0026lt;n;i++) { if (s[i] != goal[i]) tmp.push_back(i); } if (tmp.size()!=2) { return false; } if (s[tmp[0]] == goal[tmp[1]] \u0026amp;\u0026amp; s[tmp[1]] == goal[tmp[0]]) { return true; } return false; } }; ","date":"2022-09-01T21:18:53+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/lc.859.%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/","tags":["循环队列"],"title":"lc.859.循环队列"},{"categories":["循环队列"],"contents":" 933. 最近的请求次数 Description Difficulty: 简单\nRelated Topics: 设计 , 队列 , 数据流 写一个 RecentCounter 类来计算特定时间范围内最近的请求。\n请你实现 RecentCounter 类：\nRecentCounter() 初始化计数器，请求数为 0 。 int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。 保证 每次对 ping 的调用都使用比之前更大的 t 值。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 输入： [\u0026#34;RecentCounter\u0026#34;, \u0026#34;ping\u0026#34;, \u0026#34;ping\u0026#34;, \u0026#34;ping\u0026#34;, \u0026#34;ping\u0026#34;] [[], [1], [100], [3001], [3002]] 输出： [null, 1, 2, 3, 3] 解释： RecentCounter recentCounter = new RecentCounter(); recentCounter.ping(1); // requests = [1]，范围是 [-2999,1]，返回 1 recentCounter.ping(100); // requests = [1, 100]，范围是 [-2900,100]，返回 2 recentCounter.ping(3001); // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3 recentCounter.ping(3002); // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3 提示：\n1 \u0026lt;= t \u0026lt;= 10\u0026lt;sup\u0026gt;9\u0026lt;/sup\u0026gt; 保证每次对 ping 调用所使用的 t 值都 严格递增 至多调用 ping 方法 10\u0026lt;sup\u0026gt;4\u0026lt;/sup\u0026gt; 次 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 class RecentCounter { public: RecentCounter() { } deque\u0026lt;int\u0026gt; q; int ping(int t) { q.push_back(t); while(t - q.front() \u0026gt; 3000) q.pop_front(); return q.size(); } }; ","date":"2022-09-01T20:33:15+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/lc.933.%E6%9C%80%E8%BF%91%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/","tags":["循环队列"],"title":"lc.933.最近请求次数"},{"categories":["数据结构"],"contents":"循环队列 参考博客 队列的应用 参考文章 ","date":"2022-08-31T22:53:26+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/","tags":["数据结构"],"title":"循环队列"},{"categories":["链表"],"contents":" 82. 删除排序链表中的重复元素 II Description Difficulty: 中等\nRelated Topics: 链表 , 双指针 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。\n示例 1：\n1 2 输入：head = [1,2,3,3,4,4,5] 输出：[1,2,5] 示例 2：\n1 2 输入：head = [1,1,1,2,3] 输出：[2,3] 提示：\n链表中节点数目在范围 [0, 300] 内 -100 \u0026lt;= Node.val \u0026lt;= 100 题目数据保证链表已经按升序 排列 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: ListNode* deleteDuplicates(ListNode* head) { ListNode ans(0,head); ListNode *p= \u0026amp;ans; ListNode *q = NULL; while(p-\u0026gt;next) { if(p-\u0026gt;next-\u0026gt;next \u0026amp;\u0026amp; p-\u0026gt;next-\u0026gt;val == p-\u0026gt;next-\u0026gt;next-\u0026gt;val) { q = p-\u0026gt;next-\u0026gt;next; while(q \u0026amp;\u0026amp; q-\u0026gt;val == p-\u0026gt;next-\u0026gt;val) { q = q-\u0026gt;next; } p-\u0026gt;next = q; }else { p = p-\u0026gt;next; } } return ans.next; } }; ","date":"2022-08-28T22:39:02+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.82.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/","tags":["链表"],"title":"lc.82.删除链表重复节点"},{"categories":["链表"],"contents":" 92. 反转链表 II Description Difficulty: 中等\nRelated Topics: 链表 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left \u0026lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。\n示例 1：\n1 2 输入：head = [1,2,3,4,5], left = 2, right = 4 输出：[1,4,3,2,5] 示例 2：\n1 2 输入：head = [5], left = 1, right = 1 输出：[5] 提示：\n链表中节点数目为 n 1 \u0026lt;= n \u0026lt;= 500 -500 \u0026lt;= Node.val \u0026lt;= 500 1 \u0026lt;= left \u0026lt;= right \u0026lt;= n 进阶： 你可以使用一趟扫描完成反转吗？\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: ListNode * reverse(ListNode *head,int n) { if(n==1) return head; ListNode *tail = head-\u0026gt;next, *p =reverse(head-\u0026gt;next,n-1); head-\u0026gt;next = tail-\u0026gt;next; tail-\u0026gt;next = head; return p; } ListNode* reverseBetween(ListNode* head, int left, int right) { ListNode fake(0); fake.next = head; ListNode * p = \u0026amp;fake; for(int i=0;i\u0026lt;left-1;i++) p = p-\u0026gt;next; p-\u0026gt;next = reverse(p-\u0026gt;next,right-left+1); return fake.next; } }; ","date":"2022-08-28T22:30:26+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.92.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A82/","tags":["链表"],"title":"lc.92.翻转链表2"},{"categories":["链表"],"contents":" 202. 快乐数 Description Difficulty: 简单\nRelated Topics: 哈希表 , 数学 , 双指针 编写一个算法来判断一个数 n 是不是快乐数。\n「快乐数」 定义为：\n对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为 1，那么这个数就是快乐数。 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。\n示例 1：\n1 2 3 4 5 6 7 输入：n = 19 输出：true 解释： 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 示例 2：\n1 2 输入：n = 2 输出：false 提示：\n1 \u0026lt;= n \u0026lt;= 231 - 1 解题思路 graph LR 19--\u0026gt;82--\u0026gt;68--\u0026gt;100--\u0026gt;1 题目可以转化为，判断一个链表是否具有环\n如果遍历某个节点为1，说明没有环，就是快乐数\n如果遍历到重复的节点值，说明有环，就不是快乐数\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: bool isHappy(int n) { unordered_map\u0026lt;int,bool\u0026gt; mp; mp[n] = true; while (1) { n = sq(n); if (n==1) { return true; } if (mp[n]) { return false; } mp[n] = true; } return false; } int sq(int n) { int x = 0; while(n) { int u = n%10; n/=10; x += u*u; } return x; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: bool isHappy(int n) { int fast = n,slow = n; do { fast = sq(fast); fast = sq(fast); slow = sq(slow); // if (fast ==1 ) return true; }while(fast != slow \u0026amp;\u0026amp; slow != 1); return fast == 1; } int sq(int n) { int x = 0; while(n) { int u = n%10; n/=10; x += u*u; } return x; } }; ","date":"2022-08-28T21:37:39+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.202.%E5%BF%AB%E4%B9%90%E6%95%B0/","tags":["链表"],"title":"lc.202.快乐数"},{"categories":["链表"],"contents":"定义链表的实现方法 指针实现链表 1 2 3 4 type Node { int data; Node *next; } 静态数组实现链表 通过相对地址实现链表\n1 2 3 4 5 6 7 8 int data[10]; int next[10]; void add(int ind,int p,int val) { next[ind] = p; data[p] = val; return; } 代码演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;cstdio\u0026gt; using namespace std; int data[10]; int next[10]; void add(int ind,int p,int val) { next[ind] = p; data[p] = val; return; } int main() { int head=3; data[3] = -1; add(3,5,1); add(5,2,2); add(7,9,10); int p = head; while(p!=0) { printf(\u0026#34;%d[%d]-\u0026gt;\u0026#34;,p,data[p]); p = next[p]; } return 0; } //3[-1]-\u0026gt;5[1]-\u0026gt;2[2]-\u0026gt; 翻转链表写法 其实如果知道二叉树的后序遍历，我们很容易就知道写法\n下面是翻转打印\n1 2 3 4 5 6 void reverse(Node *p) { if (p == NULL) return ; reverse(p-\u0026gt;next); printf(\u0026#34;%d -\u0026gt;\u0026#34; ,p-\u0026gt;data); return; } 参考leetcode 206\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { if(head == NULL || head-\u0026gt;next ==NULL) return head; ListNode *tail = head-\u0026gt;next, *p = reverseList(head-\u0026gt;next); head-\u0026gt;next = tail-\u0026gt;next; tail -\u0026gt; next = head; return p; } }; 特殊题 [[lc.2816.翻倍以链表形式表示的数字.md]]\n合并两个有序链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(p *ListNode, q *ListNode) *ListNode { var head ListNode var x = \u0026amp;head for p != nil \u0026amp;\u0026amp; q != nil { if p.Val \u0026gt; q.Val { x.Next = q q = q.Next }else { x.Next = p p = p.Next } x = x.Next x.Next = nil } if p != nil { x.Next = p }else if q != nil { x.Next = q } return head.Next } ","date":"2022-08-28T17:07:48+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80/","tags":["链表"],"title":"链表基础"},{"categories":["递归"],"contents":" 46. 全排列 Description Difficulty: 中等\nRelated Topics: 数组 , 回溯 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n示例 1：\n1 2 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2：\n1 2 输入：nums = [0,1] 输出：[[0,1],[1,0]] 示例 3：\n1 2 输入：nums = [1] 输出：[[1]] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 6 -10 \u0026lt;= nums[i] \u0026lt;= 10 nums 中的所有整数 互不相同 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { used = vector\u0026lt;bool\u0026gt; (nums.size()); dfs(nums); return res; } vector\u0026lt;bool\u0026gt; used; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;int \u0026gt; trace; void dfs(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int n = nums.size(); if(trace.size()== n ) { res.push_back(trace); return; } for (int i=0;i\u0026lt;n;i++) { if(!used[i]) { used[i] = true; trace.push_back(nums[i]); dfs(nums); trace.pop_back(); used[i] = false; } } } }; ","date":"2022-08-25T23:12:09+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/lc.46.%E5%85%A8%E6%8E%92%E5%88%97/","tags":["递归"],"title":"lc.46.全排列"},{"categories":["递归"],"contents":" 77. 组合 Description Difficulty: 中等\nRelated Topics: 回溯 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n你可以按 任何顺序 返回答案。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 输入：n = 4, k = 2 输出： [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 示例 2：\n1 2 输入：n = 1, k = 1 输出：[[1]] 提示：\n1 \u0026lt;= n \u0026lt;= 20 1 \u0026lt;= k \u0026lt;= n Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; s; void dfs(int n,int k ,int startIndex) { if (s.size() == k) { ans.push_back(s); return; } for (int i=startIndex;i\u0026lt;=n-(k-s.size()) + 1;i++) { s.push_back(i); dfs(n,k,i+1); s.pop_back(); } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combine(int n, int k) { dfs(n,k,1); return ans; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; s; void dfs(int n,int k ,int startIndex) { if (s.size() == k) { ans.push_back(s); return; } for (int i=startIndex;i\u0026lt;=n;i++) { if(s.size() \u0026gt; k) break; //超过数 if(s.size() + (n-i+1) \u0026lt; k) break;//不够数 s.push_back(i); dfs(n,k,i+1); s.pop_back(); } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combine(int n, int k) { dfs(n,k,1); return ans; } }; ","date":"2022-08-25T22:43:21+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/lc.77.%E7%BB%84%E5%90%88/","tags":["递归"],"title":"lc.77.组合"},{"categories":["递归"],"contents":" 剑指 Offer II 079. 所有子集 Description Difficulty: 中等\nRelated Topics: 位运算 , 数组 , 回溯 给定一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\n解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n示例 1：\n1 2 输入：nums = [1,2,3] 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 示例 2：\n1 2 输入：nums = [0] 输出：[[],[0]] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10 -10 \u0026lt;= nums[i] \u0026lt;= 10 nums 中的所有元素 互不相同 注意：本题与主站 78 题相同：\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { unordered_map\u0026lt;int,bool\u0026gt; mp; dfs(nums,mp,0); return ans; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; void dfs(vector\u0026lt;int\u0026gt; \u0026amp;arr,unordered_map\u0026lt;int,bool\u0026gt; \u0026amp;mp,int index) { if (index == arr.size()) { vector\u0026lt;int\u0026gt; temp; for (auto[k,v]:mp ) { temp.push_back(k); } ans.push_back(temp); return; } dfs(arr,mp,index+1); mp[arr[index]] = true; dfs(arr,mp,index+1); mp.erase(arr[index]); } }; ","date":"2022-08-19T00:26:47+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/%E5%AD%90%E9%9B%86/","tags":["递归"],"title":"子集"},{"categories":["哈希表"],"contents":" 剑指 Offer II 031. 最近最少使用缓存 Description Difficulty: 中等\nRelated Topics: 设计 , 哈希表 , 链表 , 双向链表 运用所掌握的数据结构，设计和实现一个 。\n实现 LRUCache 类：\nLRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 输入 [\u0026#34;LRUCache\u0026#34;, \u0026#34;put\u0026#34;, \u0026#34;put\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;put\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;put\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;get\u0026#34;] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] 输出 [null, null, null, 1, null, -1, null, -1, 3, 4] 解释 LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // 缓存是 {1=1} lRUCache.put(2, 2); // 缓存是 {1=1, 2=2} lRUCache.get(1); // 返回 1 lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3} lRUCache.get(2); // 返回 -1 (未找到) lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3} lRUCache.get(1); // 返回 -1 (未找到) lRUCache.get(3); // 返回 3 lRUCache.get(4); // 返回 4 提示：\n1 \u0026lt;= capacity \u0026lt;= 3000 0 \u0026lt;= key \u0026lt;= 10000 0 \u0026lt;= value \u0026lt;= 105 最多调用 2 * 105 次 get 和 put 进阶：是否可以在 O(1) 时间复杂度内完成这两种操作？\n注意：本题与主站 146 题相同：\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 //哈希表+双向链表 struct Node { int key; int value; Node *prev,*next; }; class LRUCache { public: Node* head,*tail; unordered_map\u0026lt;int, Node*\u0026gt; idMap; int n; LRUCache(int capacity) { this-\u0026gt;n = capacity; head = new Node(); tail = new Node(); head-\u0026gt;next = tail; tail-\u0026gt;prev = head; head-\u0026gt;value = -1; tail-\u0026gt;value = -1; } void _remove( Node* x) { if(!x) return; Node *prev = x-\u0026gt;prev; Node *next = x-\u0026gt;next; if (prev) { prev-\u0026gt;next = next; } if(next) { next-\u0026gt;prev = prev; } x-\u0026gt;prev = NULL; x-\u0026gt;next = NULL; idMap.erase(x-\u0026gt;key); //记得清hashMap } void _addHead(Node *x) { Node *next = head-\u0026gt;next; Node *prev = head; prev-\u0026gt;next = x; if(next) next-\u0026gt;prev = x; x-\u0026gt;prev = head; x-\u0026gt;next = next; idMap[x-\u0026gt;key] = x; } int get(int key) { if (idMap.find(key)==idMap.end() ) return -1; Node *x = idMap[key]; _remove(x); _addHead(x); return x-\u0026gt;value; } void put(int key, int value) { Node* x = idMap[key]; if(x==NULL) { auto node = new Node(); node-\u0026gt;key = key; node-\u0026gt;value = value; idMap[key] = node; _addHead(node); }else { get(key); x-\u0026gt;value = value; } if (idMap.size() \u0026gt; n) _expire(); // printf(\u0026#34;%d,\u0026#34;,value); } void _expire() { Node *x = tail-\u0026gt;prev; _remove(x); delete(x); } }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-\u0026gt;get(key); * obj-\u0026gt;put(key,value); */ ","date":"2022-08-18T00:35:13+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/lru%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/","tags":["哈希表"],"title":"LRU缓存实现"},{"categories":["哈希表"],"contents":" 30. 串联所有单词的子串 Description Difficulty: 困难\nRelated Topics: 哈希表 , 字符串 , 滑动窗口 给定一个字符串 s和一些 长度相同 的单词 words **。**找出 s中恰好可以由 words中所有单词串联形成的子串的起始位置。\n注意子串要与 words中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words中单词串联的顺序。\n示例 1：\n1 2 3 4 5 输入：s = \u0026#34;barfoothefoobarman\u0026#34;, words = [\u0026#34;foo\u0026#34;,\u0026#34;bar\u0026#34;] 输出：[0,9] 解释： 从索引 0 和 9 开始的子串分别是 \u0026#34;barfoo\u0026#34; 和 \u0026#34;foobar\u0026#34; 。 输出的顺序不重要, [9,0] 也是有效答案。 示例 2：\n1 2 输入：s = \u0026#34;wordgoodgoodgoodbestword\u0026#34;, words = [\u0026#34;word\u0026#34;,\u0026#34;good\u0026#34;,\u0026#34;best\u0026#34;,\u0026#34;word\u0026#34;] 输出：[] 示例 3：\n1 2 输入：s = \u0026#34;barfoofoobarthefoobarman\u0026#34;, words = [\u0026#34;bar\u0026#34;,\u0026#34;foo\u0026#34;,\u0026#34;the\u0026#34;] 输出：[6,9,12] 提示：\n1 \u0026lt;= s.length \u0026lt;= 104 s 由小写英文字母组成 1 \u0026lt;= words.length \u0026lt;= 5000 1 \u0026lt;= words[i].length \u0026lt;= 30 words[i] 由小写英文字母组成 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: vector\u0026lt;int\u0026gt; findSubstring(string s, vector\u0026lt;string\u0026gt;\u0026amp; words) { unordered_map\u0026lt;string,int\u0026gt; mp; for(auto u:words) mp[u]++; if (words.size() == 0) return {}; // int int n = words.size(); int m = words[0].size(); int len = m*n; vector\u0026lt;int \u0026gt; ans; for (int i=0;i+len\u0026lt;=s.length();i++) { if (isSame(s.substr(i,len),words,mp)) { ans.push_back(i); } } return ans; } bool isSame(string a, vector\u0026lt;string\u0026gt; \u0026amp;words,unordered_map\u0026lt;string,int\u0026gt; mp2) { int n = words[0].size(); unordered_map\u0026lt;string,int\u0026gt; mp; for(int i=0;i\u0026lt;a.length();i+=n) { mp[a.substr(i,n)]++; } for(auto [key,v]: mp) { if( !(mp2.count(key) \u0026amp;\u0026amp; mp2[key] == v)) { return false; } } return true; } }; ","date":"2022-08-18T00:23:55+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/lc.30.%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/","tags":["哈希表"],"title":"lc.30.串联所有单词的子串"},{"categories":["哈希表"],"contents":" 49. 字母异位词分组 Description Difficulty: 中等\nRelated Topics: 数组 , 哈希表 , 字符串 , 排序 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。\n示例 1:\n1 2 输入: strs = [\u0026#34;eat\u0026#34;, \u0026#34;tea\u0026#34;, \u0026#34;tan\u0026#34;, \u0026#34;ate\u0026#34;, \u0026#34;nat\u0026#34;, \u0026#34;bat\u0026#34;] 输出: [[\u0026#34;bat\u0026#34;],[\u0026#34;nat\u0026#34;,\u0026#34;tan\u0026#34;],[\u0026#34;ate\u0026#34;,\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;]] 示例 2:\n1 2 输入: strs = [\u0026#34;\u0026#34;] 输出: [[\u0026#34;\u0026#34;]] 示例 3:\n1 2 输入: strs = [\u0026#34;a\u0026#34;] 输出: [[\u0026#34;a\u0026#34;]] 提示：\n1 \u0026lt;= strs.length \u0026lt;= 104 0 \u0026lt;= strs[i].length \u0026lt;= 100 strs[i] 仅包含小写字母 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; groupAnagrams(vector\u0026lt;string\u0026gt;\u0026amp; strs) { unordered_map\u0026lt;string,vector\u0026lt;string\u0026gt;\u0026gt; mp; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; result; for (auto \u0026amp;str: strs) { string g = str; sort(g.begin(),g.end()); mp[g].push_back(str); } for(auto [_,v] : mp) { result.push_back(v); } return result; } }; ","date":"2022-08-17T00:11:31+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/lc.49.%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/","tags":["哈希表"],"title":"lc.49.字母异位词分组"},{"categories":["哈希表"],"contents":" 874. 模拟行走机器人 Description Difficulty: 中等\nRelated Topics: 数组 , 模拟 机器人在一个无限大小的 XY 网格平面上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 commands ：\n-2 ：向左转 90 度 -1 ：向右转 90 度 1 \u0026lt;= x \u0026lt;= 9 ：向前移动 x 个单位长度 在网格上有一些格子被视为障碍物 obstacles 。第 i 个障碍物位于网格点 obstacles[i] = (xi, yi) 。\n机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。\n返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。（即，如果距离为 5 ，则返回 25 ）\n注意：\n北表示 +Y 方向。 东表示 +X 方向。 南表示 -Y 方向。 西表示 -X 方向。 示例 1：\n1 2 3 4 5 6 7 8 输入：commands = [4,-1,3], obstacles = [] 输出：25 解释： 机器人开始位于 (0, 0)： 1\\. 向北移动 4 个单位，到达 (0, 4) 2\\. 右转 3\\. 向东移动 3 个单位，到达 (3, 4) 距离原点最远的是 (3, 4) ，距离为 32 + 42 = 25 示例 2：\n1 2 3 4 5 6 7 8 9 输入：commands = [4,-1,4,-2,4], obstacles = [[2,4]] 输出：65 解释：机器人开始位于 (0, 0)： 1\\. 向北移动 4 个单位，到达 (0, 4) 2\\. 右转 3\\. 向东移动 1 个单位，然后被位于 (2, 4) 的障碍物阻挡，机器人停在 (1, 4) 4\\. 左转 5\\. 向北走 4 个单位，到达 (1, 8) 距离原点最远的是 (1, 8) ，距离为 12 + 82 = 65 提示：\n1 \u0026lt;= commands.length \u0026lt;= 104 commands[i] is one of the values in the list [-2,-1,1,2,3,4,5,6,7,8,9]. 0 \u0026lt;= obstacles.length \u0026lt;= 104 -3 * 104 \u0026lt;= xi, yi \u0026lt;= 3 * 104 答案保证小于 231 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public: int robotSim(vector\u0026lt;int\u0026gt;\u0026amp; commands, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; obstacles) { unordered_set\u0026lt;string\u0026gt; blockers; for (auto \u0026amp;w: obstacles) { blockers.insert(calc(w[0],w[1])); } int dx[] = {0,1,0,-1}; int dy[] = {1,0,-1,0}; int dir=0,x=0,y=0; int ans=0; for (int cmd: commands) { if (cmd \u0026gt; 0) { while(cmd--) { int nx = x+dx[dir], ny = y+dy[dir]; if (blockers.count(calc(nx,ny))) { break; //block } x = nx; y = ny; ans = max(x*x+y*y,ans); } }else if (cmd==-1) { dir = (dir+1) % 4; }else { dir = (dir-1 + 4) %4; } } return ans; } string calc(int a,int b) { return to_string(a)+\u0026#34;.\u0026#34;+to_string(b); } }; 实现一个哈希函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public: int robotSim(vector\u0026lt;int\u0026gt;\u0026amp; commands, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; obstacles) { unordered_set\u0026lt;long long\u0026gt; blockers; for (auto \u0026amp;w: obstacles) { blockers.insert(calc(w[0],w[1])); } int dx[] = {0,1,0,-1}; int dy[] = {1,0,-1,0}; int dir=0,x=0,y=0; int ans=0; for (int cmd: commands) { if (cmd \u0026gt; 0) { while(cmd--) { int nx = x+dx[dir], ny = y+dy[dir]; if (blockers.count(calc(nx,ny))) { break; //block } x = nx; y = ny; ans = max(x*x+y*y,ans); } }else if (cmd==-1) { dir = (dir+1) % 4; }else { dir = (dir-1 + 4) %4; } } return ans; } long long mod = (1e9+7); long long calc(long long a,long long b) { // long long x = (a+30000)*60000ll +b+30000; long long x = ((abs(a)\u0026lt;\u0026lt;16) \u0026amp; (abs(b)\u0026gt;\u0026gt;16) ) + (a+30000)*60000+b+30000 ; // printf(\u0026#34;x=%lld,\u0026#34;,x); return x; // return to_string(a)+\u0026#34;.\u0026#34;+to_string(b); } }; ","date":"2022-08-16T23:39:08+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/lc.874.%E6%A8%A1%E6%8B%9F%E8%A1%8C%E8%B5%B0%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA/","tags":["哈希表"],"title":"lc.874.模拟行走的机器人"},{"categories":["哈希表"],"contents":"哈希表定义 哈希表，又叫散列表，通过 \u0026ldquo;关键码\u0026rdquo; key访问数据结构。\n哈希表由2部分组成\n一个数据结构，通常是链表、数组 hash函数，输入 \u0026ldquo;关键码\u0026rdquo; (key) 返回数据结构的索引。 ","date":"2022-08-15T23:25:43+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%9A%E4%B9%89/","tags":["哈希表"],"title":"哈希表定义"},{"categories":["sync"],"contents":"atomic.Value 参考 参考博客 Go的sync/atomic包提供了原子操作，支持的数据类型包括：\nint32, int64, uint32, uint64, uintptr, unsafe.Pointer\n1\n若需要扩大原子操作的适用范围，可以使用atomic包中的Value。利用它可以实现对任意值进行原子得存储与加载。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //值类型 func atomic_value(a uint32) { var v atomic.Value v.Store(a) a = 666 fmt.Println(a) fmt.Println(v.Load()) } // 引用类型 func atomic_slice(s []uint32) { var v atomic.Value v.Store(s) s[0] = 666 fmt.Println(s) fmt.Println(v.Load()) } ","date":"2022-08-04T22:10:35+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/sync/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/","tags":["sync"],"title":"并发原语"},{"categories":["前缀和"],"contents":" 1248. 统计「优美子数组」 Description Difficulty: 中等\nRelated Topics: 数组 , 哈希表 , 数学 , 滑动窗口 给你一个整数数组 nums 和一个整数 k。如果某个连续子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。\n请返回这个数组中 「优美子数组」 的数目。\n示例 1：\n1 2 3 输入：nums = [1,1,2,1,1], k = 3 输出：2 解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。 示例 2：\n1 2 3 输入：nums = [2,4,6], k = 1 输出：0 解释：数列中不包含任何奇数，所以不存在优美子数组。 示例 3：\n1 2 输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2 输出：16 提示：\n1 \u0026lt;= nums.length \u0026lt;= 50000 1 \u0026lt;= nums[i] \u0026lt;= 10^5 1 \u0026lt;= k \u0026lt;= nums.length Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int numberOfSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); if(!n) return 0; vector\u0026lt;int\u0026gt; sum(n+1); unordered_map\u0026lt;int,int\u0026gt; mp; int cnt =0; mp[0] = 1; for (int i=1;i\u0026lt;=n;i++) { sum[i] = sum[i-1] + (nums[i-1] \u0026amp; 1); //cnt += mp[sum[i] - 3]; cnt += mp[sum[i] - k]; //sum[r] - sum[l-1] == k 转化为 // sum[r] == sum[l-1] + k // sum[r] - k == sum[l-1] , mp[sum[i]] ++; } return cnt; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int numberOfSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); if(!n) return 0; unordered_map\u0026lt;int,int\u0026gt; mp; int sum=0; int cnt = 0; mp[0] = 1; for (int u: nums) { sum = sum + (u \u0026amp; 1); cnt += mp[sum-k]; mp[sum]++; } return cnt; } }; 模板题\r前缀和 ","date":"2022-08-03T22:18:11+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C/1248.%E7%BB%9F%E8%AE%A1%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84/","tags":["前缀和"],"title":"1248.统计优美子数组"},{"categories":["rust"],"contents":"安装 rust 无论使用何种系统, 均可以根据 Rust 官方网站提供的 rustup-init 工具完成 Rust 的安装. rustup-init 下载地址: https://www.rust-lang.org/zh-CN/tools/install . 网站会自动识别你的操作系统并给出提示, 遵循网站提示一步一步执行即可. 当安装完成后, 可使用以下命令进行测试, 如果正确输出版本号则表明安装已经成功.\n1 2 3 4 rustc --version cargo new hello cd hello code . 提示: 如果你使用的是 Linux 系统, 那么在 rustup-init 运行完成后它会在命令行中提示你将软件安装目录加入 PATH 环境变量中. 对于 Windows 系统来说不需要这一步.\nvscode 插件配置 安装 rust-analyzer\nrust-analyzer 包含代码提示, 代码检查, 自动补全等多种功能. 你可能会注意到在插件市场中存在一个标了小星星的名字就叫 Rust 的插件, 它的下载量与安装量都远远高于 rust-analyzer, 那么为什么不选择使用它呢? 因为这个排名第一的 Rust 插件底层使用的是 名为 rls 的 Rust 前端, 由于 rls 本身性能过于捉急, 在 2020 年的时候社区推出了 rust-analyzer 项目并旨在全面替换掉 rls. 在体验上, rust-analyzer 要远远好于 rls.\nrust 所有权问题 所有编程语言都存在某种管理内存的机制，拿c语言来说，这种机制是 free 和 malloc ，这意味着开发者要手动管理内存，对于编程高手来说，这种拥有无限可能性的技术，对于普通的开发者而言，这是一个 bug,制造机器，一些语言采用了垃圾回收技术来管理内存，也就是说开发者可以只申请内存，而不用手动释放内存，然后，垃圾回收期，也就是GC，会自动检测某块内存是否不再被使用，如果是的话，就释放那块内存，但是 GC会导致程序性能下降，任何使用GC语言几乎不可能用来写底层程序，我们指的是底层贴近硬件的软件程序，例如操作系统和硬件驱动。\nrust 采用raii,它兼具GC的易用性和安全性，同时又有极高的性能。\n生命周期 以下是错误定义\n1 2 3 struct Person { name: \u0026amp;str, } ","date":"2022-08-01T22:47:47+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/rust/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","tags":["rust"],"title":"开发环境安装"},{"categories":["rust"],"contents":"rust介绍 rust 能做什么？\n区块链 系统层面 编译器虚拟机 rust 基本数据类型学习 复合类型 元组 1 2 3 4 5 6 7 8 fn main() { let a :i32 = 10; let b:char = \u0026#39;A\u0026#39;; let tuple = (a,b); println!(\u0026#34;key{},value={}\u0026#34;,tuple.0,tuple.1); } 定义数组 1 2 3 4 5 6 7 fn main() { let a:[u32;5] = [1,2,3,4,5]; println!(\u0026#34;{}\u0026#34;, a[0]); } 1 2 3 4 5 6 7 fn main() { let a:[u32;5] = [1,2,3,4,5]; let mut buf:[u32;5] = [0;5]; println!(\u0026#34;{}{}\u0026#34;, a[0],buf[2]); } 切片语法 let slice = \u0026amp;arr[0..3]\n结构体 结果提不是对象，结构体是各种数据的组合，是没有动作的\n1 2 3 4 5 6 struct Person { name: String, age:u8, } struct Pair(i32,f32); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #[derive(Debug)] struct Person { name: String, age: u8, } // derive 相当于自己实现了 toString 方法，这样 println 才能打印 fn main() { let jack = Person { age:6, name: String::from(\u0026#34;Jack\u0026#34;), }; print!(\u0026#34;{:?}\u0026#34;, jack); } 枚举类型 枚举 解释 枚举 无参数枚举 带枚举值的枚举 带参数的枚举 模式匹配 Option 枚举类 Option 是 Rust 标准库中的枚举类，这个类用于填补 Rust 不支持 null 引用的空白。\n许多语言支持 null 的存在（C/C++、Java），这样很方便，但也制造了极大的问题，null 的发明者也承认这一点，\u0026ldquo;一个方便的想法造成累计 10 亿美元的损失\u0026rdquo;。\nnull 经常在开发者把一切都当作不是 null 的时候给予程序致命一击：毕竟只要出现一个这样的错误，程序的运行就要彻底终止。\n为了解决这个问题，很多语言默认不允许 null，但在语言层面支持 null 的出现（常在类型前面用 ? 符号修饰）。\nJava 默认支持 null，但可以通过 @NotNull 注解限制出现 null，这是一种应付的办法。\nRust 在语言层面彻底不允许空值 null 的存在，但无奈null 可以高效地解决少量的问题，所以 Rust 引入了 Option 枚举类：\n表达式语句 语句叫做 statement, 表达式叫做 expression ,rust 是一个基于表达式的语言，意味着其大多数代码都有返回值\n1 2 3 4 5 6 let cond = true let a = if cond { 42 }else { 24 }; loop 表达式返回值 循环里面是可以带上返回值的， 我们可以利用这个实现重试某种任务\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 fn main() { let mut sum = 0; let mut n = 1; let res = loop { sum += n ; n+=1; if n \u0026gt; 100 { break sum; } }; println!(\u0026#34;{}\u0026#34;, res); } for range 语法 rust 中的 for .. in.. 语法 可以用来遍历一个迭代器，有多种方式创建一个迭代器，最简单也是最常用的方式如下所示。\n1 2 3 for i in 0..5 { println!(\u0026#34;{}\u0026#34;,i) } 1 2 3 for i in array.iter_mut() { *i += 1; } if let 语法糖 if let 用来解构一个枚举\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 enum Symbol { Char(char), Number, } fn main() { let letter = Symbol::Char(\u0026#39;a\u0026#39;); if let Symbol::Char(x) = letter { println!(\u0026#34;{}\u0026#34;,x); } } 函数和方法 如果要修改结构体，要设置 mut关键字，不然是无法编译通过的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct Point { x: u64, y: u64, } impl Point { fn new(x:u64, y:u64) -\u0026gt; Point { Point { x,y } } fn get_x(\u0026amp;self) -\u0026gt; u64 { self.x } fn set_x(\u0026amp;mut self,x: u64) { self.x = x } } fn main() { let mut p = Point::new(10,20); println!(\u0026#34;{}\u0026#34;,p.get_x()); p.set_x(30); println!(\u0026#34;{}\u0026#34;,p.get_x()); } 闭包函数 1 2 3 4 5 6 fn main() { let my = |n:u32| -\u0026gt; u32 { n + 1 }; println!(\u0026#34;{}\u0026#34;,my(12)) } 创建多线程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 use std::thread; fn main() { let msg = \u0026#34;Hello, world!\u0026#34;; thread::spawn(move || { println!(\u0026#34;{}\u0026#34;, msg); }).join(); } rust 模块化 通过 mod 关键字来定义模块\n1 2 3 4 5 6 7 8 9 10 11 12 pub mod fuck { pub const MSG: \u0026amp;str = \u0026#34;Hello, world!\u0026#34;; } fn main() { println!(\u0026#34;{}\u0026#34;,fuck::MSG) } 结构体可见性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 mod mod1 { pub struct Person { pub name: String, nickname: String } impl Person { pub fn new(name: \u0026amp;str,s : \u0026amp;str) -\u0026gt; Person { Person { name:String::from(name), nickname: String::from(s) } } } } fn main() { let p = mod1::Person::new(\u0026#34;tom\u0026#34;, \u0026#34;tommy\u0026#34;); println!(\u0026#34;{}\u0026#34;,p.name); //只有 pub的 才可以打印 } 模块访问关键字 super: 上层模块 self: 当前模块 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 fn function() { println!(\u0026#34;---\u0026#34;); } mod mod1 { pub fn function() { super::function(); self::selfn(); } pub fn selfn() { } } fn main() { mod1::function(); } ","date":"2022-08-01T22:45:16+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/rust/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","tags":["rust"],"title":"基本数据类型"},{"categories":["链表"],"contents":" 142. 环形链表 II Description Difficulty: 中等\nRelated Topics: 哈希表 , 链表 , 双指针 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n不允许修改 链表。\n示例 1：\n1 2 3 输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：\n1 2 3 输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：\n1 2 3 输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。 提示：\n链表中节点的数目范围在范围 [0, 104] 内 -105 \u0026lt;= Node.val \u0026lt;= 105 pos 的值为 -1 或者链表中的一个有效索引 **进阶：**你是否可以使用 O(1) 空间解决此题？\n解题公式 graph LR head--l--\u0026gt;st--p--\u0026gt;meet--\u0026#34;(r-p)\u0026#34;--\u0026gt;st 公式推导：\n$2*(l+p) = l+ kr + p$\n$l+p = kr$\n$l = k*r - p$\n$ l = k*r - p + r -r$\n$ l = (k-1) *r + (r-p) $\n实际工作中我们不需要这么复杂，直接用一个 HashMap 将 node存起来即可。\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: #define Node ListNode ListNode *detectCycle(ListNode *head) { if(!head) return NULL; Node* x = head; Node*y = head; while(x) { x = x-\u0026gt;next; if(!x) break; x = x-\u0026gt;next; y = y-\u0026gt;next; if (x == y) break; } if(!x) return NULL; // x y is meet ,x is fast x = head; while(x!=y) { x = x-\u0026gt;next; y = y-\u0026gt;next; //y一直在原地转圈 } return x; } }; ","date":"2022-08-01T01:09:32+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","tags":["链表"],"title":"环形链表"},{"categories":["链表"],"contents":" 25. K 个一组翻转链表 Description Difficulty: 困难\nRelated Topics: 递归 , 链表 给你链表的头节点 head ，每 k个节点一组进行翻转，请你返回修改后的链表。\nk 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k的整数倍，那么请将最后剩余的节点保持原有顺序。\n你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\n示例 1：\n1 2 输入：head = [1,2,3,4,5], k = 2 输出：[2,1,4,3,5] 示例 2：\n1 2 输入：head = [1,2,3,4,5], k = 3 输出：[3,2,1,4,5] 提示：\n链表中的节点数目为 n 1 \u0026lt;= k \u0026lt;= n \u0026lt;= 5000 0 \u0026lt;= Node.val \u0026lt;= 1000 **进阶：**你可以设计一个只用 O(1) 额外内存空间的算法解决此问题吗？\nSolution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { ListNode fake(-1); ListNode *x = \u0026amp;fake; while(head) { ListNode * end = getEnd(head,k); if (!end) { break; } ListNode *next_group = end-\u0026gt;next; reverse(head,end); x-\u0026gt;next = end; head -\u0026gt; next = next_group; x = head;//head become the group of tail head = next_group; } return fake.next; } ListNode * getEnd(ListNode* h, int k) { while( h!=NULL ) { k--; if(k == 0) break; h = h-\u0026gt;next; } return h; } ListNode * reverse(ListNode * l,ListNode* r) { if(l == r) return l; ListNode* pre = l; l = l-\u0026gt;next; while(l!=r) { ListNode *t = l-\u0026gt;next; l-\u0026gt;next = pre; pre = l; l = t; //pre = pre-\u0026gt;next; } r-\u0026gt;next = pre; return pre ; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseKGroup(head *ListNode, k int) *ListNode { if head == nil || k \u0026lt;= 1 { return head } var fake = \u0026amp;ListNode{Next:head } pre := fake for head != nil { groupEnd := getEnd(head,k) if groupEnd == nil { break } groupNext := groupEnd.Next x,y := reverse(head,groupEnd) pre.Next = x head = groupNext pre = y } return fake.Next } func getEnd(head *ListNode,k int) *ListNode { for head != nil { k-- if k == 0 { return head } head = head.Next } return head } func reverse(head, tail *ListNode) (*ListNode, *ListNode) { prev := tail.Next curr := head for prev != tail { next := curr.Next curr.Next = prev prev = curr curr = next } return tail, head } ","date":"2022-08-01T01:02:32+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.25.k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/","tags":["链表"],"title":"k个一组翻转链表"},{"categories":["数据结构"],"contents":"变长数组 一个建议的实现方法：\n初始化：空数组，分配常数空间\npush_back, 空间不够，申请2倍内存拷贝\npop_back, 空间利用率不到 25%，就释放一半内存\n均摊复杂度 o(1)\n在空数组中连续插入n个元素，总插入、拷贝次数为 $ n+n/2+n/4 + \u0026hellip; \u0026lt; 2n$\n下一次扩容到下一次释放，至少需要删除 (1-2*0.5) = 0.5n次\n思考： 如果（释放空间的阈值） 利用率到 50% 的时候缩容，会怎么样\n练习题 合并有序数组 去重 移动零 链表 头插法 尾插法 删除 练习题 k个一组翻转链表 ","date":"2022-08-01T00:12:20+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","tags":["数据结构"],"title":"数据结构"},{"categories":["单调队列"],"contents":"单调队列解法 区间[l,r] 可以由 [1,r] 和 [1,l-1] 的信息导出 满足区间减法，可以用前缀和 维护信息是一个点的话，可以考虑使用双指针，如果是一个段的话，可以考虑前缀和和单调队列\n如果 区间的两个前缀作差，可以知道 [l,r] 之间的信息，就考虑用前缀和，否则就要考虑其他算法了\n通用问题 RMQ问题 问题引入：\nRMQ(x,y) 就是询问数组 [x,y] 区间内部的最小值,\n现在如果固定区间的尾部，例如 rmq(x,7), 请问 如下序列中最少记录几个元素，满足 rmq(x,7)满足任何需求\n比如滑动窗口的最小值，我们可以用一个单调递增队列(双端队列), 头部访问 o(1) 的时间复杂度获取区间最小元素\n单调队列的本质：\n维护 固定末尾的 RMQ问题\n1 2 3 4 5 6 7 8 9 10 deque\u0026lt;int\u0026gt; q; for (int i=0;i\u0026lt;n;i++) { while(q.size() \u0026amp;\u0026amp; arr[q.back()] \u0026gt; arr[i]) q.pop_back(); q.push(arr[i]); // k = y-x if(i - q.front() \u0026lt; k ) continue; q.pop_front(); //清除过期元素 cout \u0026lt;\u0026lt; arr[q.front()] \u0026lt;\u0026lt;endl; // 滑动窗口的最小值 } 单调队列的性质 入队操作\n队尾入队，会把之前破坏单调性的元素从队尾移除（维护单调性）\n出队操作\n队列头部元素超出区间范围，就移除队头\n","date":"2022-07-30T23:30:18+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/","tags":["单调队列"],"title":"单调队列(rmq问题)"},{"categories":["单调队列"],"contents":" 239. 滑动窗口最大值 Description Difficulty: 困难\nRelated Topics: 队列 , 数组 , 滑动窗口 , 单调队列 , 堆（优先队列） 给你一个整数数组 nums，有一个大小为 k的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回 滑动窗口中的最大值 。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3 输出：[3,3,5,5,6,7] 解释： 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 示例 2：\n1 2 输入：nums = [1], k = 1 输出：[1] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 -104 \u0026lt;= nums[i] \u0026lt;= 104 1 \u0026lt;= k \u0026lt;= nums.length Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: vector\u0026lt;int\u0026gt; maxSlidingWindow(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { deque\u0026lt;int\u0026gt; q; vector\u0026lt;int\u0026gt; ans; int n = nums.size(); for (int i=0;i\u0026lt; n ;i++) { while(q.size() \u0026amp;\u0026amp; q.front() \u0026lt;= i- k ) { q.pop_front(); } while(q.size() \u0026amp;\u0026amp; nums[q.back()] \u0026lt;= nums[i]) q.pop_back(); //只要有 nums[ q.back() ] \u0026gt; nums[i] 的情况在，q.back() 永远都是最大值，如果 q.back() 小于等于 nums[i],nums[i] 为窗口的最大值，只需要存入最大值即可 ， q.push_back(i); if ( i\u0026gt;= k-1) { ans.push_back(nums[q.front()]); } } return ans; } }; ","date":"2022-07-30T23:29:17+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/","tags":["单调队列"],"title":"滑动窗口最大值"},{"categories":["单调栈"],"contents":" 84. 柱状图中最大的矩形 Description Difficulty: 困难\nRelated Topics: 栈 , 数组 , 单调栈 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n示例 1:\n1 2 3 输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 示例 2：\n1 2 输入： heights = [2,4] 输出： 4 提示：\n1 \u0026lt;= heights.length \u0026lt;=105 0 \u0026lt;= heights[i] \u0026lt;= 104 Solution Language: Go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct Rect { int w; int h; }; class Solution { public: int largestRectangleArea(vector\u0026lt;int\u0026gt;\u0026amp; heights) { stack\u0026lt;Rect\u0026gt; s; int res = 0; heights.push_back(0); //用来清空栈 for (int u: heights) { int width = 0; while(s.size() \u0026amp;\u0026amp; s.top().h \u0026gt;= u) { // 累计 width += s.top().w; res = max(res,width * s.top().h); s.pop(); } s.push({width+1, u}); } return res; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 struct Rect { int w; int h; }; class Solution { public: int largestRectangleArea(vector\u0026lt;int\u0026gt;\u0026amp; heights) { stack\u0026lt;Rect\u0026gt; s; int res = 0; // heights.push_back(0); for (int u: heights) { int width = 0; while(s.size() \u0026amp;\u0026amp; s.top().h \u0026gt;= u) { // 累计 width += s.top().w; res = max(res,width * s.top().h); s.pop(); } s.push({width+1, u}); } int width = 0; while(s.size()) { width += s.top().w; res = max(res,width * s.top().h); s.pop(); } return res; } }; ","date":"2022-07-30T22:20:31+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/%E6%9F%B1%E7%8A%B6%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/","tags":["单调栈"],"title":"柱状图的最大矩形"},{"categories":["单调栈"],"contents":"单调栈 单调栈的解题思路：\n确定递增递减，关键在于前面不能影响后面的条件 单调栈 是男一号， 第一个最大的\n目的：获取每一个元素第一个左边比他小的下标\n1 2 3 4 5 6 for (int i=0;i\u0026lt;n;i++) { while(s.size() \u0026amp;\u0026amp; arr[i] \u0026lt; arr[s.top()]) { s.pop(); } } 经典例题 单调性结合前缀和 [[lc.1124.表现良好的最长时间段.md]]\n","date":"2022-07-30T22:19:20+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/%E5%8D%95%E8%B0%83%E6%A0%88/","tags":["单调栈"],"title":"单调栈"},{"categories":["双指针"],"contents":" 15. 三数之和 Description Difficulty: 中等\nRelated Topics: 数组 , 双指针 , 排序 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 _a，b，c ，_使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。\n**注意：**答案中不可以包含重复的三元组。\n示例 1：\n1 2 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 示例 2：\n1 2 输入：nums = [] 输出：[] 示例 3：\n1 2 输入：nums = [0] 输出：[] 提示：\n0 \u0026lt;= nums.length \u0026lt;= 3000 -105 \u0026lt;= nums[i] \u0026lt;= 105 Solution Language: Go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func threeSum(nums []int) [][]int { n := len(nums) sort.Slice(nums,func(i,j int) bool { return nums[i] \u0026lt;= nums[j] }) var res = [][]int{} for i:=0;i\u0026lt;n-2;i++ { if nums[i] \u0026gt; 0 { break } if i\u0026gt;0 \u0026amp;\u0026amp; nums[i] == nums[i-1] { continue } k := n-1 for j:=i+1;j\u0026lt; k;j++ { if j \u0026gt; i+1 \u0026amp;\u0026amp; nums[j] == nums[j-1] { continue } for j\u0026lt;k \u0026amp;\u0026amp; nums[j] + nums[k] + nums[i] \u0026gt; 0 { k-- } if j \u0026lt; k \u0026amp;\u0026amp; nums[j] + nums[k] + nums[i] == 0 { res = append(res,[]int{ nums[i] ,nums[j], nums[k]}) } } } return res } // func two_sum(nums []int ,l,r,target int) []int { // res := []int{} // i:=l // j := r // for i\u0026lt;j { // for i\u0026lt;j \u0026amp;\u0026amp; nums[i] + nums[j] \u0026gt; target { j-- } // if nums[i] + nums[j] == target { // res = append(res,[]int{}) // } // } // return res // } ","date":"2022-07-30T22:11:30+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","tags":["双指针"],"title":"三数之和"},{"categories":["双指针"],"contents":" 167. 两数之和 II - 输入有序数组 Description Difficulty: 中等\nRelated Topics: 数组 , 双指针 , 二分查找 给你一个下标从 1 开始的整数数组 numbers ，该数组已按**非递减顺序排列 ** ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 \u0026lt;= index1 \u0026lt; index2 \u0026lt;= numbers.length 。\n以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1和index2。\n你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。\n你所设计的解决方案必须只使用常量级的额外空间。\n示例 1：\n1 2 3 输入：numbers = [2,7,11,15], target = 9 输出：[1,2] 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。 示例 2：\n1 2 3 输入：numbers = [2,3,4], target = 6 输出：[1,3] 解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。 示例 3：\n1 2 3 输入：numbers = [-1,0], target = -1 输出：[1,2] 解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。 提示：\n2 \u0026lt;= numbers.length \u0026lt;= 3 * 104 -1000 \u0026lt;= numbers[i] \u0026lt;= 1000 numbers 按 非递减顺序 排列 -1000 \u0026lt;= target \u0026lt;= 1000 仅存在一个有效答案 前缀和算法 代码解释\n$nums[i] + nums[j] == target$\n其中我们知道，当 nums[i] 递增的时候，nums[j] 必然递减，因为他们的和一定是 target，是一个常量，比如 $y=kx+b$ 一样，是一个一次函数，\n又因为这个数组是有序的 ，所以 nums[i] 随着 i递增而递增， $nums[j] = target - nums[i]$ ,因此 $nums[j]$ 必然是递减的\nLanguage: Go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func twoSum(numbers []int, target int) []int { n := len(numbers) l := 0 r := n -1 for l\u0026lt; r { v := numbers[l] + numbers[r] if v == target { return []int{l+1,r+1} } if v \u0026gt; target { r -- }else { l++ } } return []int{0,0} } leetcode 第一题 两数和 1. 两数之和 Description Difficulty: 简单\nRelated Topics: 数组 , 哈希表 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n示例 1：\n1 2 3 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2：\n1 2 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：\n1 2 输入：nums = [3,3], target = 6 输出：[0,1] 提示：\n2 \u0026lt;= nums.length \u0026lt;= 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 -109 \u0026lt;= target \u0026lt;= 109 只会存在一个有效答案 **进阶：**你可以想出一个时间复杂度小于 O(n2) 的算法吗？\nSolution Language: Go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func twoSum(nums []int, target int) []int { n := len(nums) temp := make([][]int,n) for i:=0;i\u0026lt;n;i++ { temp[i] = []int{nums[i],i} } sort.Slice(temp,func(i,j int) bool { return temp[i][0] \u0026lt;= temp[j][0] }) j := n-1 for i:=0;i\u0026lt;j;i++ { for i\u0026lt;j \u0026amp;\u0026amp; temp[i][0] + temp[j][0] \u0026gt; target { j-- } if temp[i][0] + temp[j][0] == target { return []int {temp[i][1],temp[j][1]} } } return []int{} } ","date":"2022-07-30T21:30:06+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C2%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","tags":["双指针"],"title":"两数之和2,有序数组"},{"categories":["双指针"],"contents":"双指针扫描 用于解决一类基于 “子段”的 统计问题\n子段: 数组中连续的一段（下标范围用一个闭区间表示）\n这类问题 朴素做法是两重循环，枚举 左右端点l和 r,优化手段是找到枚举中的冗余部分，将其去除\n优化策略通常有；\n固定右边端点，看做端点范围 例如左端点取值范围是一个前缀，可以用前缀和等算法来维护前缀信息 移动一个端点，看另一个端点变化 例如一个端点跟随另一个点单调移动，像一个滑动窗口 此时可以考虑双指针 常见例题 ","date":"2022-07-30T21:16:22+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/%E5%8F%8C%E6%8C%87%E9%92%88/","tags":["双指针"],"title":"双指针"},{"categories":["前缀和"],"contents":"算法解释 前缀和 算法不局限于求和，也可以扩展到求前缀最小值、最大值等\n二维前缀和题目 $sum(p,q,i,j)=s[i][j]-s[i][q-1]-s[p-1][j]+s[p-1][q-1]$\n练习题 加一 （Easy） 半年内出题频次：\n合并两个有序链表 （Easy） 半年内出题频次：\n设计循环双端队列 （Medium） 半年内出题频次：\n和为K的子数组 （Medium） 半年内出题频次：\n删除有序数组中的重复项 （Easy） 半年内出题频次：\n移动零 （Easy） 半年内出题频次：\n反转链表 （Easy） 半年内出题频次：\nK个一组翻转链表 （Hard） 半年内出题频次：\n邻值查找 （Medium） （ACWing）\n环形链表 （Medium） 半年内出题频次：\n环形链表 II （Medium） 半年内出题频次：\n有效的括号 （Medium） 半年内出题频次：\n最小栈 （Medium） 半年内出题频次：\n逆波兰表达式求值 （Medium） 半年内出题频次：\n基本计算器(选做) （Hard） 半年内出题频次：\n统计「优美子数组」 （Medium） 半年内出题频次：\n二维区域和检索 - 矩阵不可变 （Medium） 半年内出题频次：\n航班预订统计 （Medium） 半年内出题频次：\n最大子序和 （Easy） 半年内出题频次：\n双指针扫描、滑动窗口\n两数之和 （Easy） 半年内出题频次：\n两数之和 II - 输入有序数组 （Easy） 半年内出题频次：\n三数之和 （Medium） 半年内出题频次：\n盛最多水的容器 （Medium） 半年内出题频次：\n柱状图中最大的矩形 （Hard） 半年内出题频次：\n滑动窗口最大值 （Hard） 半年内出题频次：\n接雨水 （Hard） 半年内出题频次：\n","date":"2022-07-30T21:00:31+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C/%E5%89%8D%E7%BC%80%E5%92%8C/","tags":["前缀和"],"title":"算法解释"},{"categories":["前缀和"],"contents":" 53. 最大子数组和 Description Difficulty: 中等\nRelated Topics: 数组 , 分治 , 动态规划 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n子数组 是数组中的一个连续部分。\n示例 1：\n1 2 3 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：\n1 2 输入：nums = [1] 输出：1 示例 3：\n1 2 输入：nums = [5,4,-1,7,8] 输出：23 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 -104 \u0026lt;= nums[i] \u0026lt;= 104 **进阶：**如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。\n前缀和算法 先求出前缀和，然后再用贪心算法，求出 最小的 sum[l], 和 最大的 sum[r],\n然后 sum[r] - sum[l] 取最大，就是最大子数组和了。\n求出前缀和数组sum,枚举一个右端点 i,找到 i之前的一个 j,让 s[i] - s[j] 最大，也就是 让 s[j] 最小，再维护一个 S的前缀最小值即可。\nLanguage: Go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func min(a,b int) int { if a \u0026gt; b { return b } return a } func max(a,b int) int { if a \u0026lt; b { return b } return a } func maxSubArray(nums []int) int { n := len(nums) if n == 0 { return 0 } if n == 1 { return nums[0] } sum := make([]int,n+1) for i:=1;i\u0026lt;=n;i++ { sum[i] = nums[i-1] + sum[i-1] } //sum --\u0026gt; 前缀和范围 min_pre := sum[0] res := int(-1e10) for i:=1;i\u0026lt;=n;i++ { res = max(res,sum[i] - min_pre) min_pre = min(min_pre,sum[i]) } return res } 解法二，贪心算法 这个解法和前面前缀和解法是一样的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func min(a,b int) int { if a \u0026gt; b { return b } return a } func max(a,b int) int { if a \u0026lt; b { return b } return a } func maxSubArray(nums []int) int { n := len(nums) if n == 0 { return 0 } if n == 1 { return nums[0] } res := int(-1e10) pre := 0 for _,v := range nums { if pre \u0026lt; 0 { pre = 0 } pre += v if pre \u0026gt; res { res = pre } } return res } ","date":"2022-07-30T20:39:00+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/","tags":["前缀和"],"title":"最大子序和"},{"categories":["差分"],"contents":"leetcode 航班预定统计 1109. 航班预订统计 Description Difficulty: 中等\nRelated Topics: 数组 , 前缀和 这里有 n 个航班，它们分别从 1 到 n 进行编号。\n有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。\n请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5 输出：[10,55,45,25,25] 解释： 航班编号 1 2 3 4 5 预订记录 1 ： 10 10 预订记录 2 ： 20 20 预订记录 3 ： 25 25 25 25 总座位数： 10 55 45 25 25 因此，answer = [10,55,45,25,25] 示例 2：\n1 2 3 4 5 6 7 8 输入：bookings = [[1,2,10],[2,2,15]], n = 2 输出：[10,25] 解释： 航班编号 1 2 预订记录 1 ： 10 10 预订记录 2 ： 15 总座位数： 10 25 因此，answer = [10,25] 提示：\n1 \u0026lt;= n \u0026lt;= 2 * 104 1 \u0026lt;= bookings.length \u0026lt;= 2 * 104 bookings[i].length == 3 1 \u0026lt;= firsti \u0026lt;= lasti \u0026lt;= n 1 \u0026lt;= seatsi \u0026lt;= 104 Solution Language: Go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: vector\u0026lt;int\u0026gt; corpFlightBookings(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; bookings, int n) { int maxn = 0; for(auto \u0026amp;booking: bookings) { int first = booking[0],second = booking[1]; int num = booking[2]; maxn = max(maxn,second); } vector\u0026lt;int\u0026gt; d(maxn+3); for(auto \u0026amp;booking: bookings) { int first = booking[0],second = booking[1]; int num = booking[2]; d[first] += num; d[second+1] -= num; } vector\u0026lt;int\u0026gt; res(n,0) ; int all =0; for (int i=0;i\u0026lt;n;i++) { all+= d[i+1]; res[i] = all; } #ifdef debug printa(d); printa(res); #endif return res; } } 差分法 理解增量的含义：\n注意到一个预订记录实际上代表了一个区间的增量。我们的任务是将这些增量叠加得到答案。因此，我们可以使用差分解决本题。\n任务区间操作，可以转为两个关键点（事件），事件的影响从l开始，从r+1 处消失\n差分可以解决区间覆盖问题\n增量叠加起来 就是数量 【类似于微积分这种】\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func corpFlightBookings(bookings [][]int, n int) []int { sum := make([]int,n+1) for _,e := range bookings { first := e[0] last := e[1] add := e[2] sum[first-1] += add sum[last] -= add } for i:=1;i\u0026lt;=n;i++ { sum[i] += sum[i-1] } return sum[0:n] } ","date":"2022-07-30T18:24:21+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E5%B7%AE%E5%88%86/leetcode.1109%E8%88%AA%E7%8F%AD%E9%A2%84%E5%AE%9A%E7%BB%9F%E8%AE%A1/","tags":["差分"],"title":"leetcode.1109航班预定统计"},{"categories":["图论"],"contents":"可达性统计 ","date":"2022-07-16T16:05:46+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/ac.%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%BB%9F%E8%AE%A1/","tags":["图论"],"title":"ac.可达性统计"},{"categories":["状态转移"],"contents":" 10. 正则表达式匹配 Description Difficulty: 困难\nRelated Topics: 递归 , 字符串 , 动态规划 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。\n'.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 **整个 **字符串 s的，而不是部分字符串。\n示例 1：\n1 2 3 输入：s = \u0026#34;aa\u0026#34;, p = \u0026#34;a\u0026#34; 输出：false 解释：\u0026#34;a\u0026#34; 无法匹配 \u0026#34;aa\u0026#34; 整个字符串。 示例 2:\n1 2 3 输入：s = \u0026#34;aa\u0026#34;, p = \u0026#34;a*\u0026#34; 输出：true 解释：因为 \u0026#39;*\u0026#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 \u0026#39;a\u0026#39;。因此，字符串 \u0026#34;aa\u0026#34; 可被视为 \u0026#39;a\u0026#39; 重复了一次。 示例 3：\n1 2 3 输入：s = \u0026#34;ab\u0026#34;, p = \u0026#34;.*\u0026#34; 输出：true 解释：\u0026#34;.*\u0026#34; 表示可匹配零个或多个（\u0026#39;*\u0026#39;）任意字符（\u0026#39;.\u0026#39;）。 提示：\n1 \u0026lt;= s.length \u0026lt;= 20 1 \u0026lt;= p.length \u0026lt;= 30 s 只包含从 a-z 的小写字母。 p 只包含从 a-z 的小写字母，以及字符 . 和 *。 保证每次出现字符 * 时，前面都匹配到有效的字符 Solution Language: JavaScript\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 /* * @lc app=leetcode.cn id=10 lang=cpp * * [10] 正则表达式匹配 */ // @lc code=start class Solution { public: bool isMatch(string s, string p) { int n = s.size(), m = p.size(); if(!n || !m) return false; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;bool\u0026gt;(m + 1)); dp[0][0] = true; //传递 for (int i = 1; i \u0026lt;= m; i ++) { if (p[i-1] == \u0026#39;*\u0026#39;) dp[0][i] = dp[0][i - 2]; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { // case 1: p== * // case 2: p== . // case 3: p==s // char pp = p[j - 1], ss = s[i - 1]; if ( p[j-1] == \u0026#39;.\u0026#39; || p[j-1] == s[i-1]) { dp[i][j] = dp[i - 1][j - 1]; } else if ( p[j-1] == \u0026#39;*\u0026#39; ) { // match 1 if (p[j - 2] == \u0026#39;.\u0026#39; || p[j - 2] == s[i - 1]) { // s=\u0026#34;aa\u0026#34; // p=\u0026#34;.*\u0026#34; dp[i][j] = dp[i][j-2] || dp[i-1][j-2]||dp[i-1][j]; } else { // empty match // \u0026#34;aaaa\u0026#34; // \u0026#34;aaaa*\u0026#34; dp[i][j] = dp[i][j - 2]; // 不匹配 } } } } return dp[n][m]; } }; // @lc code=end ","date":"2022-06-30T20:32:51+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BBdp/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","tags":["状态转移"],"title":"正则表达式匹配"},{"categories":["双指针"],"contents":" 11. 盛最多水的容器 Description Difficulty: 中等\nRelated Topics: 贪心 , 数组 , 双指针 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n返回容器可以储存的最大水量。\n**说明：**你不能倾斜容器。\n示例 1：\n1 2 3 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 2：\n1 2 输入：height = [1,1] 输出：1 提示：\nn == height.length 2 \u0026lt;= n \u0026lt;= 105 0 \u0026lt;= height[i] \u0026lt;= 104 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* * @lc app=leetcode.cn id=11 lang=cpp * * [11] 盛最多水的容器 */ // @lc code=start class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int w = height.size(); int l=0,r = w-1; int expect = 0; int calc_area=0; while(l\u0026lt;r) { calc_area = (r-l) * min(height[l],height[r]); if(expect \u0026lt; calc_area) { expect = calc_area; } if(height[l] \u0026gt;= height[r]) --r; else l++; } return expect; } }; // @lc code=end 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func min(a,b int) int { if a\u0026gt;b { return b } return a } func max(a,b int) int { if a\u0026gt;b { return a } return b } func maxArea(height []int) int { n := len(height) j := n - 1 res := 0 i:=0 for i \u0026lt; j { h := min(height[i],height[j]) res = max(res,h * (j-i)) if height[i] \u0026gt; height[j] { j-- }else { i++ } } return res } 双指针\r","date":"2022-06-30T19:44:59+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","tags":["双指针"],"title":"最多水的容器"},{"categories":["回溯搜索"],"contents":" 282. 给表达式添加运算符 Description Difficulty: 困难\nRelated Topics: 数学 , 字符串 , 回溯 给定一个仅包含数字 0-9 的字符串 num 和一个目标值整数 target ，在 num 的数字之间添加 二元 运算符（不是一元）+、- 或 * ，返回 所有 能够得到 target 的表达式。\n注意，返回表达式中的操作数 不应该 包含前导零。\n示例 1:\n1 2 3 输入: num = \u0026#34;123\u0026#34;, target = 6 输出: [\u0026#34;1+2+3\u0026#34;, \u0026#34;1*2*3\u0026#34;] 解释: “1*2*3” 和 “1+2+3” 的值都是6。 示例 2:\n1 2 3 输入: num = \u0026#34;232\u0026#34;, target = 8 输出: [\u0026#34;2*3+2\u0026#34;, \u0026#34;2+3*2\u0026#34;] 解释: “2*3+2” 和 “2+3*2” 的值都是8。 示例 3:\n1 2 3 输入: num = \u0026#34;3456237490\u0026#34;, target = 9191 输出: [] 解释: 表达式 “3456237490” 无法得到 9191 。 提示：\n1 \u0026lt;= num.length \u0026lt;= 10 num 仅含数字 -231 \u0026lt;= target \u0026lt;= 231 - 1 Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /* * @lc app=leetcode.cn id=282 lang=cpp * * [282] 给表达式添加运算符 */ // @lc code=start class Solution { public: vector\u0026lt;string\u0026gt; addOperators(string num, int target) { vector\u0026lt;string\u0026gt; res; string path; path.resize(100); dfs(res,path,0,num,0,0,1,target); return res; } void dfs(vector\u0026lt;string\u0026gt; \u0026amp;res,string \u0026amp;path,int len,string \u0026amp;nums,int cur,long long a,long long b,int target) { if(cur\u0026gt;nums.size()) return; if(cur == nums.size()) { if(target == a) res.push_back(path.substr(0,len-1)); return; } long long c=0; int n = nums.size(); for(int i=cur;i\u0026lt;n;i++) { c = c*10+(nums[i] - \u0026#39;0\u0026#39;); path[len++] = nums[i]; path[len] = \u0026#39;+\u0026#39;; /* +, a+b*c + () a+b+1*(?) -, a+b*c - () =\u0026gt; a+b -1*(?) *, a+b*c* () =\u0026gt; a+ (b*c)*(?) */ dfs(res,path,len+1,nums,i+1,a+b*c,1,target); // dfs(res,path,num,i+1,sum,) if(i+1\u0026lt;n) { path[len] = \u0026#39;-\u0026#39;; dfs(res,path,len+1,nums,i+1,a+b*c,-1,target); path[len] = \u0026#39;*\u0026#39;; dfs(res,path,len+1,nums,i+1,a,b*c,target); } if(nums[cur] == \u0026#39;0\u0026#39;) break; } } }; // @lc code=end ","date":"2022-06-11T18:24:29+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E6%90%9C%E7%B4%A2/leetcode.282.%E7%BB%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B7%BB%E5%8A%A0%E8%BF%90%E7%AE%97%E7%AC%A6/","tags":["回溯搜索"],"title":"leetcode.282.给表达式添加运算符"},{"categories":["序列边界"],"contents":" 410. 分割数组的最大值 Description Difficulty: 困难\nRelated Topics: 贪心 , 数组 , 二分查找 , 动态规划 给定一个非负整数数组 nums 和一个整数 m ，你需要将这个数组分成 m个非空的连续子数组。\n设计一个算法使得这 m个子数组各自和的最大值最小。\n示例 1：\n1 2 3 4 5 6 输入：nums = [7,2,5,10,8], m = 2 输出：18 解释： 一共有四种方法将 nums 分割为 2 个子数组。 其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。 因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。 示例 2：\n1 2 输入：nums = [1,2,3,4,5], m = 2 输出：9 示例 3：\n1 2 输入：nums = [1,4,4], m = 3 输出：4 提示：\n1 \u0026lt;= nums.length \u0026lt;= 1000 0 \u0026lt;= nums[i] \u0026lt;= 106 1 \u0026lt;= m \u0026lt;= min(50, nums.length) Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* * @lc app=leetcode.cn id=410 lang=cpp * * [410] 分割数组的最大值 */ // @lc code=start class Solution { public: int splitArray(vector\u0026lt;int\u0026gt;\u0026amp; nums, int m) { int n = nums.size();//分割 m份 int sum=0; for(int u:nums) sum+= u; int l=0,r = sum; // int res=0; while(l\u0026lt;r) { int x = ( l+r )/2; if(canSplit(nums,x,m)) { r = x; }else { //太j大了 l=x+1; } } return r; } bool canSplit(vector\u0026lt;int\u0026gt; \u0026amp; a,int min,int m) { int n = a.size(); int sum = 0; int cnt = 0; for(int i=0;i\u0026lt;n;i++) { if(a[i] \u0026gt; min) return false; if(sum+a[i] \u0026gt; min ) { cnt++; sum = a[i]; }else { sum += a[i]; } } return cnt \u0026lt;= m; } }; // @lc code=end 「将数组分割为 m 段，求……」是动态规划题目常见的问法。\n动态规划思路 令 f[i][j] 表示将数组的前 i 个数分割为 j 段所能得到的最大连续子数组和的最小值。在进行状态转移时，我们可以考虑第 j 段的具体范围，即我们可以枚举 k ，其中前 k 个数被分割为 j-1 段，而第 k+1 到第 i 个数为第 j 段。此时，这 j 段子数组中和的最大值，就等于 f[k][j-1] 与 sub(k+1,i) 中的较大值，其中 sub(i,j) 表示数组 nums 中下标落在区间 [i,j] 内的数的和。\n作者：LeetCode-Solution\n链接： https://leetcode.cn/problems/split-array-largest-sum/solution/fen-ge-shu-zu-de-zui-da-zhi-by-leetcode-solution/ 来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int splitArray(vector\u0026lt;int\u0026gt;\u0026amp; nums, int m) { vector\u0026lt;long long\u0026gt; sum(nums.size()+1); int n = nums.size(); for(int i=1;i\u0026lt;=n;i++) sum[i] += (sum[i-1] + nums[i-1]); vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; dp(n+1,vector\u0026lt;long long\u0026gt;(m+1,LONG_MAX)); for(int i=1;i\u0026lt;=n;i++) { dp[i][1] = sum[i];// 前i 个 1组 // 前 i个 一共 m组 for(int j=1;j\u0026lt;=min(i,m);j++) { for(int k=0;k\u0026lt;i;k++) { dp[i][j] = min(dp[i][j],max(dp[k][j-1], sum[i] - sum[k])); } } } return dp[n][m]; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int splitArray(vector\u0026lt;int\u0026gt;\u0026amp; nums, int m) { vector\u0026lt;long long\u0026gt; sum(nums.size()+1); int n = nums.size(); for(int i=1;i\u0026lt;=n;i++) sum[i] += (sum[i-1] + nums[i-1]); vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; dp(n+1,vector\u0026lt;long long\u0026gt;(m+1,INT_MAX)); dp[0][0] = 0; for(int i=1;i\u0026lt;=n;i++) { //dp[i][1] = sum[i];// 前i 个 1组 // 前 i个 一共 m组 for(int j=1;j\u0026lt;=min(i,m);j++) { for(int k=0;k\u0026lt;i;k++) { // max(不分配， 分配(i-k)) dp[i][j] = min(dp[i][j],max(dp[k][j-1], sum[i] - sum[k])); } } } return dp[n][m]; } }; ","date":"2022-06-11T17:28:23+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E5%BA%8F%E5%88%97%E5%88%92%E5%88%86dp/leetcode.410.%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","tags":["序列边界"],"title":"leetcode.410.分割数组的最大值"},{"categories":["计算数量"],"contents":" 413. 等差数列划分 Description Difficulty: 中等\nRelated Topics: 数组 , 动态规划 如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。\n例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。 给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。\n子数组 是数组中的一个连续序列。\n示例 1：\n1 2 3 输入：nums = [1,2,3,4] 输出：3 解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。 示例 2：\n1 2 输入：nums = [1] 输出：0 提示：\n1 \u0026lt;= nums.length \u0026lt;= 5000 -1000 \u0026lt;= nums[i] \u0026lt;= 1000 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* * @lc app=leetcode.cn id=413 lang=cpp * * [413] 等差数列划分 */ // @lc code=start class Solution { public: int numberOfArithmeticSlices(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if(nums.size() \u0026lt; 3) return 0; int sequence = 0; int res=0; for(int i=2,n = nums.size();i\u0026lt;n;i++) { if(nums[i-1]- nums[i-2] == nums[i] - nums[i-1]) { res += ++sequence; }else { sequence = 0; } } return res; } }; // @lc code=end 解法2 ，动态规划 动态规划本质和上面这个是一样的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int numberOfArithmeticSlices(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if(nums.size() \u0026lt; 3) return 0; int n = nums.size(); vector\u0026lt;int\u0026gt; dp(n+1); for(int i=2;i\u0026lt;n;i++) { if(nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) { dp[i] = dp[i-1] + 1; } } int res=0; for(int u:dp) res+= u; return res; } }; ","date":"2022-06-11T16:39:30+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E8%AE%A1%E7%AE%97%E6%95%B0%E9%87%8F/leetcode.413.%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/","tags":["计算数量"],"title":"leetcode.413.等差数列划分"},{"categories":["计算数量"],"contents":" 62. 不同路径 Description Difficulty: 中等\nRelated Topics: 数学 , 动态规划 , 组合数学 一个机器人位于一个 m x n网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n问总共有多少条不同的路径？\n示例 1：\n1 2 输入：m = 3, n = 7 输出：28 示例 2：\n1 2 3 4 5 6 7 输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 1\\. 向右 -\u0026gt; 向下 -\u0026gt; 向下 2\\. 向下 -\u0026gt; 向下 -\u0026gt; 向右 3\\. 向下 -\u0026gt; 向右 -\u0026gt; 向下 示例 3：\n1 2 输入：m = 7, n = 3 输出：28 示例 4：\n1 2 输入：m = 3, n = 3 输出：6 提示：\n1 \u0026lt;= m, n \u0026lt;= 100 题目数据保证答案小于等于 2 * 109 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* * @lc app=leetcode.cn id=62 lang=cpp * * [62] 不同路径 */ // @lc code=start class Solution { public: int uniquePaths(int m, int n) { vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; dp(m+1,vector\u0026lt;int\u0026gt;(n+1)); for(int i=1;i\u0026lt;=n;i++) dp[0][i] = 1; for(int j=1;j\u0026lt;=m;j++) dp[j][0] = 1; dp[0][0] = 1; for(int i=1;i\u0026lt;m;i++) { for(int j=1;j\u0026lt;n;j++) { dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m-1][n-1]; } }; // @lc code=end 不同路径2 63. 不同路径 II Description Difficulty: 中等\nRelated Topics: 数组 , 动态规划 , 矩阵 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n网格中的障碍物和空位置分别用 1 和 0 来表示。\n示例 1：\n1 2 3 4 5 6 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] 输出：2 解释：3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1\\. 向右 -\u0026gt; 向右 -\u0026gt; 向下 -\u0026gt; 向下 2\\. 向下 -\u0026gt; 向下 -\u0026gt; 向右 -\u0026gt; 向右 示例 2：\n1 2 输入：obstacleGrid = [[0,1],[0,0]] 输出：1 提示：\nm == obstacleGrid.length n == obstacleGrid[i].length 1 \u0026lt;= m, n \u0026lt;= 100 obstacleGrid[i][j] 为 0 或 1 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* * @lc app=leetcode.cn id=63 lang=cpp * * [63] 不同路径 II */ // @lc code=start class Solution { public: int uniquePathsWithObstacles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; a) { int n = a.size(); if(!n) return 0; int m = a[0].size(); if(!m) return 0; if(a[0][0]) return 0; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;dp(n+1,vector\u0026lt;int\u0026gt; (m+1)) ; // dp[0][0] = 1; for(int i=0;i\u0026lt;n \u0026amp;\u0026amp; a[i][0]==0;i++) dp[i][0] = 1; for(int j=1;j\u0026lt;m \u0026amp;\u0026amp; a[0][j] == 0;j++) dp[0][j] = 1; for(int i=1;i\u0026lt;n;i++) for(int j=1;j\u0026lt;m;j++) { if(a[i][j]) continue; dp[i][j] = dp[i-1][j] + dp[i][j-1]; } return dp[n-1][m-1]; } }; // @lc code=end ","date":"2022-06-11T15:49:28+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E8%AE%A1%E7%AE%97%E6%95%B0%E9%87%8F/leetcode.62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/","tags":["计算数量"],"title":"leetcode.62.不同路径"},{"categories":["计算次数"],"contents":" 926. 将字符串翻转到单调递增 Description Difficulty: 中等\nRelated Topics: 字符串 , 动态规划 如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。\n给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。\n返回使 s 单调递增的最小翻转次数。\n示例 1：\n1 2 3 输入：s = \u0026#34;00110\u0026#34; 输出：1 解释：翻转最后一位得到 00111. 示例 2：\n1 2 3 输入：s = \u0026#34;010110\u0026#34; 输出：2 解释：翻转得到 011111，或者是 000111。 示例 3：\n1 2 3 输入：s = \u0026#34;00011000\u0026#34; 输出：2 解释：翻转得到 00000000。 提示：\n1 \u0026lt;= s.length \u0026lt;= 105 s[i] 为 '0' 或 '1' Solution Language: C++\n解题思路 这个题是利用前缀和，然后枚举分界点，\n可以把 找到某个分界点a，让 a前面翻转的 1 最少，a后面翻转的 0 最少，这个a就是 分界点的位置，也就是答案的解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* * @lc app=leetcode.cn id=926 lang=cpp * * [926] 将字符串翻转到单调递增 */ // @lc code=start class Solution { public: int minFlipsMonoIncr(string str) { int n = str.size(); vector\u0026lt;int\u0026gt; s(n+1) ; for (int i = 1; i \u0026lt;= n; i++) { s[i] = s[i-1] + (str[i-1] - \u0026#39;0\u0026#39;); } int cnt0_ = n - s[n];//0的个数 int res = cnt0_;// 000xxx 1111 xxxx for(int i=1;i\u0026lt;=n;i++) { //枚举分界点 //前面1的个数 int cnt1 = s[i]; int cnt0 = (n-i) - (s[n] - s[i]);//后面0的个数 res = min(res,cnt1+cnt0); } return res; } }; // @lc code=end ","date":"2022-06-11T15:22:02+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E8%AE%A1%E7%AE%97%E6%AC%A1%E6%95%B0/926.%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BF%BB%E8%BD%AC%E5%88%B0%E9%80%92%E5%A2%9E/","tags":["计算次数"],"title":"926.将字符串翻转到递增"},{"categories":["位运算"],"contents":" 393. UTF-8 编码验证 Description Difficulty: 中等\nRelated Topics: 位运算 , 数组 给定一个表示数据的整数数组 data ，返回它是否为有效的 UTF-8 编码。\nUTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：\n对于 1 字节 的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。 对于 n 字节 的字符 (n \u0026gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。 这是 UTF-8 编码的工作方式：\n1 2 3 4 5 6 7 Number of Bytes | UTF-8 octet sequence | (binary) --------------------+--------------------------------------------- 1 | 0xxxxxxx 2 | 110xxxxx 10xxxxxx 3 | 1110xxxx 10xxxxxx 10xxxxxx 4 | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx x 表示二进制形式的一位，可以是 0 或 1。\n**注意：**输入是整数数组。只有每个整数的 最低 8 个有效位 用来存储数据。这意味着每个整数只表示 1 字节的数据。\n示例 1：\n1 2 3 4 输入：data = [197,130,1] 输出：true 解释：数据表示字节序列:11000101 10000010 00000001。 这是有效的 utf-8 编码，为一个 2 字节字符，跟着一个 1 字节字符。 示例 2：\n1 2 3 4 5 6 输入：data = [235,140,4] 输出：false 解释：数据表示 8 位的序列: 11101011 10001100 00000100. 前 3 位都是 1 ，第 4 位为 0 表示它是一个 3 字节字符。 下一个字节是开头为 10 的延续字节，这是正确的。 但第二个延续字节不以 10 开头，所以是不符合规则的。 提示:\n1 \u0026lt;= data.length \u0026lt;= 2 * 104 0 \u0026lt;= data[i] \u0026lt;= 255 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /* * @lc app=leetcode.cn id=393 lang=cpp * * [393] UTF-8 编码验证 */ // @lc code=start class Solution { public: bool validUtf8(vector\u0026lt;int\u0026gt;\u0026amp; data) { int n = data.size(); #define len1 0b10000000 #define len2 0b11000000 #define len3 0b11100000 #define len4 0b11110000 #define len5 0b11111000 for(int i=0;i\u0026lt;n;i++) { int len=0; if((data[i] \u0026amp; len1) == 0) { len=1; // 第1位是0 }else if((data[i] \u0026amp; len3) == len2 ) { len=2; }else if((data[i] \u0026amp; len4) == len3) { len=3; }else if((data[i] \u0026amp; len5) == len4) { len = 4; }else return false; for(int j=1;j\u0026lt;len;j++) { int t=i+j; if(t\u0026gt;=n) return false; if((data[t] \u0026amp; len2) != len1 ) { return false; } } i+=len-1; } return true; } }; // @lc code=end ","date":"2022-06-11T14:30:50+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/393%E9%AA%8C%E8%AF%81utf8%E7%BC%96%E7%A0%81/","tags":["位运算"],"title":"393验证utf8编码"},{"categories":["博弈问题"],"contents":"石子游戏 1 Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，排成一行；每堆都有 正 整数颗石子，数目为 piles[i] 。\n游戏以谁手中的石子最多来决出胜负。石子的 总数 是 奇数 ，所以没有平局。\nAlice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的 开始 或 结束 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 石子最多 的玩家 获胜 。\n假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。\n示例 1：\n**输入：**piles = [5,3,4,5]\n**输出：**true\n解释：\nAlice 先开始，只能拿前 5 颗或后 5 颗石子 。\n假设他取了前 5 颗，这一行就变成了 [3,4,5] 。\n如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。\n如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。\n这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。\n示例 2：\n**输入：**piles = [3,7,2,3]\n**输出：**true\n提示：\n2 \u0026lt;= piles.length \u0026lt;= 500 piles.length 是 偶数 1 \u0026lt;= piles[i] \u0026lt;= 500 sum(piles[i]) 是 奇数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* * @lc app=leetcode.cn id=877 lang=cpp * * [877] 石子游戏 */ // @lc code=start class Solution { public: bool stoneGame(vector\u0026lt;int\u0026gt;\u0026amp; piles) { int n = piles.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n+1,vector\u0026lt;int\u0026gt;(n+1,0)); //dp[1][n] \u0026gt; 0 表示 Alice 能赢，把比较 问题变成正负号的问题 for(int i=0;i\u0026lt;n;i++) for(int j=1;j\u0026lt;=n;j++) dp[i][j] = piles[i]; for(int i=n-1;i\u0026gt;=0;i--) { for(int j=i+1;j\u0026lt;n;j++) { //i j dp[i][j] = max(piles[i] - dp[i+1][j],piles[j] - dp[i][j-1]); } } return dp[0][n-1] \u0026gt;= 0; } }; // @lc code=end ","date":"2022-06-11T13:18:42+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/877.%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/","tags":["博弈问题"],"title":"877.石子游戏"},{"categories":["堆"],"contents":"给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\n示例 1:\n输入: nums = [1,1,1,2,2,3], k = 2\n输出: [1,2]\n示例 2:\n输入: nums = [1], k = 1\n输出: [1]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* * @lc app=leetcode.cn id=347 lang=cpp * * [347] 前 K 个高频元素 */ // @lc code=start class Solution { public: vector\u0026lt;int\u0026gt; topKFrequent(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { unordered_map\u0026lt;int,int\u0026gt; mp ; for(int u:nums) mp[u]++; #define HeapItem pair\u0026lt;int,int\u0026gt; #define less(l,r) l.second \u0026gt; r.second struct Compare { bool operator() (HeapItem \u0026amp;l,HeapItem \u0026amp;r) { return less(l,r); }; }; priority_queue\u0026lt;HeapItem,vector\u0026lt;HeapItem\u0026gt;,Compare\u0026gt; q; for(auto pir:mp) { q.push(pir); if(q.size() \u0026gt; k) q.pop(); } vector\u0026lt;int\u0026gt; res(k); int i=0; while(q.size()) { auto t = q.top();q.pop(); res[i++] = t.first; } return res; } }; // @lc code=end ","date":"2022-06-11T01:37:53+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/347.%E9%AB%98%E9%A2%91%E6%95%B0%E5%AD%97/","tags":["堆"],"title":"347.前k个高频元素"},{"categories":["堆"],"contents":" 23. 合并K个升序链表 Description Difficulty: 困难\nRelated Topics: 链表 , 分治 , 堆（优先队列） , 归并排序 给你一个链表数组，每个链表都已经按升序排列。\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 解释：链表数组如下： [ 1-\u0026gt;4-\u0026gt;5, 1-\u0026gt;3-\u0026gt;4, 2-\u0026gt;6 ] 将它们合并到一个有序链表中得到。 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5-\u0026gt;6 示例 2：\n1 2 输入：lists = [] 输出：[] 示例 3：\n1 2 输入：lists = [[]] 输出：[] 提示：\nk == lists.length 0 \u0026lt;= k \u0026lt;= 10^4 0 \u0026lt;= lists[i].length \u0026lt;= 500 -10^4 \u0026lt;= lists[i][j] \u0026lt;= 10^4 lists[i] 按 升序 排列 lists[i].length 的总和不超过 10^4 Solution Language: C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /* * @lc app=leetcode.cn id=23 lang=cpp * * [23] 合并K个升序链表 */ // @lc code=start /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode *mergeKLists(vector\u0026lt;ListNode *\u0026gt; \u0026amp;lists) { if(lists.size() == 0) return NULL; #define HeapItem pair\u0026lt;int,ListNode*\u0026gt; struct Compare { bool operator() (HeapItem \u0026amp;l,HeapItem \u0026amp;r) { return l.first \u0026gt;= r.first; }; }; priority_queue\u0026lt;HeapItem,vector\u0026lt;HeapItem\u0026gt;,Compare\u0026gt; q; for(auto lstNode: lists) { if(lstNode) q.push({lstNode-\u0026gt;val,lstNode}); } ListNode head; ListNode* p = \u0026amp;head; while(q.size()) { auto temp = q.top();q.pop(); ListNode* lst = temp.second; p-\u0026gt;next = lst; p = p-\u0026gt;next; if(lst-\u0026gt;next) { q.push({lst-\u0026gt;next-\u0026gt;val,lst-\u0026gt;next}); } } return head.next; } }; // @lc code=end 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 struct Node { int key; ListNode* node; // bool operator \u0026lt; (const Node \u0026amp;b) const { // return key \u0026gt; b.key; // } }; bool operator \u0026lt; (const Node\u0026amp;a, const Node \u0026amp;b ) { return a.key \u0026gt; b.key; } class Solution { public: ListNode* mergeKLists(vector\u0026lt;ListNode*\u0026gt;\u0026amp; lists) { if(lists.size()\u0026lt;=0) return NULL; priority_queue\u0026lt;Node \u0026gt; q; for (ListNode *temp : lists) { if (temp) q.push ({temp-\u0026gt;val,temp}); } ListNode fake; ListNode *p = \u0026amp;fake; while(!q.empty()) { auto pnode = q.top();q.pop(); p-\u0026gt;next = pnode.node; // p = p-\u0026gt;next; p = p-\u0026gt;next; if(pnode.node-\u0026gt;next) { q.push({pnode.node-\u0026gt;next-\u0026gt;val,pnode.node-\u0026gt;next}); } } return fake.next; } }; 手写堆 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #define Node ListNode class Heap { public: vector\u0026lt;Node*\u0026gt; heap; void push(Node* node) { heap.push_back(node); int p = heap.size() -1 ; while (p \u0026gt; 0) { int fa = (p-1)/2; if (heap[p]-\u0026gt;val \u0026lt; heap[fa] -\u0026gt;val ) { swap(heap[p],heap[fa]); p = fa; }else { break; } } } Node* pop() { Node * res = heap[0]; swap(heap[heap.size()-1],heap[0]); heap.pop_back(); int p = 0; //向下调整 int child = p*2 + 1; // int rchild = p*2+2; while(child \u0026lt; heap.size()) { //child 未出界 int rchild = p*2+2; if(rchild\u0026lt; heap.size() \u0026amp;\u0026amp; heap[child]-\u0026gt;val \u0026gt; heap[rchild]-\u0026gt;val) { child = rchild; } if (heap[p]-\u0026gt;val \u0026gt; heap[child]-\u0026gt;val) { swap(heap[child],heap[p]); p = child; child = p*2+1; }else { break; } } return res; } }; class Solution { public: ListNode* mergeKLists(vector\u0026lt;ListNode*\u0026gt;\u0026amp; lists) { if(lists.size()\u0026lt;=0) return NULL; Heap heap; for (Node * n:lists) { if(n) heap.push(n); } Node fake = {-1,NULL}; Node *curr = \u0026amp;fake; while(heap.heap.size()) { Node * x = heap.pop(); // if (!x) break; if (!x) continue; curr-\u0026gt;next = x; curr = curr-\u0026gt;next; if(x-\u0026gt;next) { heap.push(x-\u0026gt;next); } } return fake.next; } }; ","date":"2022-06-11T01:24:49+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/23.%E5%90%88%E5%B9%B6%E5%89%8Dk%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/","tags":["堆"],"title":"23.合并前k个升序链表"},{"categories":["python语法"],"contents":"yield 生成器语法 1 2 3 4 5 6 7 8 9 10 def fab(max): n, a, b = 0, 0, 1 while n \u0026lt; max: yield b # 使用 yield # print b a, b = b, a + b n = n + 1 for n in fab(5): print n 通过这个 yield ,我们就不需要在 while 循环里面 使用 print 函数了， 而是 for 循环里面使用\n，yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator，调用 fab(5) 不会执行 fab 函数，而是返回一个 iterable 对象\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt;\u0026gt;\u0026gt;f = fab(5) \u0026gt;\u0026gt;\u0026gt; f.next() 1 \u0026gt;\u0026gt;\u0026gt; f.next() 1 \u0026gt;\u0026gt;\u0026gt; f.next() 2 \u0026gt;\u0026gt;\u0026gt; f.next() 3 \u0026gt;\u0026gt;\u0026gt; f.next() 5 \u0026gt;\u0026gt;\u0026gt; f.next() ","date":"2022-05-18T11:40:28+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python%E8%AF%AD%E6%B3%95/yield%E7%94%9F%E6%88%90%E5%99%A8/","tags":["python语法"],"title":"yield生成器"},{"categories":["notes"],"contents":"学习网站收集 学前端 学前端2 ","date":"2022-05-18T00:25:33+08:00","permalink":"https://lyr-2000.github.io/code/post/notes/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/","tags":["notes"],"title":"学习网站"},{"categories":["python语法"],"contents":"函数定义 参考学习教程 脚本中函数定义要放在函数调用之前，因为这是解释型语言\n1 2 3 4 def say(); print(\u0026#34;hello world\u0026#34;) say() # say调用放在定义之后 注释 名字 描述 单行注释 #, 注意，函数单行注释到函数定义要留有两个空行，这是标准 多行注释 \u0026quot;\u0026quot;\u0026quot;, \u0026quot;\u0026quot;\u0026quot; 函数的文档注释 开发中希望给函数添加注释，注释应该定义在函数的下方，用三对引号括起来 三对引号之间编写行说明文字 函数调用位置 使用快捷键，ctrl j ctrl j ,就可以查看函数说明信息 1 2 3 4 5 6 7 8 9 10 11 12 # python 解释知道下面定义了一个函数 def print_line(char,times): \u0026#34;\u0026#34;\u0026#34; :param char: 分割线使用的分割支付 :param times: 分割线的长度 \u0026#34;\u0026#34;\u0026#34; print(char * times) 概念 理解 形参 形式参数，函数定义的 实参 实际传入的参数 模块定义 参考文档 新建一个 mylib.py 文件， 通过 import语句可以导入 这个包模块，很像golang的写法\n1 2 def libExample(): print(\u0026#39;lib example\u0026#39;) 1 2 3 4 # import requests import mylib mylib.libExample() pycache原理 python会把 python模块 编译为 pyc文件，导入的时候，就会进行编译，再次执行同一个模块的话，效率就会提高\n变量类型 python 分为数字型和非数字型\n数值型\n整形，int 浮点 ，float 布尔，bool 复数 ，complex 非数字型\n字符串 列表 元组 字典 所有非数字型变量都支持下面的特点：\n都是 序列，sequence 取值 [] 遍历 for in 计算长度，最大，最小值，比较、删除 链接 + ，和重复 * 切片 [:] 列表的操作 终端输入 ipython3, 输入 name = [] ,name. 和 tab键， ipython就会自动显示出这个列表有哪些方法可以调用，比如 append,count,reverse,sort 等方法\ndel关键字删除 删除列表的方法：\nli.remove(obj) li.pop(idx) del li[idx] del 是一个关键字，用来表示删除对象释放内存\n数组排序 1 2 3 4 5 6 7 8 name = [3,4,11,1] name.sort() print(name) name.sort(reverse=True) print(name) name.reverse() print(name) 1 2 3 4 5 6 7 # arr.sort 是 内部排序 # sorted 是全局函数，返回一个新的排序后的数组 li = [3,4,666,1,3,2] li=sorted(li,key=lambda x:-x) print(li) 切片 li[idx:len] 返回一个切片数组\n1 2 3 4 5 6 7 8 9 li = [1,2,3] li2 = li[0:1] print(li2) li[0] = 555 print(li) 切片返回的是引用，修改切片后，原切片也会修改\n内置函数 方法 描述 len 返回元素个数 del 删除变量 max 返回容器最大值 min 返回容器最小值 cmp 比较两个值，返回0,-1,1等,python3 取消了cmp函数 id 返回对象地址 运算符 大于等于小于就不说了，这里解释一下成员运算符\nin not in 分别表示判断元素是否在序列中\n","date":"2022-05-18T00:24:40+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python%E8%AF%AD%E6%B3%95/%E5%87%BD%E6%95%B0/","tags":["python语法"],"title":"函数"},{"categories":["栈"],"contents":"\r编译原理\r栈\r给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。\n整数除法仅保留整数部分。\n你可以假设给定的表达式总是有效的。所有中间结果将在 [-231, 231 - 1] 的范围内。\n注意：不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。\n示例 1：\n输入：s = \u0026ldquo;3+2*2\u0026rdquo;\n输出：7\n示例 2：\n输入：s = \u0026quot; 3/2 \u0026quot;\n输出：1\n示例 3：\n输入：s = \u0026quot; 3+5 / 2 \u0026quot;\n输出：5\n提示：\n1 \u0026lt;= s.length \u0026lt;= 3 105\ns 由整数和算符 (\u0026rsquo;+\u0026rsquo;, \u0026lsquo;-\u0026rsquo;, \u0026lsquo;\u0026rsquo;, \u0026lsquo;/\u0026rsquo;) 组成，中间由一些空格隔开\ns 表示一个 有效表达式\n表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内\n题目数据保证答案是一个 32-bit 整数\n解题思路 编译原理： 参考学习教程 文法学习 1 2 E -\u0026gt; T + E | T - E | T E -\u0026gt; E + T | E - T | T 参考的教程2 解题代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 /* * @lc app=leetcode.cn id=227 lang=cpp * * [227] 基本计算器 II */ // #include \u0026lt;iostream\u0026gt; // using namespace std; // @lc code=start struct Node { char type; Node *left; Node *right; int val; Node(char t, Node *l, Node *r, int v) : type(t), left(l), right(r), val(v){}; }; class Solution { public: int calculate(string s1) { s = s1; index = 0; Node *p = parseE(); int res = eval(p); freeTree(p); return res; } string s; int index; int eval(Node *p) { if (p-\u0026gt;type == \u0026#39;0\u0026#39;) { return p-\u0026gt;val; } if (p-\u0026gt;type == \u0026#39;+\u0026#39;) { return eval(p-\u0026gt;left) + eval(p-\u0026gt;right); } else if (p-\u0026gt;type == \u0026#39;-\u0026#39;) { return eval(p-\u0026gt;left) - eval(p-\u0026gt;right); } else if (p-\u0026gt;type == \u0026#39;*\u0026#39;) return eval(p-\u0026gt;left) * eval(p-\u0026gt;right); else if (p-\u0026gt;type == \u0026#39;/\u0026#39;) return eval(p-\u0026gt;left) / eval(p-\u0026gt;right); else return p-\u0026gt;val; } void freeTree(Node *root) { if (!root) { return; } freeTree(root-\u0026gt;left); freeTree(root-\u0026gt;right); delete root; } int getNum() { trimSpace(); int res = 0; while (index \u0026lt; s.size() \u0026amp;\u0026amp; isdigit(s[index])) { res = res * 10 + ( s[index++] - \u0026#39;0\u0026#39;); } return res; } Node *parseE() { Node *b = NULL; Node *a = parseT(); while (index \u0026lt; s.size()) { if (peek() == \u0026#39;+\u0026#39;) { index++; b = parseT(); a = new Node(\u0026#39;+\u0026#39;, a, b, 0); } else if (peek() == \u0026#39;-\u0026#39;) { index++; b = parseT(); a = new Node(\u0026#39;-\u0026#39;, a, b, 0); } else { break; } } return a; } Node *parseT() { Node *b = NULL; trimSpace(); auto a = parseF(); while (index \u0026lt; s.size()) { if (peek() == \u0026#39;*\u0026#39;) { index++; b = parseF(); a = new Node(\u0026#39;*\u0026#39;, a, b, 0); } else if (peek() == \u0026#39;/\u0026#39;) { index++; b = parseF(); a = new Node(\u0026#39;/\u0026#39;, a, b, 0); } else { break; } } return a; } Node *parseF() { if (peek() == \u0026#39;(\u0026#39;) { index++; Node *res = parseE(); if (peek() == \u0026#39;)\u0026#39;) { index++; return res; } } else if (isdigit(s[index])) { int val = getNum(); return new Node(\u0026#39;0\u0026#39;, NULL, NULL, val); } return new Node(\u0026#39;0\u0026#39;, NULL, NULL, 0); } char peek() { trimSpace(); return s[index]; } void trimSpace() { while (index \u0026lt; s.size() \u0026amp;\u0026amp; s[index] == \u0026#39; \u0026#39;) index++; } }; // @lc code=end // int main(void) // { // Solution s; // cout \u0026lt;\u0026lt; s.calculate(\u0026#34;1+1+1\u0026#34;) \u0026lt;\u0026lt; endl; // cout \u0026lt;\u0026lt; \u0026#34;hello worldL\u0026#34; \u0026lt;\u0026lt; endl; // } 通用解法 上面的做法还是有一定的局限性，因为没有总结出一般规律来， 函数会有个优先级处理的问题，我们可以这样理解，每一层函数都不主动去处理字符，而是委托给下一层去处理 输入的符号，如果下一层能解决，这一层就不用解决，如果下一层不解决，那么尝试这一层解决。 我们通过这样 就可以解决符号优先级的问题了，最后可以解析出一个抽象语法树。\nc语言运算符优先级表 做了这道题，我们就有编译原理的基础了，可以实现简单的脚本语言\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 struct Node { char type; Node *left; Node *right; int val; Node(char t, Node *l, Node *r, int v) : type(t), left(l), right(r), val(v){}; }; class Solution { public: int calculate(string s1) { s = s1; index = 0; this -\u0026gt; tables = vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; {{\u0026#39;+\u0026#39;,\u0026#39;-\u0026#39;},{\u0026#39;*\u0026#39;,\u0026#39;/\u0026#39;}}; Node *p = parseE(0); int res = eval(p); freeTree(p); return res; } string s; int index; int eval(Node *p) { if (p-\u0026gt;type == \u0026#39;0\u0026#39;) { return p-\u0026gt;val; } if (p-\u0026gt;type == \u0026#39;+\u0026#39;) { return eval(p-\u0026gt;left) + eval(p-\u0026gt;right); } else if (p-\u0026gt;type == \u0026#39;-\u0026#39;) { return eval(p-\u0026gt;left) - eval(p-\u0026gt;right); } else if (p-\u0026gt;type == \u0026#39;*\u0026#39;) return eval(p-\u0026gt;left) * eval(p-\u0026gt;right); else if (p-\u0026gt;type == \u0026#39;/\u0026#39;) return eval(p-\u0026gt;left) / eval(p-\u0026gt;right); else return p-\u0026gt;val; } void freeTree(Node *root) { if (!root) { return; } freeTree(root-\u0026gt;left); freeTree(root-\u0026gt;right); delete root; } int getNum() { trimSpace(); int res = 0; while (index \u0026lt; s.size() \u0026amp;\u0026amp; isdigit(s[index])) { res = res * 10 + ( s[index++] - \u0026#39;0\u0026#39;); } return res; } //{ {\u0026#39;+\u0026#39;,\u0026#39;-\u0026#39;},{\u0026#39;*\u0026#39;,\u0026#39;/\u0026#39;}} vector\u0026lt;vector\u0026lt;char\u0026gt; \u0026gt; tables; Node *parseE(int k) { if(k\u0026gt;=tables.size()) { // is zero if(peek() == \u0026#39;(\u0026#39;) { index++; auto node = parseE(0); if(peek() == \u0026#39;)\u0026#39;) { index++; }else { printf(\u0026#34;error\\n\u0026#34;); } return node; }else { auto node = new Node(0,NULL,NULL,getNum()); return node; } }else { auto a = parseE(k+1); //combile // Node *b = NULL; while(index \u0026lt; s.size()) { bool flag = false; for(char cc: tables[k]) { if (peek() == cc) { index++; flag = true; a = new Node(cc,a,parseE(k+1),0); } } if(!flag) break; } return a; } return NULL; } char peek() { trimSpace(); return s[index]; } void trimSpace() { while (index \u0026lt; s.size() \u0026amp;\u0026amp; s[index] == \u0026#39; \u0026#39;) index++; } }; ","date":"2022-05-17T23:01:19+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/leetcode-227%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8/","tags":["栈"],"title":"leetcode 227实现计算器"},{"categories":["并查集"],"contents":"剑指117.相似的字符串 ​\n如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。\n例如，\u0026ldquo;tars\u0026rdquo; 和 \u0026ldquo;rats\u0026rdquo; 是相似的 (交换 0 与 2 的位置)； \u0026ldquo;rats\u0026rdquo; 和 \u0026ldquo;arts\u0026rdquo; 也是相似的，但是 \u0026ldquo;star\u0026rdquo; 不与 \u0026ldquo;tars\u0026rdquo;，\u0026ldquo;rats\u0026rdquo;，或 \u0026ldquo;arts\u0026rdquo; 相似。\n总之，它们通过相似性形成了两个关联组：{\u0026ldquo;tars\u0026rdquo;, \u0026ldquo;rats\u0026rdquo;, \u0026ldquo;arts\u0026rdquo;} 和 {\u0026ldquo;star\u0026rdquo;}。注意，\u0026ldquo;tars\u0026rdquo; 和 \u0026ldquo;arts\u0026rdquo; 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。\n给定一个字符串列表 strs。列表中的每个字符串都是 strs 中其它所有字符串的一个 字母异位词 。请问 strs 中有多少个相似字符串组？\n字母异位词（anagram），一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。\n示例 1：\n输入：strs = [\u0026ldquo;tars\u0026rdquo;,\u0026ldquo;rats\u0026rdquo;,\u0026ldquo;arts\u0026rdquo;,\u0026ldquo;star\u0026rdquo;]\n输出：2\n示例 2：\n输入：strs = [\u0026ldquo;omv\u0026rdquo;,\u0026ldquo;ovm\u0026rdquo;]\n输出：1\n提示：\n1 \u0026lt;= strs.length \u0026lt;= 300\n1 \u0026lt;= strs[i].length \u0026lt;= 300\nstrs[i] 只包含小写字母。\nstrs 中的所有单词都具有相同的长度，且是彼此的字母异位词。\n注意：本题与主站 839 题相同： https://leetcode-cn.com/problems/similar-string-groups/ 并查集\r字符串\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 struct UnionFind { vector\u0026lt;int\u0026gt; p; int group; int find(int a) { if(p[a] != a) p[a] = find(p[a]); return p[a]; } void merge(int u,int v) { // p[u] = p[v]; int x = find(u),y = find(v); if (x == y) return ; p[x] = y; group--; } }; class Solution { public: int numSimilarGroups(vector\u0026lt;string\u0026gt;\u0026amp; strs) { UnionFind f; f.p = vector\u0026lt;int\u0026gt;(strs.size()+1); int n = strs.size(); f.group = n; for(int i=0,n = strs.size();i\u0026lt;n;i++) { f.p[i] = i; } for(int i=0;i\u0026lt;n;i++) { for(int j=i+1;j\u0026lt;n;j++) { if(check(strs[i],strs[j])) { f.merge(i,j); } } } return f.group ; } bool check(string \u0026amp;a,string \u0026amp;b) { int n = a.size() ,m = b.size(); if (n!= m) return false ; if(a==b) return true; int last = -1; int dif = 0; int pre = -1; for(int i=0;i\u0026lt;n;i++) { if(a[i] != b[i]) { ++dif; if (last==-1) last = i; else pre = i; } if (dif \u0026gt; 2) return false; } if(dif ==2 \u0026amp;\u0026amp; a[last] == b[pre] \u0026amp;\u0026amp; a[pre] == b[last]) return true; return false; } }; ","date":"2022-05-12T16:24:48+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E5%89%91%E6%8C%87117.%E7%9B%B8%E4%BC%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","tags":["并查集"],"title":"剑指117.相似的字符串"},{"categories":["notes"],"contents":"vscode代码模板功能 ​\n代码片段快捷键 学算法记录 labuladong网站 markdown nice 网站 可以美化代码\n中文文档排版指南 参考文章 https://www.bilibili.com/video/BV1no4y1k7YT/?spm_id_from=333.788.recommend_more_video.-1 ","date":"2022-05-11T23:28:48+08:00","permalink":"https://lyr-2000.github.io/code/post/notes/vscode%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E5%8A%9F%E8%83%BD/","tags":["notes"],"title":"vscode代码模板功能"},{"categories":["dp"],"contents":"通配符匹配算法 ​\n参考leetcode44.通配符匹配 给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 \u0026lsquo;?\u0026rsquo; 和 \u0026lsquo;*\u0026rsquo; 的通配符匹配。\n\u0026lsquo;?\u0026rsquo; 可以匹配任何单个字符。\n\u0026lsquo;*\u0026rsquo; 可以匹配任意字符串（包括空字符串）。\n两个字符串完全匹配才算匹配成功。\n说明:\ns 可能为空，且只包含从 a-z 的小写字母。\np 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。\n示例 1:\n输入:\ns = \u0026ldquo;aa\u0026rdquo;\np = \u0026ldquo;a\u0026rdquo;\n输出: false\n解释: \u0026ldquo;a\u0026rdquo; 无法匹配 \u0026ldquo;aa\u0026rdquo; 整个字符串。\n示例 2:\n输入:\ns = \u0026ldquo;aa\u0026rdquo;\np = \u0026ldquo;\u0026rdquo;\n输出: true\n解释: \u0026lsquo;\u0026rsquo; 可以匹配任意字符串。\n示例 3:\n输入:\ns = \u0026ldquo;cb\u0026rdquo;\np = \u0026ldquo;?a\u0026rdquo;\n输出: false\n解释: \u0026lsquo;?\u0026rsquo; 可以匹配 \u0026lsquo;c\u0026rsquo;, 但第二个 \u0026lsquo;a\u0026rsquo; 无法匹配 \u0026lsquo;b\u0026rsquo;。\n示例 4:\n输入:\ns = \u0026ldquo;adceb\u0026rdquo;\np = \u0026ldquo;ab\u0026rdquo;\n输出: true\n解释: 第一个 \u0026lsquo;\u0026rsquo; 可以匹配空字符串, 第二个 \u0026lsquo;\u0026rsquo; 可以匹配字符串 \u0026ldquo;dce\u0026rdquo;.\n示例 5:\n输入:\ns = \u0026ldquo;acdcb\u0026rdquo;\np = \u0026ldquo;a*c?b\u0026rdquo;\n输出: false\n参考 http-router通配符匹配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: bool isMatch(string s, string p) { int n = s.size(), m = p.size(); int i=0,j=0; int wildcard = -1; int last = 0; while(i\u0026lt; n) { if(s[i] == p[j] || p[j] == \u0026#39;?\u0026#39;) { i++;j++; continue; } if (p[j] == \u0026#39;*\u0026#39;) { //wildcard wildcard = j++; // not match , and test p[i] is match p[j+1] last = i; continue; } //not match any if(wildcard!=-1) {//无法匹配，就回溯到 上一个 * j =wildcard+1; i = ++last; //假设 p[wildcard] 和 s[last] 匹配，那么就 继续 test p[wildcard] 和 s[last+1] continue; } // 找不到 return false; } while(j\u0026lt;m \u0026amp;\u0026amp; p[j] == \u0026#39;*\u0026#39;) j++; return j == m; } }; 动规解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: bool isMatch(string s, string p) { int n = s.size(), m = p.size(); vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; dp(n+1,vector\u0026lt;int\u0026gt; (m+1)); // *** 匹配0个字符 dp[0][0] = 1; for(int i=1;i\u0026lt;=m;i++) { dp[0][i] = dp[0][i-1] \u0026amp;\u0026amp; p[i-1] == \u0026#39;*\u0026#39;; } for(int i=1;i\u0026lt;=n;i++) { for(int j=1;j\u0026lt;=m;j++) { // 匹配 1-\u0026gt; i ,1-\u0026gt;j 个字符 char y = p[j-1]; char x = s[i-1]; if(y==x || y == \u0026#39;?\u0026#39;) { dp[i][j] = dp[i-1][j-1];// match ok } if(y==\u0026#39;*\u0026#39;) { // 0 (i-1,j) // 1 (i,j-1) dp[i][j] = dp[i-1][j] || dp[i][j-1]; } } } return dp[n][m]; } }; dp\r动态规划\r字符串匹配\r","date":"2022-05-11T20:02:48+08:00","permalink":"https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/dp/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BBdp/%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/","tags":["dp"],"title":"通配符匹配算法"},{"categories":["docs"],"contents":"shell 文档网站 awk 使用教程 ","date":"2022-05-11T20:02:48+08:00","permalink":"https://lyr-2000.github.io/code/post/docs/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/","tags":["docs"],"title":"准备工作"},{"categories":null,"contents":"","date":"2021-08-14T22:42:48+08:00","permalink":"https://lyr-2000.github.io/code/home/","tags":null,"title":"首页"},{"categories":null,"contents":"算法学习网站收集 注意，这个是专门学习 算法的独立文档站，不接受友链，需要友链的请 选择 根节点站\ngeeksforgeeks\r学算法网站\r与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n1 2 3 4 5 name: \u0026#34;凌冬的个人博客\u0026#34; # 昵称 desc: \u0026#34;过去不优秀，不代表未来不精彩！\u0026#34; # 介绍 avatar: \u0026#34;https://blog.lyr-2000.xyz/avatar.png\u0026#34; # 头像 link: \u0026#34;https://blog.lyr-2000.xyz\u0026#34; # 链接 siteshot: \u0026#34;https://blog.lyr-2000.xyz/siteshot.png\u0026#34; # 页面截图 欢迎和我交换友链,申请前记得先添加本站哦,~\n","date":"2019-12-25T14:27:01Z","permalink":"https://lyr-2000.github.io/code/friends/","tags":null,"title":"友情链接"},{"categories":null,"contents":"链上数据分析工具 Dune\nGlassnode\nToken Terminal\nEigenphi\nNansen\nFootprint\nhttps://dune.com/home ","date":null,"permalink":"https://lyr-2000.github.io/code/post/docs/%E9%93%BE%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/","tags":null,"title":""}]