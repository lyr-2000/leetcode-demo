<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>字符串 on 凌冬的代码博客站</title><link>https://lyr-2000.github.io/code/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><description>Recent content in 字符串 on 凌冬的代码博客站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>LYR</copyright><lastBuildDate>Sat, 15 Oct 2022 18:58:31 +0800</lastBuildDate><atom:link href="https://lyr-2000.github.io/code/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/index.xml" rel="self" type="application/rss+xml"/><item><title>lc.32.最长有效括号</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</link><pubDate>Sat, 15 Oct 2022 18:58:31 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</guid><description>32. 最长有效括号 Description Difficulty: 困难 Related Topics: 栈 , 字符串 , 动态规划 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。 示例 1： 1 2 3 输入</description></item><item><title>lc.17.17多次搜索</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.17.17%E5%A4%9A%E6%AC%A1%E6%90%9C%E7%B4%A2/</link><pubDate>Sat, 15 Oct 2022 18:42:00 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.17.17%E5%A4%9A%E6%AC%A1%E6%90%9C%E7%B4%A2/</guid><description>面试题 17.17. 多次搜索 Description Difficulty: 中等 Related Topics: 字典树 , 数组 , 哈希表 , 字符串 , 字符串匹配 , 滑动窗口 给定一个较长字符串big和一个包含较短字符串的数组smalls</description></item><item><title>lc.12.整数转罗马数字</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.12.%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</link><pubDate>Wed, 12 Oct 2022 21:31:59 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.12.%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</guid><description>12. 整数转罗马数字 Description Difficulty: 中等 Related Topics: 哈希表 , 数学 , 字符串 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 1 2 3 4 5 6 7 8 字符 数值 I 1 V 5 X 10 L</description></item><item><title>lc.14.最长公共前缀</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.14.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</link><pubDate>Wed, 12 Oct 2022 20:43:36 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.14.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</guid><description>14. 最长公共前缀 Description Difficulty: 简单 Related Topics: 字符串 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &amp;quot;&amp;quot;。 示例</description></item><item><title>lc.3.无重复字符的最长子串</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link><pubDate>Tue, 11 Oct 2022 23:52:11 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid><description>3. 无重复字符的最长子串 Description Difficulty: 中等 Related Topics: 哈希表 , 字符串 , 滑动窗口 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度。 示例 1: 1 2 3 输入: s</description></item><item><title>lc.28.实现strStr()</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.28.%E5%AE%9E%E7%8E%B0strstr/</link><pubDate>Tue, 11 Oct 2022 22:06:18 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.28.%E5%AE%9E%E7%8E%B0strstr/</guid><description>28. 找出字符串中第一个匹配项的下标 Description Difficulty: 中等 Related Topics: 双指针 , 字符串 , 字符串匹配 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标</description></item><item><title>manacher算法</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/manacher%E7%AE%97%E6%B3%95/</link><pubDate>Tue, 11 Oct 2022 00:27:11 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/manacher%E7%AE%97%E6%B3%95/</guid><description>5. 最长回文子串 Description Difficulty: 中等 Related Topics: 字符串 , 动态规划 给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 1 2 3 输入：s = &amp;#34;babad&amp;#34; 输出：&amp;#34;bab&amp;#34</description></item><item><title>lc.214.最短回文串</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.214.%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2/</link><pubDate>Mon, 10 Oct 2022 22:38:17 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.214.%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2/</guid><description>214. 最短回文串 Description Difficulty: 困难 Related Topics: 字符串 , 字符串匹配 , 哈希函数 , 滚动哈希 给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可</description></item><item><title>lc.1392.最长快乐前缀</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.1392.%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%89%8D%E7%BC%80/</link><pubDate>Mon, 10 Oct 2022 22:31:43 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.1392.%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%89%8D%E7%BC%80/</guid><description>1392. 最长快乐前缀 Description Difficulty: 困难 Related Topics: 字符串 , 字符串匹配 , 哈希函数 , 滚动哈希 「快乐前缀」 是在原字符串中既是 非空 前缀也是后缀（不包括原字符串自身）的字符串</description></item><item><title>lc.459.重复的子字符串</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Mon, 10 Oct 2022 22:18:02 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/lc.459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>459. 重复的子字符串 Description Difficulty: 简单 Related Topics: 字符串 , 字符串匹配 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。 示例 1: 1 2 3 输入: s = &amp;#34;abab&amp;#34; 输</description></item><item><title>shift-and算法</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/shift-and%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 10 Oct 2022 20:59:33 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/shift-and%E7%AE%97%E6%B3%95/</guid><description>shift and 算法 Shift-And算法是一种基于前缀的单字符串匹配算法，采用位运算。其算法思想比KMP简单得多。 在最简单的brute force算法中</description></item><item><title>sunday算法</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/sunday%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 10 Oct 2022 00:25:57 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/sunday%E7%AE%97%E6%B3%95/</guid><description>sunday算法 KMP算法是一个里程碑似的算法，它的出现宣告了人类是找到线性时间复杂度的字符串匹配算法的。在这之后，出现了许多的字符串匹配算</description></item><item><title>kmp匹配算法</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/kmp%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</link><pubDate>Sun, 09 Oct 2022 21:35:28 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/kmp%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</guid><description>KMP 匹配算法 预处理过程： pre_4 == last_4 pre_3 == last_3 pre_2 == last_2 如果不是最长的后缀，就可能错过答案的位置，要保证后缀和前缀最长。 证明 两个串可以直接匹配： $$ TA == TB\ SA ==</description></item></channel></rss>