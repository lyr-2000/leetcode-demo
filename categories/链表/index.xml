<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>链表 on 凌冬的代码博客站</title><link>https://lyr-2000.github.io/code/categories/%E9%93%BE%E8%A1%A8/</link><description>Recent content in 链表 on 凌冬的代码博客站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>LYR</copyright><lastBuildDate>Sat, 07 Dec 2024 00:49:32 +0800</lastBuildDate><atom:link href="https://lyr-2000.github.io/code/categories/%E9%93%BE%E8%A1%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>两两交换链表</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8/</link><pubDate>Sat, 07 Dec 2024 00:49:32 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8/</guid><description>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 1 2 3 4</description></item><item><title>删除链表第k个节点</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</link><pubDate>Sat, 07 Dec 2024 00:30:02 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</guid><description>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next</description></item><item><title>lc.2816.翻倍以链表形式表示的数字</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.2816.%E7%BF%BB%E5%80%8D%E4%BB%A5%E9%93%BE%E8%A1%A8%E5%BD%A2%E5%BC%8F%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%95%B0%E5%AD%97/</link><pubDate>Sun, 21 Jan 2024 14:30:28 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.2816.%E7%BF%BB%E5%80%8D%E4%BB%A5%E9%93%BE%E8%A1%A8%E5%BD%A2%E5%BC%8F%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%95%B0%E5%AD%97/</guid><description>leetcode 2816.翻倍以链表形式表示的数字 algorithms Medium (57.46%) Likes: 19 Dislikes: 0 Total Accepted: 7.3K Total Submissions: 12.6K Testcase Example: &amp;lsquo;[1,8,9]&amp;rsquo; 给你一个 非空 链表的头节点 head ，表示一个不含前导零的非负数整数。 将链表 翻倍 后</description></item><item><title>lc.2130.链表的孪生和</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.2130.%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%AA%E7%94%9F%E5%92%8C/</link><pubDate>Sun, 23 Oct 2022 21:28:19 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.2130.%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%AA%E7%94%9F%E5%92%8C/</guid><description>2130. 链表最大孪生和 Description Difficulty: 中等 Related Topics: 栈 , 链表 , 双指针 在一个大小为 n 且 n 为 偶数 的链表中，对于 0 &amp;lt;= i &amp;lt;= (n / 2) - 1 的 i ，第 i 个节点（下标从 0 开始）的孪生节</description></item><item><title>lc.029.排序的循环链表</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.029.%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</link><pubDate>Wed, 19 Oct 2022 21:58:35 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.029.%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</guid><description>剑指 Offer II 029. 排序的循环链表 Description Difficulty: 中等 Related Topics: 链表 给定循环单调非递减列表中的一个点，写一个函数向这个列表中插入一个新元素 insertVal ，使这个列表仍然是循环升序的</description></item><item><title>lc.82.删除链表重复节点</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.82.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</link><pubDate>Sun, 28 Aug 2022 22:39:02 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.82.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</guid><description>82. 删除排序链表中的重复元素 II Description Difficulty: 中等 Related Topics: 链表 , 双指针 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排</description></item><item><title>lc.92.翻转链表2</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.92.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A82/</link><pubDate>Sun, 28 Aug 2022 22:30:26 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.92.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A82/</guid><description>92. 反转链表 II Description Difficulty: 中等 Related Topics: 链表 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &amp;lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 示例 1：</description></item><item><title>lc.202.快乐数</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.202.%E5%BF%AB%E4%B9%90%E6%95%B0/</link><pubDate>Sun, 28 Aug 2022 21:37:39 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.202.%E5%BF%AB%E4%B9%90%E6%95%B0/</guid><description>202. 快乐数 Description Difficulty: 简单 Related Topics: 哈希表 , 数学 , 双指针 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」 定义为： 对于一个正整数，每一次将该数替换为它每个位</description></item><item><title>链表基础</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80/</link><pubDate>Sun, 28 Aug 2022 17:07:48 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80/</guid><description>定义链表的实现方法 指针实现链表 1 2 3 4 type Node { int data; Node *next; } 静态数组实现链表 通过相对地址实现链表 1 2 3 4 5 6 7 8 int data[10]; int next[10]; void add(int ind,int p,int val) { next[ind] = p; data[p] = val; return;</description></item><item><title>环形链表</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 01 Aug 2022 01:09:32 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid><description>142. 环形链表 II Description Difficulty: 中等 Related Topics: 哈希表 , 链表 , 双指针 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有</description></item><item><title>k个一组翻转链表</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.25.k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 01 Aug 2022 01:02:32 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/lc.25.k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid><description>25. K 个一组翻转链表 Description Difficulty: 困难 Related Topics: 递归 , 链表 给你链表的头节点 head ，每 k个节点一组进行翻转，请你返回修改后的链表。 k 是一个正整数，它的值小于或等于链</description></item></channel></rss>